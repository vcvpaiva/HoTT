<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Sequential.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="sd">(** We present a proof of the conjecture that sequential colimits in HoTT apropriately commute with Œ£-types. As a corollary, we characterize the path space of a sequential colimit as a sequential colimit of path spaces. For the written account of these results see https://www.cs.cornell.edu/~ks858/papers/sequential_colimits_homotopy.pdf. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Basics.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Types.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Diagrams.Diagram.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Diagrams.Sequence.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Diagrams.Cocone.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Colimits.Colimit.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Spaces.Nat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> HProp.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> PathAny.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> nat_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">coe</span> := (transport idmap).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;a ^+&quot;</span> := (@arr sequence_graph _ _ _ <span class="mi">1</span> a).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk0"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_shift_from_zero_by</span> {<span class="nv">A</span> : Sequence} (<span class="nv">a</span> : A <span class="mi">0</span>) <span class="nv">k</span> : A k.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A k</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A k</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk2"><span class="highlight"><span class="nb">induction</span> k <span class="kr">as</span> [ | k q].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A <span class="mi">0</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A k</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk3"><hr></label><div class="goal-conclusion"><span class="highlight">A k.+<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A <span class="mi">0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> a.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A k.+<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> q^+.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;a ^+ k&quot;</span> := (seq_shift_from_zero_by a k).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Shiftings; described in the paragraph after Lemma 3.7. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_pair_shift</span> {<span class="nv">A</span> : Sequence} (<span class="nv">x</span> : sig A) : sig A.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> x <span class="kr">as</span> [n a]; <span class="bp">exact</span> (n.+<span class="mi">1</span>; a^+).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk8"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_pair_shift_by</span> {<span class="nv">A</span> : Sequence} (<span class="nv">x</span> : sig A) (<span class="nv">k</span> : nat) : sig A.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka"><span class="highlight"><span class="nb">induction</span> k <span class="kr">as</span> [ | k y].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x}</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chkb"><hr></label><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x}</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (seq_pair_shift y).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x ^++&quot;</span> := (seq_pair_shift x).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x ^++ k&quot;</span> := (seq_pair_shift_by x k).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_pair_shift_assoc</span> {<span class="nv">A</span> : Sequence} (<span class="nv">x</span> : sig A) (<span class="nv">k</span> : nat)
  : (x^++)^++k = x^++(k.+<span class="mi">1</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((x) ^++) ^++ (k) = (x) ^++ (k.+<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((x) ^++) ^++ (k) = (x) ^++ (k.+<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10"><span class="highlight"><span class="nb">induction</span> k <span class="kr">as</span> [ | k q].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((x) ^++) ^++ (<span class="mi">0</span>) = (x) ^++ (<span class="mi">1</span>)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk11" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">((x) ^++) ^++ (k) = (x) ^++ (k.+<span class="mi">1</span>)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk11"><hr></label><div class="goal-conclusion"><span class="highlight">((x) ^++) ^++ (k.+<span class="mi">1</span>) = (x) ^++ (k.+<span class="mi">2</span>)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((x) ^++) ^++ (<span class="mi">0</span>) = (x) ^++ (<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">((x) ^++) ^++ (k) = (x) ^++ (k.+<span class="mi">1</span>)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((x) ^++) ^++ (k.+<span class="mi">1</span>) = (x) ^++ (k.+<span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (ap seq_pair_shift q).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_shift_pair_from_zero</span> {<span class="nv">A</span> : Sequence} (<span class="nv">a</span> : A <span class="mi">0</span>) <span class="nv">k</span> : (<span class="mi">0</span>;a)^++k = (k;a^+k).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((<span class="mi">0</span>; a)) ^++ (k) = (k; (a) ^+ (k))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk15"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((<span class="mi">0</span>; a)) ^++ (k) = (k; (a) ^+ (k))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16"><span class="highlight"><span class="nb">induction</span> k <span class="kr">as</span> [ | k q].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((<span class="mi">0</span>; a)) ^++ (<span class="mi">0</span>) = (<span class="mi">0</span>; (a) ^+ (<span class="mi">0</span>))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk17" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">((<span class="mi">0</span>; a)) ^++ (k) = (k; (a) ^+ (k))</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk17"><hr></label><div class="goal-conclusion"><span class="highlight">((<span class="mi">0</span>; a)) ^++ (k.+<span class="mi">1</span>) = (k.+<span class="mi">1</span>; (a) ^+ (k.+<span class="mi">1</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk18"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((<span class="mi">0</span>; a)) ^++ (<span class="mi">0</span>) = (<span class="mi">0</span>; (a) ^+ (<span class="mi">0</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk19"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">((<span class="mi">0</span>; a)) ^++ (k) = (k; (a) ^+ (k))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((<span class="mi">0</span>; a)) ^++ (k.+<span class="mi">1</span>) = (k.+<span class="mi">1</span>; (a) ^+ (k.+<span class="mi">1</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (ap seq_pair_shift q).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">inj</span> A := (@colim sequence_graph A).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">glue</span> A := (<span class="kr">fun</span> <span class="nv">n</span> =&gt; @colimp sequence_graph A n n.+<span class="mi">1</span> <span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The uniqueness principle for sequential colimits; Lemma 3.3. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1a"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colimit_uniq</span> {<span class="nv">A</span> : Sequence} <span class="nv">E</span> (<span class="nv">F</span> <span class="nv">G</span> : Colimit A -&gt; E)
  (<span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">n</span>, F o inj A n == G o inj A n)
  (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span>, ap F (glue A n a) @ h n a = h n.+<span class="mi">1</span> a^+ @ ap G (glue A n a))
  : F == G.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F, G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Colimit A -&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
F o inj A n == G o inj A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n),
ap F (glue A n a) @ h n a =
h n.+<span class="mi">1</span> (a) ^+ @ ap G (glue A n a)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">F == G</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F, G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Colimit A -&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
F o inj A n == G o inj A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n),
ap F (glue A n a) @ h n a =
h n.+<span class="mi">1</span> (a) ^+ @ ap G (glue A n a)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">F == G</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1c"><span class="highlight">srapply (Colimit_ind _ h); <span class="nb">intros</span> n m p a; <span class="nb">destruct</span> p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F, G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Colimit A -&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
F o inj A n == G o inj A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n),
ap F (glue A n a) @ h n a =
h n.+<span class="mi">1</span> (a) ^+ @ ap G (glue A n a)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt; F w = G w)
  (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a) (h n.+<span class="mi">1</span> (a) ^+) = h n a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1d"><span class="highlight"><span class="nb">generalize</span> (H n a); <span class="nb">generalize</span> (h n a); <span class="nb">destruct</span> (glue A n a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F, G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Colimit A -&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
F o inj A n == G o inj A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n),
ap F (glue A n a) @ h n a =
h n.+<span class="mi">1</span> (a) ^+ @ ap G (glue A n a)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span>
<span class="nv">p</span> : F (inj A n.+<span class="mi">1</span> (a) ^+) = G (inj A n.+<span class="mi">1</span> (a) ^+),
ap F <span class="mi">1</span> @ p = h n.+<span class="mi">1</span> (a) ^+ @ ap G <span class="mi">1</span> -&gt;
transport (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt; F w = G w) <span class="mi">1</span>
  (h n.+<span class="mi">1</span> (a) ^+) = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> p q; srefine ((concat_p1 _)^ @ _); srefine (_ @ (concat_1p _)); <span class="bp">exact</span> q^.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The successor sequence from Lemma 3.6. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">succ_seq</span> (<span class="nv">A</span> : Sequence) : Sequence
  := Build_Sequence (<span class="kr">fun</span> <span class="nv">k</span> =&gt; A k.+<span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">a</span> =&gt; a^+).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The shifted sequence from Lemma 3.7. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">shift_seq</span> (<span class="nv">A</span> : Sequence) <span class="nv">n</span> : Sequence
  := Build_Sequence (<span class="kr">fun</span> <span class="nv">k</span> =&gt; A (k+n)%nat) (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">a</span> =&gt; a^+).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The canonical equivalence between the colimit of the succesor sequence and the colimit of the original sequence; Lemma 3.6. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1e"><span class="highlight"><span class="kn">Definition</span> <span class="nf">colim_succ_seq_to_colim_seq</span> <span class="nv">A</span> : Colimit (succ_seq A) -&gt; Colimit A.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (succ_seq A) -&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk1f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (succ_seq A) -&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk20"><span class="highlight">srapply Colimit_rec; srapply Build_Cocone.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
succ_seq A i -&gt; Colimit A</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk21"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o (succ_seq A) _f g == <span class="nl">?legs</span> i</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk22"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
succ_seq A i -&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; inj _ n.+<span class="mi">1</span> a).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk23"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a</span> : succ_seq A n) =&gt; inj A n.+<span class="mi">1</span> a) j
o (succ_seq A) _f g ==
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a</span> : succ_seq A n) =&gt; inj A n.+<span class="mi">1</span> a) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> n m p; <span class="nb">destruct</span> p; <span class="bp">exact</span> (glue A n.+<span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk24"><span class="highlight"><span class="kn">Definition</span> <span class="nf">colim_succ_seq_to_colim_seq_beta_glue</span> <span class="nv">A</span> <span class="nv">n</span> <span class="nv">a</span>
  : ap (colim_succ_seq_to_colim_seq A) (glue (succ_seq A) n a) = glue A (n.+<span class="mi">1</span>) a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">succ_seq A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (colim_succ_seq_to_colim_seq A)
  (glue (succ_seq A) n a) = glue A n.+<span class="mi">1</span> a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk25"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">succ_seq A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (colim_succ_seq_to_colim_seq A)
  (glue (succ_seq A) n a) = glue A n.+<span class="mi">1</span> a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply Colimit_rec_beta_colimp.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk26"><span class="highlight"><span class="kn">Definition</span> <span class="nf">colim_succ_seq_to_colim_seq_ap_inj</span> <span class="nv">A</span> <span class="nv">n</span> (<span class="nv">a1</span> <span class="nv">a2</span> : succ_seq A n) (<span class="nv">p</span> : a1 = a2)
  : ap (colim_succ_seq_to_colim_seq A) (ap (inj _ n) p) = ap (inj _ n.+<span class="mi">1</span>) p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">succ_seq A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a1 = a2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (colim_succ_seq_to_colim_seq A)
  (ap (inj (succ_seq A) n) p) = ap (inj A n.+<span class="mi">1</span>) p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk27"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">succ_seq A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a1 = a2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (colim_succ_seq_to_colim_seq A)
  (ap (inj (succ_seq A) n) p) = ap (inj A n.+<span class="mi">1</span>) p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk28"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_colim_succ_seq_to_colim_seq</span> <span class="nv">A</span>
  : IsEquiv (colim_succ_seq_to_colim_seq A).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (colim_succ_seq_to_colim_seq A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk29"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (colim_succ_seq_to_colim_seq A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk2a"><span class="highlight">srapply isequiv_adjointify.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit A -&gt; Colimit (succ_seq A)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk2b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk2b"><hr></label><div class="goal-conclusion"><span class="highlight">colim_succ_seq_to_colim_seq A o <span class="nl">?g</span> == idmap</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chk2c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk2c"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?g</span> o colim_succ_seq_to_colim_seq A == idmap</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk2d"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit A -&gt; Colimit (succ_seq A)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk2e"><span class="highlight">srapply Colimit_rec; srapply Build_Cocone.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
A i -&gt; Colimit (succ_seq A)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk2f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk2f"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o A _f g == <span class="nl">?legs</span> i</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk30"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
A i -&gt; Colimit (succ_seq A)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; inj (succ_seq A) n a^+).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk31"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n) =&gt;
 inj (succ_seq A) n (a) ^+) j o A _f g ==
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n) =&gt;
 inj (succ_seq A) n (a) ^+) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> n m p a; <span class="nb">destruct</span> p; <span class="bp">exact</span> (glue (succ_seq A) n a^+).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk32"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">colim_succ_seq_to_colim_seq A
o Colimit_rec (Colimit (succ_seq A))
    {|
      legs :=
        <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
          (<span class="nv">a</span> : A n) =&gt; inj (succ_seq A) n (a) ^+;
      legs_comm :=
        <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
          (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
          (<span class="nv">a</span> : A n) =&gt;
        <span class="kr">match</span>
          p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
          <span class="kr">return</span>
            (inj (succ_seq A) y ((A _f p0) a) ^+ =
             inj (succ_seq A) n (a) ^+)
        <span class="kr">with</span>
        | <span class="mi">1</span> =&gt; glue (succ_seq A) n (a) ^+
        <span class="kr">end</span>
    |} == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk33"><span class="highlight">srapply seq_colimit_uniq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
 colim_succ_seq_to_colim_seq A
   (Colimit_rec (Colimit (succ_seq A))
      {|
        legs :=
          <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
            (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 (a) ^+;
        legs_comm :=
          <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
            (<span class="nv">a</span> : A n0) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
            <span class="kr">return</span>
              (inj (succ_seq A) y ((A _f p0) a) ^+ =
               inj (succ_seq A) n0 (a) ^+)
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 (a) ^+
          <span class="kr">end</span>
      |} x)) o inj A n == idmap o inj A n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk34"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   colim_succ_seq_to_colim_seq A
     (Colimit_rec (Colimit (succ_seq A))
        {|
          legs :=
            <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
              (<span class="nv">a0</span> : A n0) =&gt;
            inj (succ_seq A) n0 (a0) ^+;
          legs_comm :=
            <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
              (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
              (<span class="nv">a0</span> : A n0) =&gt;
            <span class="kr">match</span>
              p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
              <span class="kr">return</span>
                (inj (succ_seq A) y ((A _f p0) a0) ^+ =
                 inj (succ_seq A) n0 (a0) ^+)
            <span class="kr">with</span>
            | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 (a0) ^+
            <span class="kr">end</span>
        |} x)) (glue A n a) @ <span class="nl">?h</span> n a =
<span class="nl">?h</span> n.+<span class="mi">1</span> (a) ^+ @ ap idmap (glue A n a)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk35"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
 colim_succ_seq_to_colim_seq A
   (Colimit_rec (Colimit (succ_seq A))
      {|
        legs :=
          <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
            (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 (a) ^+;
        legs_comm :=
          <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
            (<span class="nv">a</span> : A n0) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
            <span class="kr">return</span>
              (inj (succ_seq A) y ((A _f p0) a) ^+ =
               inj (succ_seq A) n0 (a) ^+)
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 (a) ^+
          <span class="kr">end</span>
      |} x)) o inj A n == idmap o inj A n</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; glue _ n a).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk36"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit A =&gt;
   colim_succ_seq_to_colim_seq A
     (Colimit_rec (Colimit (succ_seq A))
        {|
          legs :=
            <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
              (<span class="nv">a0</span> : A n0) =&gt;
            inj (succ_seq A) n0 (a0) ^+;
          legs_comm :=
            <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
              (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
              (<span class="nv">a0</span> : A n0) =&gt;
            <span class="kr">match</span>
              p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
              <span class="kr">return</span>
                (inj (succ_seq A) y ((A _f p0) a0) ^+ =
                 inj (succ_seq A) n0 (a0) ^+)
            <span class="kr">with</span>
            | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 (a0) ^+
            <span class="kr">end</span>
        |} x)) (glue A n a) @
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a0</span> : A n0) =&gt;
 glue A n0 a0) n a =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a0</span> : A n0) =&gt;
 glue A n0 a0) n.+<span class="mi">1</span> (a) ^+ @ ap idmap (glue A n a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk37"><span class="highlight"><span class="nb">intros</span> n a; <span class="nb">rewrite</span> ap_idmap, ap_compose, Colimit_rec_beta_colimp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (colim_succ_seq_to_colim_seq A)
  (legs_comm
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a</span> : A n) =&gt; inj (succ_seq A) n (a) ^+;
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
           (<span class="nv">a</span> : A n) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
           <span class="kr">return</span>
             (inj (succ_seq A) y ((A _f p0) a) ^+ =
              inj (succ_seq A) n (a) ^+)
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; colimp n n.+<span class="mi">1</span> <span class="mi">1</span> (a) ^+
         <span class="kr">end</span>
     |} n n.+<span class="mi">1</span> <span class="mi">1</span> a) @ colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a =
colimp n.+<span class="mi">1</span> n.+<span class="mi">2</span> <span class="mi">1</span> (a) ^+ @ colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> colim_succ_seq_to_colim_seq_beta_glue; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk38"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit_rec (Colimit (succ_seq A))
  {|
    legs :=
      <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
      =&gt; inj (succ_seq A) n (a) ^+;
    legs_comm :=
      <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
        (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
        (<span class="nv">a</span> : A n) =&gt;
      <span class="kr">match</span>
        p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
        <span class="kr">return</span>
          (inj (succ_seq A) y ((A _f p0) a) ^+ =
           inj (succ_seq A) n (a) ^+)
      <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; glue (succ_seq A) n (a) ^+
      <span class="kr">end</span>
  |} o colim_succ_seq_to_colim_seq A == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk39"><span class="highlight">srapply seq_colimit_uniq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (succ_seq A) =&gt;
 Colimit_rec (Colimit (succ_seq A))
   {|
     legs :=
       <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
         (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 (a) ^+;
     legs_comm :=
       <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
         (<span class="nv">a</span> : A n0) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (inj (succ_seq A) y ((A _f p0) a) ^+ =
            inj (succ_seq A) n0 (a) ^+)
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 (a) ^+
       <span class="kr">end</span>
   |} (colim_succ_seq_to_colim_seq A x))
o inj (succ_seq A) n == idmap o inj (succ_seq A) n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk3a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk3a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : succ_seq A n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (succ_seq A) =&gt;
   Colimit_rec (Colimit (succ_seq A))
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a0</span> : A n0) =&gt; inj (succ_seq A) n0 (a0) ^+;
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
           (<span class="nv">a0</span> : A n0) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
           <span class="kr">return</span>
             (inj (succ_seq A) y ((A _f p0) a0) ^+ =
              inj (succ_seq A) n0 (a0) ^+)
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 (a0) ^+
         <span class="kr">end</span>
     |} (colim_succ_seq_to_colim_seq A x))
  (glue (succ_seq A) n a) @ <span class="nl">?h</span> n a =
<span class="nl">?h</span> n.+<span class="mi">1</span> (a) ^+ @ ap idmap (glue (succ_seq A) n a)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3b"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (succ_seq A) =&gt;
 Colimit_rec (Colimit (succ_seq A))
   {|
     legs :=
       <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
         (<span class="nv">a</span> : A n0) =&gt; inj (succ_seq A) n0 (a) ^+;
     legs_comm :=
       <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
         (<span class="nv">a</span> : A n0) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (inj (succ_seq A) y ((A _f p0) a) ^+ =
            inj (succ_seq A) n0 (a) ^+)
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 (a) ^+
       <span class="kr">end</span>
   |} (colim_succ_seq_to_colim_seq A x))
o inj (succ_seq A) n == idmap o inj (succ_seq A) n</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; glue _ n a).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3c"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : succ_seq A n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (succ_seq A) =&gt;
   Colimit_rec (Colimit (succ_seq A))
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a0</span> : A n0) =&gt; inj (succ_seq A) n0 (a0) ^+;
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
           (<span class="nv">a0</span> : A n0) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
           <span class="kr">return</span>
             (inj (succ_seq A) y ((A _f p0) a0) ^+ =
              inj (succ_seq A) n0 (a0) ^+)
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; glue (succ_seq A) n0 (a0) ^+
         <span class="kr">end</span>
     |} (colim_succ_seq_to_colim_seq A x))
  (glue (succ_seq A) n a) @
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : succ_seq A n0) =&gt; glue (succ_seq A) n0 a0) n
  a =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : succ_seq A n0) =&gt; glue (succ_seq A) n0 a0)
  n.+<span class="mi">1</span> (a) ^+ @ ap idmap (glue (succ_seq A) n a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3d"><span class="highlight"><span class="nb">intros</span> n a; <span class="nb">rewrite</span> ap_idmap, ap_compose, Colimit_rec_beta_colimp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">succ_seq A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (Colimit_rec (Colimit (succ_seq A))
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a</span> : A n) =&gt; inj (succ_seq A) n (a) ^+;
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
           (<span class="nv">a</span> : A n) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
           <span class="kr">return</span>
             (inj (succ_seq A) y ((A _f p0) a) ^+ =
              inj (succ_seq A) n (a) ^+)
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; colimp n n.+<span class="mi">1</span> <span class="mi">1</span> (a) ^+
         <span class="kr">end</span>
     |})
  (legs_comm
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a</span> : succ_seq A n) =&gt; inj A n.+<span class="mi">1</span> a;
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
           <span class="kr">return</span>
             ((<span class="kr">fun</span> <span class="nv">x</span> : succ_seq A n =&gt;
               inj A y.+<span class="mi">1</span> (((succ_seq A) _f p0) x)) ==
              (<span class="kr">fun</span> <span class="nv">a</span> : succ_seq A n =&gt; inj A n.+<span class="mi">1</span> a))
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt; colimp n.+<span class="mi">1</span> n.+<span class="mi">2</span> <span class="mi">1</span>
         <span class="kr">end</span>
     |} n n.+<span class="mi">1</span> <span class="mi">1</span> a) @ colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a =
colimp n.+<span class="mi">1</span> n.+<span class="mi">2</span> <span class="mi">1</span> (a) ^+ @ colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> (@Colimit_rec_beta_colimp _ A _ _ _ _ <span class="mi">1</span>); <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_colim_succ_seq_to_colim_seq</span> <span class="nv">A</span> : Colimit (succ_seq A) &lt;~&gt; Colimit A
  := Build_Equiv _ _ (colim_succ_seq_to_colim_seq A) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The canonical equivalence between the colimit of the shifted sequence and the colimit of the original sequence; Lemma 3.6. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3e"><span class="highlight"><span class="kn">Definition</span> <span class="nf">colim_shift_seq_to_colim_seq</span> <span class="nv">A</span> <span class="nv">n</span> : Colimit (shift_seq A n) -&gt; Colimit A.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (shift_seq A n) -&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk3f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (shift_seq A n) -&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk40"><span class="highlight">srapply Colimit_rec; srapply Build_Cocone.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A n i -&gt; Colimit A</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk41"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o (shift_seq A n) _f g == <span class="nl">?legs</span> i</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk42"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A n i -&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">a</span> =&gt; inj A (k+n)%nat a).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk43"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a</span> : shift_seq A n k) =&gt; inj A (k + n) a) j
o (shift_seq A n) _f g ==
(<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a</span> : shift_seq A n k) =&gt; inj A (k + n) a) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> k l p; <span class="nb">destruct</span> p; <span class="bp">exact</span> (glue A (k+n)%nat).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk44"><span class="highlight"><span class="kn">Definition</span> <span class="nf">colim_shift_seq_to_colim_seq_beta_glue</span> <span class="nv">A</span> <span class="nv">n</span> <span class="nv">k</span> <span class="nv">a</span>
  : ap (colim_shift_seq_to_colim_seq A n) (glue (shift_seq A n) k a) = glue A (k+n)%nat a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">shift_seq A n k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (colim_shift_seq_to_colim_seq A n)
  (glue (shift_seq A n) k a) = glue A (k + n) a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk45"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">shift_seq A n k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (colim_shift_seq_to_colim_seq A n)
  (glue (shift_seq A n) k a) = glue A (k + n) a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply Colimit_rec_beta_colimp.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk46"><span class="highlight"><span class="kn">Definition</span> <span class="nf">colim_shift_seq_to_colim_seq_ap_inj</span> <span class="nv">A</span> <span class="nv">n</span> <span class="nv">k</span> (<span class="nv">a1</span> <span class="nv">a2</span> : shift_seq A n k) (<span class="nv">p</span> : a1 = a2)
  : ap (colim_shift_seq_to_colim_seq A n) (ap (inj _ k) p) = ap (inj _ (k+n)%nat) p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">shift_seq A n k</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a1 = a2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (colim_shift_seq_to_colim_seq A n)
  (ap (inj (shift_seq A n) k) p) =
ap (inj A (k + n)) p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk47"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">shift_seq A n k</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a1 = a2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (colim_shift_seq_to_colim_seq A n)
  (ap (inj (shift_seq A n) k) p) =
ap (inj A (k + n)) p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk48"><span class="highlight"><span class="kn">Definition</span> <span class="nf">J</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">y</span>} {<span class="nv">I</span> : <span class="kr">forall</span> <span class="nv">x</span>, Y x -&gt; Z} (<span class="nv">p</span> : x1 = x2)
  : I x2 y = I x1 (coe (ap Y p^) y).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">I</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">I x2 y = I x1 (coe (ap Y p^) y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk49"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">I</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">I x2 y = I x1 (coe (ap Y p^) y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4a"><span class="highlight"><span class="kn">Definition</span> <span class="nf">K</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">y</span>} <span class="nv">F</span> <span class="nv">G</span> (<span class="nv">p</span> : x1 = x2) :
  G x2 (coe (ap Y p) y) = coe (ap Y (ap F p)) (G x1 y).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Y (F x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">G x2 (coe (ap Y p) y) = coe (ap Y (ap F p)) (G x1 y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Y (F x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">G x2 (coe (ap Y p) y) = coe (ap Y (ap F p)) (G x1 y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4c"><span class="highlight"><span class="kn">Definition</span> <span class="nf">L</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">y</span>} {<span class="nv">F</span> <span class="nv">G</span>} {<span class="nv">I</span> : <span class="kr">forall</span> <span class="nv">x</span>, Y x -&gt; Z} {<span class="nv">p</span> : x1 = x2}
  (<span class="nv">Q</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, I (F x) (G x y) = I x y)
  : Q x2 y @ J p =
    J (ap F p) @ (ap (I (F x1)) (K F G p^ @ ap10 (ap coe (ap (ap Y) (ap_V F p))) (G x2 y))^ @
    Q x1 (coe (ap Y p^) y)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Y (F x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">I</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y x), I (F x) (G x y) = I x y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q x2 y @ J p =
J (ap F p) @
(ap (I (F x1))
   (K F G p^ @
    ap10 (ap coe (ap (ap Y) (ap_V F p))) (G x2 y))^ @
 Q x1 (coe (ap Y p^) y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Y (F x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">I</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : X, Y x -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : X) (<span class="nv">y</span> : Y x), I (F x) (G x y) = I x y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Q x2 y @ J p =
J (ap F p) @
(ap (I (F x1))
   (K F G p^ @
    ap10 (ap coe (ap (ap Y) (ap_V F p))) (G x2 y))^ @
 Q x1 (coe (ap Y p^) y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> p; <span class="nb">rewrite</span> !concat_1p, concat_p1; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4e"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_colim_shift_seq_to_colim_seq</span> `{Funext} A n
  : IsEquiv (colim_shift_seq_to_colim_seq A n).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk4f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk50"><span class="highlight"><span class="nb">induction</span> n <span class="kr">as</span> [ | n e]; srapply isequiv_homotopic&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (shift_seq A <span class="mi">0</span>) &lt;~&gt; Colimit A</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk51"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?f</span> == colim_shift_seq_to_colim_seq A <span class="mi">0</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk52"><hr></label><div class="goal-conclusion"><span class="highlight">Colimit (shift_seq A n.+<span class="mi">1</span>) &lt;~&gt; Colimit A</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk53"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?f0</span> == colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk54"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (shift_seq A <span class="mi">0</span>) &lt;~&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk55"><span class="highlight">srapply equiv_functor_colimit; srapply Build_diagram_equiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">DiagramMap (shift_seq A <span class="mi">0</span>) A</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk56"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, IsEquiv (<span class="nl">?m</span> i)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk57"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">DiagramMap (shift_seq A <span class="mi">0</span>) A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk58"><span class="highlight">srapply Build_DiagramMap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A <span class="mi">0</span> i -&gt; A i</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk59" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk59"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : shift_seq A <span class="mi">0</span> i),
(A _f g) (<span class="nl">?DiagramMap_obj</span> i x) =
<span class="nl">?DiagramMap_obj</span> j (((shift_seq A <span class="mi">0</span>) _f g) x)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5a"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A <span class="mi">0</span> i -&gt; A i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">k</span> =&gt; coe (ap A (nat_add_n_O k)^)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5b"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : shift_seq A <span class="mi">0</span> i),
(A _f g)
  ((<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
    coe (ap A (nat_add_n_O k)^)) i x) =
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
 coe (ap A (nat_add_n_O k)^)) j
  (((shift_seq A <span class="mi">0</span>) _f g) x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5c"><span class="highlight"><span class="nb">intros</span> k l p a; <span class="nb">destruct</span> p; srapply (K S (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; a^+) (nat_add_n_O k)^ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">shift_seq A <span class="mi">0</span> k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">coe (ap A (ap S (nat_add_n_O k)^))
  ((<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A n) =&gt; (a) ^+) (k + <span class="mi">0</span>) a) =
coe (ap A (nat_add_n_O k.+<span class="mi">1</span>)^) (a) ^+</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply (ap10 (ap coe (ap (ap _) (ap_V _ _)))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5d"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
       coe (ap A (nat_add_n_O k)^);
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
         (<span class="nv">a</span> : shift_seq A <span class="mi">0</span> k) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           ((A _f p0) (coe (ap A (nat_add_n_O k)^) a) =
            coe (ap A (nat_add_n_O y)^)
              (((shift_seq A <span class="mi">0</span>) _f p0) a))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           K S (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; (a0) ^+)
             (nat_add_n_O k)^ @
           ap10
             (ap coe
                (ap (ap A) (ap_V S (nat_add_n_O k))))
             (a) ^+
       <span class="kr">end</span>
   |} i)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> k; srapply isequiv_path.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5e"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_functor_colimit
  {|
    diag_equiv_map :=
      {|
        DiagramMap_obj :=
          <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
          coe (ap A (nat_add_n_O k)^);
        DiagramMap_comm :=
          <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
            (<span class="nv">a</span> : shift_seq A <span class="mi">0</span> k) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
            <span class="kr">return</span>
              ((A _f p0)
                 (coe (ap A (nat_add_n_O k)^) a) =
               coe (ap A (nat_add_n_O y)^)
                 (((shift_seq A <span class="mi">0</span>) _f p0) a))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              K S
                (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; (a0) ^+)
                (nat_add_n_O k)^ @
              ap10
                (ap coe
                   (ap (ap A) (ap_V S (nat_add_n_O k))))
                (a) ^+
          <span class="kr">end</span>
      |};
    diag_equiv_isequiv :=
      <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
      isequiv_path (ap A (nat_add_n_O k)^)
  |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
  (iscolimit_colimit A) ==
colim_shift_seq_to_colim_seq A <span class="mi">0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk5f"><span class="highlight"><span class="nb">symmetry</span>; srapply seq_colimit_uniq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
colim_shift_seq_to_colim_seq A <span class="mi">0</span>
o inj (shift_seq A <span class="mi">0</span>) n ==
equiv_functor_colimit
  {|
    diag_equiv_map :=
      {|
        DiagramMap_obj :=
          <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
          coe (ap A (nat_add_n_O k)^);
        DiagramMap_comm :=
          <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
            (<span class="nv">a</span> : shift_seq A <span class="mi">0</span> k) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
            <span class="kr">return</span>
              ((A _f p0)
                 (coe (ap A (nat_add_n_O k)^) a) =
               coe (ap A (nat_add_n_O y)^)
                 (((shift_seq A <span class="mi">0</span>) _f p0) a))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              K S
                (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">a0</span> : A n0) =&gt; (a0) ^+)
                (nat_add_n_O k)^ @
              ap10
                (ap coe
                   (ap (ap A) (ap_V S (nat_add_n_O k))))
                (a) ^+
          <span class="kr">end</span>
      |};
    diag_equiv_isequiv :=
      <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
      isequiv_path (ap A (nat_add_n_O k)^)
  |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
  (iscolimit_colimit A) o inj (shift_seq A <span class="mi">0</span>) n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk60"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : shift_seq A <span class="mi">0</span> n),
ap (colim_shift_seq_to_colim_seq A <span class="mi">0</span>)
  (glue (shift_seq A <span class="mi">0</span>) n a) @ <span class="nl">?h0</span> n a =
<span class="nl">?h0</span> n.+<span class="mi">1</span> (a) ^+ @
ap
  (equiv_functor_colimit
     {|
       diag_equiv_map :=
         {|
           DiagramMap_obj :=
             <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
             coe (ap A (nat_add_n_O k)^);
           DiagramMap_comm :=
             <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
               (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
               (<span class="nv">a0</span> : shift_seq A <span class="mi">0</span> k) =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
               <span class="kr">return</span>
                 ((A _f p0)
                    (coe (ap A (nat_add_n_O k)^) a0) =
                  coe (ap A (nat_add_n_O y)^)
                    (((shift_seq A <span class="mi">0</span>) _f p0) a0))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 K S
                   (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">a1</span> : A n0) =&gt;
                    (a1) ^+) (nat_add_n_O k)^ @
                 ap10
                   (ap coe
                      (ap (ap A)
                         (ap_V S (nat_add_n_O k))))
                   (a0) ^+
             <span class="kr">end</span>
         |};
       diag_equiv_isequiv :=
         <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
         isequiv_path (ap A (nat_add_n_O k)^)
     |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
     (iscolimit_colimit A)) (glue (shift_seq A <span class="mi">0</span>) n a)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk61"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
colim_shift_seq_to_colim_seq A <span class="mi">0</span>
o inj (shift_seq A <span class="mi">0</span>) n ==
equiv_functor_colimit
  {|
    diag_equiv_map :=
      {|
        DiagramMap_obj :=
          <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
          coe (ap A (nat_add_n_O k)^);
        DiagramMap_comm :=
          <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
            (<span class="nv">a</span> : shift_seq A <span class="mi">0</span> k) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
            <span class="kr">return</span>
              ((A _f p0)
                 (coe (ap A (nat_add_n_O k)^) a) =
               coe (ap A (nat_add_n_O y)^)
                 (((shift_seq A <span class="mi">0</span>) _f p0) a))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              K S
                (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">a0</span> : A n0) =&gt; (a0) ^+)
                (nat_add_n_O k)^ @
              ap10
                (ap coe
                   (ap (ap A) (ap_V S (nat_add_n_O k))))
                (a) ^+
          <span class="kr">end</span>
      |};
    diag_equiv_isequiv :=
      <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
      isequiv_path (ap A (nat_add_n_O k)^)
  |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
  (iscolimit_colimit A) o inj (shift_seq A <span class="mi">0</span>) n</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> k a; <span class="bp">exact</span> (J (nat_add_n_O k)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk62"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : shift_seq A <span class="mi">0</span> n),
ap (colim_shift_seq_to_colim_seq A <span class="mi">0</span>)
  (glue (shift_seq A <span class="mi">0</span>) n a) @
(<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : shift_seq A <span class="mi">0</span> k) =&gt; J (nat_add_n_O k)) n a =
(<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : shift_seq A <span class="mi">0</span> k) =&gt; J (nat_add_n_O k)) n.+<span class="mi">1</span>
  (a) ^+ @
ap
  (equiv_functor_colimit
     {|
       diag_equiv_map :=
         {|
           DiagramMap_obj :=
             <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
             coe (ap A (nat_add_n_O k)^);
           DiagramMap_comm :=
             <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
               (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
               (<span class="nv">a0</span> : shift_seq A <span class="mi">0</span> k) =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
               <span class="kr">return</span>
                 ((A _f p0)
                    (coe (ap A (nat_add_n_O k)^) a0) =
                  coe (ap A (nat_add_n_O y)^)
                    (((shift_seq A <span class="mi">0</span>) _f p0) a0))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 K S
                   (<span class="kr">fun</span> (<span class="nv">n0</span> : nat) (<span class="nv">a1</span> : A n0) =&gt;
                    (a1) ^+) (nat_add_n_O k)^ @
                 ap10
                   (ap coe
                      (ap (ap A)
                         (ap_V S (nat_add_n_O k))))
                   (a0) ^+
             <span class="kr">end</span>
         |};
       diag_equiv_isequiv :=
         <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
         isequiv_path (ap A (nat_add_n_O k)^)
     |} (iscolimit_colimit (shift_seq A <span class="mi">0</span>))
     (iscolimit_colimit A)) (glue (shift_seq A <span class="mi">0</span>) n a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> k a; <span class="nb">rewrite</span> !Colimit_rec_beta_colimp; srapply (L (glue A)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk63"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (shift_seq A n.+<span class="mi">1</span>) &lt;~&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk64"><span class="highlight"><span class="nb">transitivity</span> (Colimit (succ_seq (shift_seq A n))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (shift_seq A n.+<span class="mi">1</span>) &lt;~&gt;
Colimit (succ_seq (shift_seq A n))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk65"><hr></label><div class="goal-conclusion"><span class="highlight">Colimit (succ_seq (shift_seq A n)) &lt;~&gt; Colimit A</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk66"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (shift_seq A n.+<span class="mi">1</span>) &lt;~&gt;
Colimit (succ_seq (shift_seq A n))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk67"><span class="highlight">srapply equiv_functor_colimit; srapply Build_diagram_equiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">DiagramMap (shift_seq A n.+<span class="mi">1</span>)
  (succ_seq (shift_seq A n))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk68" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk68"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, IsEquiv (<span class="nl">?m</span> i)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk69"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">DiagramMap (shift_seq A n.+<span class="mi">1</span>)
  (succ_seq (shift_seq A n))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6a"><span class="highlight">srapply Build_DiagramMap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A n.+<span class="mi">1</span> i -&gt; succ_seq (shift_seq A n) i</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk6b"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : shift_seq A n.+<span class="mi">1</span> i),
((succ_seq (shift_seq A n)) _f g)
  (<span class="nl">?DiagramMap_obj</span> i x) =
<span class="nl">?DiagramMap_obj</span> j (((shift_seq A n.+<span class="mi">1</span>) _f g) x)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6c"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
shift_seq A n.+<span class="mi">1</span> i -&gt; succ_seq (shift_seq A n) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">k</span> =&gt; coe (ap A (nat_add_n_Sm k n)^)).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6d"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : shift_seq A n.+<span class="mi">1</span> i),
((succ_seq (shift_seq A n)) _f g)
  ((<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
    coe (ap A (nat_add_n_Sm k n)^)) i x) =
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
 coe (ap A (nat_add_n_Sm k n)^)) j
  (((shift_seq A n.+<span class="mi">1</span>) _f g) x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6e"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : shift_seq A n.+<span class="mi">1</span> i),
((succ_seq (shift_seq A n)) _f g)
  ((<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
    coe (ap A (nat_add_n_Sm k n)^)) i x) =
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
 coe (ap A (nat_add_n_Sm k n)^)) j
  (((shift_seq A n.+<span class="mi">1</span>) _f g) x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk6f"><span class="highlight"><span class="nb">intros</span> k l p a; <span class="nb">destruct</span> p; rapply (K S (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; a^+) (nat_add_n_Sm k n)^ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">shift_seq A n.+<span class="mi">1</span> k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">coe (ap A (ap S (nat_add_n_Sm k n)^)) (a) ^+ =
coe (ap A (nat_add_n_Sm k.+<span class="mi">1</span> n)^) (a) ^+</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply (ap10 (ap coe (ap (ap _) (ap_V _ _)))).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk70"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
       coe (ap A (nat_add_n_Sm k n)^);
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
         (<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (((succ_seq (shift_seq A n)) _f p0)
              (coe (ap A (nat_add_n_Sm k n)^) a) =
            coe (ap A (nat_add_n_Sm y n)^)
              (((shift_seq A n.+<span class="mi">1</span>) _f p0) a))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           K S (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; (a0) ^+)
             (nat_add_n_Sm k n)^ @
           ap10
             (ap coe
                (ap (ap A) (ap_V S (nat_add_n_Sm k n))))
             (a) ^+
       <span class="kr">end</span>
   |} i)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> k; srapply isequiv_path.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk71"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (succ_seq (shift_seq A n)) &lt;~&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srefine (<span class="nb">transitivity</span> (equiv_colim_succ_seq_to_colim_seq _) (Build_Equiv _ _ _ e)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk72"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
 equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
  (Colimit (succ_seq (shift_seq A n))) (Colimit A)
  (equiv_functor_colimit
     {|
       diag_equiv_map :=
         {|
           DiagramMap_obj :=
             <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
             coe (ap A (nat_add_n_Sm k n)^);
           DiagramMap_comm :=
             <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
               (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
               (<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
               <span class="kr">return</span>
                 (((succ_seq (shift_seq A n)) _f p0)
                    (coe (ap A (nat_add_n_Sm k n)^) a) =
                  coe (ap A (nat_add_n_Sm y n)^)
                    (((shift_seq A n.+<span class="mi">1</span>) _f p0) a))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 K S
                   (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt;
                    (a0) ^+) (nat_add_n_Sm k n)^ @
                 ap10
                   (ap coe
                      (ap (ap A)
                         (ap_V S (nat_add_n_Sm k n))))
                   (a) ^+
             <span class="kr">end</span>
         |};
       diag_equiv_isequiv :=
         <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
         isequiv_path (ap A (nat_add_n_Sm k n)^)
     |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
     (iscolimit_colimit (succ_seq (shift_seq A n))))
  (<span class="nb">transitivity</span>
     (equiv_colim_succ_seq_to_colim_seq
        (shift_seq A n))
     {|
       equiv_fun := colim_shift_seq_to_colim_seq A n;
       equiv_isequiv := e
     |}) == colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk73"><span class="highlight"><span class="nb">symmetry</span>; srapply seq_colimit_uniq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph,
colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span>
o inj (shift_seq A n.+<span class="mi">1</span>) n0 ==
(<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
 equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
  (Colimit (succ_seq (shift_seq A n))) (Colimit A)
  (equiv_functor_colimit
     {|
       diag_equiv_map :=
         {|
           DiagramMap_obj :=
             <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
             coe (ap A (nat_add_n_Sm k n)^);
           DiagramMap_comm :=
             <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
               (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
               (<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
               <span class="kr">return</span>
                 (((succ_seq (shift_seq A n)) _f p0)
                    (coe (ap A (nat_add_n_Sm k n)^) a) =
                  coe (ap A (nat_add_n_Sm y n)^)
                    (((shift_seq A n.+<span class="mi">1</span>) _f p0) a))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 K S
                   (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt;
                    (a0) ^+) (nat_add_n_Sm k n)^ @
                 ap10
                   (ap coe
                      (ap (ap A)
                         (ap_V S (nat_add_n_Sm k n))))
                   (a) ^+
             <span class="kr">end</span>
         |};
       diag_equiv_isequiv :=
         <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
         isequiv_path (ap A (nat_add_n_Sm k n)^)
     |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
     (iscolimit_colimit (succ_seq (shift_seq A n))))
  (<span class="nb">transitivity</span>
     (equiv_colim_succ_seq_to_colim_seq
        (shift_seq A n))
     {|
       equiv_fun := colim_shift_seq_to_colim_seq A n;
       equiv_isequiv := e
     |}) o inj (shift_seq A n.+<span class="mi">1</span>) n0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk74" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk74"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> n0),
ap (colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span>)
  (glue (shift_seq A n.+<span class="mi">1</span>) n0 a) @ <span class="nl">?h</span> n0 a =
<span class="nl">?h</span> n0.+<span class="mi">1</span> (a) ^+ @
ap
  ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
    equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
     (Colimit (succ_seq (shift_seq A n))) (Colimit A)
     (equiv_functor_colimit
        {|
          diag_equiv_map :=
            {|
              DiagramMap_obj :=
                <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
                coe (ap A (nat_add_n_Sm k n)^);
              DiagramMap_comm :=
                <span class="kr">fun</span>
                  (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
                  (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
                  (<span class="nv">a0</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
                <span class="kr">match</span>
                  p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
                  <span class="kr">return</span>
                    (((succ_seq (...)) _f p0)
                       (coe (ap A (...)^) a0) =
                     coe (ap A (nat_add_n_Sm y n)^)
                       (((...) _f p0) a0))
                <span class="kr">with</span>
                | <span class="mi">1</span> =&gt;
                    K S
                      (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a1</span> : A n) =&gt;
                       (a1) ^+) (nat_add_n_Sm k n)^ @
                    ap10
                      (ap coe
                         (ap (ap A)
                            (ap_V S (nat_add_n_Sm k n))))
                      (a0) ^+
                <span class="kr">end</span>
            |};
          diag_equiv_isequiv :=
            <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
            isequiv_path (ap A (nat_add_n_Sm k n)^)
        |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
        (iscolimit_colimit (succ_seq (shift_seq A n))))
     (<span class="nb">transitivity</span>
        (equiv_colim_succ_seq_to_colim_seq
           (shift_seq A n))
        {|
          equiv_fun :=
            colim_shift_seq_to_colim_seq A n;
          equiv_isequiv := e
        |})) (glue (shift_seq A n.+<span class="mi">1</span>) n0 a)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk75"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph,
colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span>
o inj (shift_seq A n.+<span class="mi">1</span>) n0 ==
(<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
 equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
  (Colimit (succ_seq (shift_seq A n))) (Colimit A)
  (equiv_functor_colimit
     {|
       diag_equiv_map :=
         {|
           DiagramMap_obj :=
             <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
             coe (ap A (nat_add_n_Sm k n)^);
           DiagramMap_comm :=
             <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
               (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
               (<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
             <span class="kr">match</span>
               p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
               <span class="kr">return</span>
                 (((succ_seq (shift_seq A n)) _f p0)
                    (coe (ap A (nat_add_n_Sm k n)^) a) =
                  coe (ap A (nat_add_n_Sm y n)^)
                    (((shift_seq A n.+<span class="mi">1</span>) _f p0) a))
             <span class="kr">with</span>
             | <span class="mi">1</span> =&gt;
                 K S
                   (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt;
                    (a0) ^+) (nat_add_n_Sm k n)^ @
                 ap10
                   (ap coe
                      (ap (ap A)
                         (ap_V S (nat_add_n_Sm k n))))
                   (a) ^+
             <span class="kr">end</span>
         |};
       diag_equiv_isequiv :=
         <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
         isequiv_path (ap A (nat_add_n_Sm k n)^)
     |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
     (iscolimit_colimit (succ_seq (shift_seq A n))))
  (<span class="nb">transitivity</span>
     (equiv_colim_succ_seq_to_colim_seq
        (shift_seq A n))
     {|
       equiv_fun := colim_shift_seq_to_colim_seq A n;
       equiv_isequiv := e
     |}) o inj (shift_seq A n.+<span class="mi">1</span>) n0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> k a; <span class="bp">exact</span> (J (nat_add_n_Sm k n)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk76"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : shift_seq A n.+<span class="mi">1</span> n0),
ap (colim_shift_seq_to_colim_seq A n.+<span class="mi">1</span>)
  (glue (shift_seq A n.+<span class="mi">1</span>) n0 a) @
(<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt; J (nat_add_n_Sm k n))
  n0 a =
(<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt; J (nat_add_n_Sm k n))
  n0.+<span class="mi">1</span> (a) ^+ @
ap
  ((<span class="kr">fun</span> (<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : x &lt;~&gt; y) (<span class="nv">g</span> : y &lt;~&gt; z) =&gt;
    equiv_compose g f) (Colimit (shift_seq A n.+<span class="mi">1</span>))
     (Colimit (succ_seq (shift_seq A n))) (Colimit A)
     (equiv_functor_colimit
        {|
          diag_equiv_map :=
            {|
              DiagramMap_obj :=
                <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
                coe (ap A (nat_add_n_Sm k n)^);
              DiagramMap_comm :=
                <span class="kr">fun</span>
                  (<span class="nv">k</span> <span class="nv">l</span> : Graph.graph0 sequence_graph)
                  (<span class="nv">p</span> : Graph.graph1 sequence_graph k l)
                  (<span class="nv">a0</span> : shift_seq A n.+<span class="mi">1</span> k) =&gt;
                <span class="kr">match</span>
                  p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
                  <span class="kr">return</span>
                    (((succ_seq (...)) _f p0)
                       (coe (ap A (...)^) a0) =
                     coe (ap A (nat_add_n_Sm y n)^)
                       (((...) _f p0) a0))
                <span class="kr">with</span>
                | <span class="mi">1</span> =&gt;
                    K S
                      (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a1</span> : A n) =&gt;
                       (a1) ^+) (nat_add_n_Sm k n)^ @
                    ap10
                      (ap coe
                         (ap (ap A)
                            (ap_V S (nat_add_n_Sm k n))))
                      (a0) ^+
                <span class="kr">end</span>
            |};
          diag_equiv_isequiv :=
            <span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt;
            isequiv_path (ap A (nat_add_n_Sm k n)^)
        |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
        (iscolimit_colimit (succ_seq (shift_seq A n))))
     (<span class="nb">transitivity</span>
        (equiv_colim_succ_seq_to_colim_seq
           (shift_seq A n))
        {|
          equiv_fun :=
            colim_shift_seq_to_colim_seq A n;
          equiv_isequiv := e
        |})) (glue (shift_seq A n.+<span class="mi">1</span>) n0 a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk77"><span class="highlight"><span class="nb">intros</span> k a; <span class="nb">rewrite</span> Colimit_rec_beta_colimp; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">shift_seq A n.+<span class="mi">1</span> k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">colimp (k + n.+<span class="mi">1</span>) (k + n.+<span class="mi">1</span>).+<span class="mi">1</span> <span class="mi">1</span> a @
J (nat_add_n_Sm k n) =
J (ap S (nat_add_n_Sm k n)) @
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (shift_seq A n.+<span class="mi">1</span>) =&gt;
   colim_shift_seq_to_colim_seq A n
     (colim_succ_seq_to_colim_seq (shift_seq A n)
        (functor_colimit
           {|
             DiagramMap_obj :=
               <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
               coe (ap A (nat_add_n_Sm k n)^);
             DiagramMap_comm :=
               <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
                 (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
               <span class="kr">match</span>
                 p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
                 <span class="kr">return</span>
                   (<span class="kr">match</span>
                      p0 <span class="kr">in</span> (_ = y0)
                      <span class="kr">return</span> (... -&gt; ...)
                    <span class="kr">with</span>
                    | <span class="mi">1</span> =&gt;
                        <span class="kr">fun</span> <span class="nv">a0</span> : A ....+<span class="mi">1</span> =&gt; (a0) ^+
                    <span class="kr">end</span>
                      (coe (ap A (nat_add_n_Sm k n)^)
                         a) =
                    coe (ap A (nat_add_n_Sm y n)^)
                      (<span class="kr">match</span> p0 <span class="kr">in</span> ... <span class="kr">return</span> ... <span class="kr">with</span>
                       | <span class="mi">1</span> =&gt; <span class="kr">fun</span> ... =&gt; ... ^+
                       <span class="kr">end</span> a))
               <span class="kr">with</span>
               | <span class="mi">1</span> =&gt;
                   K S
                     (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt;
                      (a0) ^+) (nat_add_n_Sm k n)^ @
                   ap10
                     (ap coe
                        (ap (ap A)
                           (ap_V S (nat_add_n_Sm k n))))
                     (a) ^+
               <span class="kr">end</span>
           |} (iscolimit_colimit (shift_seq A n.+<span class="mi">1</span>))
           (iscolimit_colimit
              (succ_seq (shift_seq A n))) x)))
  (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk78"><span class="highlight"><span class="nb">rewrite</span> <span class="mi">2</span>(ap_compose&#39; _ _ (glue _ k a)), Colimit_rec_beta_colimp, <span class="mi">2</span>ap_pp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">shift_seq A n.+<span class="mi">1</span> k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">colimp (k + n.+<span class="mi">1</span>) (k + n.+<span class="mi">1</span>).+<span class="mi">1</span> <span class="mi">1</span> a @
J (nat_add_n_Sm k n) =
J (ap S (nat_add_n_Sm k n)) @
(ap (colim_shift_seq_to_colim_seq A n)
   (ap (colim_succ_seq_to_colim_seq (shift_seq A n))
      (ap
         (iscolimit_colimit (succ_seq (shift_seq A n))
            k.+<span class="mi">1</span>)
         (DiagramMap_comm
            {|
              DiagramMap_obj :=
                <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
                coe (ap A (nat_add_n_Sm k n)^);
              DiagramMap_comm :=
                <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
                  (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
                <span class="kr">match</span>
                  p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
                  <span class="kr">return</span>
                    (<span class="kr">match</span>
                       p0 <span class="kr">in</span> (...) <span class="kr">return</span> (...)
                     <span class="kr">with</span>
                     | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : ... =&gt; (a0) ^+
                     <span class="kr">end</span> (coe (ap A (...)^) a) =
                     coe (ap A (nat_add_n_Sm y n)^)
                       (<span class="kr">match</span> ... ... <span class="kr">with</span>
                        | ... =&gt; ... =&gt; ...
                        <span class="kr">end</span> a))
                <span class="kr">with</span>
                | <span class="mi">1</span> =&gt;
                    K S
                      (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt;
                       (a0) ^+) (nat_add_n_Sm k n)^ @
                    ap10
                      (ap coe
                         (ap (ap A)
                            (ap_V S (nat_add_n_Sm k n))))
                      (a) ^+
                <span class="kr">end</span>
            |} <span class="mi">1</span> a)^)) @
 ap (colim_shift_seq_to_colim_seq A n)
   (ap (colim_succ_seq_to_colim_seq (shift_seq A n))
      (legs_comm
         (iscolimit_colimit (succ_seq (shift_seq A n)))
         k k.+<span class="mi">1</span> <span class="mi">1</span>
         ({|
            DiagramMap_obj :=
              <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
              coe (ap A (nat_add_n_Sm k n)^);
            DiagramMap_comm :=
              <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
                (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
              <span class="kr">match</span>
                p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
                <span class="kr">return</span>
                  (<span class="kr">match</span> p0 <span class="kr">in</span> (...) <span class="kr">return</span> (...) <span class="kr">with</span>
                   | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : ... =&gt; (a0) ^+
                   <span class="kr">end</span> (coe (ap A (...)^) a) =
                   coe (ap A (nat_add_n_Sm y n)^)
                     (<span class="kr">match</span> ... ... <span class="kr">with</span>
                      | ... =&gt; ... =&gt; ...
                      <span class="kr">end</span> a))
              <span class="kr">with</span>
              | <span class="mi">1</span> =&gt;
                  K S
                    (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt;
                     (a0) ^+) (nat_add_n_Sm k n)^ @
                  ap10
                    (ap coe
                       (ap (ap A)
                          (ap_V S (nat_add_n_Sm k n))))
                    (a) ^+
              <span class="kr">end</span>
          |} k a))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk79"><span class="highlight"><span class="nb">rewrite</span> colim_succ_seq_to_colim_seq_ap_inj, colim_shift_seq_to_colim_seq_ap_inj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">shift_seq A n.+<span class="mi">1</span> k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">colimp (k + n.+<span class="mi">1</span>) (k + n.+<span class="mi">1</span>).+<span class="mi">1</span> <span class="mi">1</span> a @
J (nat_add_n_Sm k n) =
J (ap S (nat_add_n_Sm k n)) @
(ap (inj A (k.+<span class="mi">2</span> + n))
   (DiagramMap_comm
      {|
        DiagramMap_obj :=
          <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
          coe (ap A (nat_add_n_Sm k n)^);
        DiagramMap_comm :=
          <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
            (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
            <span class="kr">return</span>
              (<span class="kr">match</span>
                 p0 <span class="kr">in</span> (_ = y0)
                 <span class="kr">return</span>
                   (A (k + n).+<span class="mi">1</span> -&gt; A (y0 + n).+<span class="mi">1</span>)
               <span class="kr">with</span>
               | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A (k + n).+<span class="mi">1</span> =&gt; (a0) ^+
               <span class="kr">end</span> (coe (ap A (nat_add_n_Sm k n)^) a) =
               coe (ap A (nat_add_n_Sm y n)^)
                 (<span class="kr">match</span>
                    p0 <span class="kr">in</span> (_ = y0)
                    <span class="kr">return</span> (A ... -&gt; A ...)
                  <span class="kr">with</span>
                  | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A (...) =&gt; (a0) ^+
                  <span class="kr">end</span> a))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              K S
                (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; (a0) ^+)
                (nat_add_n_Sm k n)^ @
              ap10
                (ap coe
                   (ap (ap A)
                      (ap_V S (nat_add_n_Sm k n))))
                (a) ^+
          <span class="kr">end</span>
      |} <span class="mi">1</span> a)^ @
 ap (colim_shift_seq_to_colim_seq A n)
   (ap (colim_succ_seq_to_colim_seq (shift_seq A n))
      (legs_comm
         (iscolimit_colimit (succ_seq (shift_seq A n)))
         k k.+<span class="mi">1</span> <span class="mi">1</span>
         ({|
            DiagramMap_obj :=
              <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
              coe (ap A (nat_add_n_Sm k n)^);
            DiagramMap_comm :=
              <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
                (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
              <span class="kr">match</span>
                p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
                <span class="kr">return</span>
                  (<span class="kr">match</span> p0 <span class="kr">in</span> (...) <span class="kr">return</span> (...) <span class="kr">with</span>
                   | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : ... =&gt; (a0) ^+
                   <span class="kr">end</span> (coe (ap A (...)^) a) =
                   coe (ap A (nat_add_n_Sm y n)^)
                     (<span class="kr">match</span> ... ... <span class="kr">with</span>
                      | ... =&gt; ... =&gt; ...
                      <span class="kr">end</span> a))
              <span class="kr">with</span>
              | <span class="mi">1</span> =&gt;
                  K S
                    (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt;
                     (a0) ^+) (nat_add_n_Sm k n)^ @
                  ap10
                    (ap coe
                       (ap (ap A)
                          (ap_V S (nat_add_n_Sm k n))))
                    (a) ^+
              <span class="kr">end</span>
          |} k a))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7a"><span class="highlight"><span class="nb">rewrite</span> (colim_succ_seq_to_colim_seq_beta_glue (shift_seq A n)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (colim_shift_seq_to_colim_seq A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">shift_seq A n.+<span class="mi">1</span> k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">colimp (k + n.+<span class="mi">1</span>) (k + n.+<span class="mi">1</span>).+<span class="mi">1</span> <span class="mi">1</span> a @
J (nat_add_n_Sm k n) =
J (ap S (nat_add_n_Sm k n)) @
(ap (inj A (k.+<span class="mi">2</span> + n))
   (DiagramMap_comm
      {|
        DiagramMap_obj :=
          <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
          coe (ap A (nat_add_n_Sm k n)^);
        DiagramMap_comm :=
          <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
            (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
          <span class="kr">match</span>
            p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
            <span class="kr">return</span>
              (<span class="kr">match</span>
                 p0 <span class="kr">in</span> (_ = y0)
                 <span class="kr">return</span>
                   (A (k + n).+<span class="mi">1</span> -&gt; A (y0 + n).+<span class="mi">1</span>)
               <span class="kr">with</span>
               | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A (k + n).+<span class="mi">1</span> =&gt; (a0) ^+
               <span class="kr">end</span> (coe (ap A (nat_add_n_Sm k n)^) a) =
               coe (ap A (nat_add_n_Sm y n)^)
                 (<span class="kr">match</span>
                    p0 <span class="kr">in</span> (_ = y0)
                    <span class="kr">return</span> (A ... -&gt; A ...)
                  <span class="kr">with</span>
                  | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A (...) =&gt; (a0) ^+
                  <span class="kr">end</span> a))
          <span class="kr">with</span>
          | <span class="mi">1</span> =&gt;
              K S
                (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; (a0) ^+)
                (nat_add_n_Sm k n)^ @
              ap10
                (ap coe
                   (ap (ap A)
                      (ap_V S (nat_add_n_Sm k n))))
                (a) ^+
          <span class="kr">end</span>
      |} <span class="mi">1</span> a)^ @
 ap (colim_shift_seq_to_colim_seq A n)
   (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span>
      ({|
         DiagramMap_obj :=
           <span class="kr">fun</span> <span class="nv">k</span> : nat =&gt;
           coe (ap A (nat_add_n_Sm k n)^);
         DiagramMap_comm :=
           <span class="kr">fun</span> (<span class="nv">k</span> <span class="nv">l</span> : nat) (<span class="nv">p</span> : k.+<span class="mi">1</span> = l)
             (<span class="nv">a</span> : A (k + n.+<span class="mi">1</span>)) =&gt;
           <span class="kr">match</span>
             p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
             <span class="kr">return</span>
               (<span class="kr">match</span>
                  p0 <span class="kr">in</span> (_ = y0)
                  <span class="kr">return</span> (A ....+<span class="mi">1</span> -&gt; A ....+<span class="mi">1</span>)
                <span class="kr">with</span>
                | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : A (...).+<span class="mi">1</span> =&gt; (a0) ^+
                <span class="kr">end</span> (coe (ap A (nat_add_n_Sm k n)^) a) =
                coe (ap A (nat_add_n_Sm y n)^)
                  (<span class="kr">match</span> p0 <span class="kr">in</span> (...) <span class="kr">return</span> (...) <span class="kr">with</span>
                   | <span class="mi">1</span> =&gt; <span class="kr">fun</span> <span class="nv">a0</span> : ... =&gt; (a0) ^+
                   <span class="kr">end</span> a))
           <span class="kr">with</span>
           | <span class="mi">1</span> =&gt;
               K S
                 (<span class="kr">fun</span> (<span class="nv">n</span> : nat) (<span class="nv">a0</span> : A n) =&gt; (a0) ^+)
                 (nat_add_n_Sm k n)^ @
               ap10
                 (ap coe
                    (ap (ap A)
                       (ap_V S (nat_add_n_Sm k n))))
                 (a) ^+
           <span class="kr">end</span>
       |} k a)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> colim_shift_seq_to_colim_seq_beta_glue; srapply (L (glue A)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_colim_shift_seq_to_colim_seq</span> `{Funext} A n
  : Colimit (shift_seq A n) &lt;~&gt; Colimit A
  := Build_Equiv _ _ (colim_shift_seq_to_colim_seq A n) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Corollary 7.7.1 for k := -2; implies Lemma 7.2. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7b"><span class="highlight"><span class="kn">Definition</span> <span class="nf">contr_colim_contr_seq</span> `{Funext} (A : Sequence)
  : (<span class="kr">forall</span> <span class="nv">k</span>, Contr (A k)) -&gt; Contr (Colimit A).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph, Contr (A k)) -&gt;
Contr (Colimit A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph, Contr (A k)) -&gt;
Contr (Colimit A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7d"><span class="highlight"><span class="nb">intro</span> h_seqcontr; <span class="nb">pose</span> (unit_seq := Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> =&gt; Unit) (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; tt)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (Colimit A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk7e"><span class="highlight">srapply (contr_equiv&#39; (Colimit unit_seq)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit unit_seq &lt;~&gt; Colimit A</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk7f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk7f"><hr></label><div class="goal-conclusion"><span class="highlight">Contr (Colimit unit_seq)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk80"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit unit_seq &lt;~&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk81"><span class="highlight"><span class="nb">symmetry</span>; srapply equiv_functor_colimit.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A ~d~ unit_seq</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk82"><span class="highlight">srapply Build_diagram_equiv; srapply Build_DiagramMap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
A i -&gt; unit_seq i</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk83"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) 
(<span class="nv">x</span> : A i),
(unit_seq _f g) (<span class="nl">?DiagramMap_obj</span> i x) =
<span class="nl">?DiagramMap_obj</span> j ((A _f g) x)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk84"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
A i -&gt; unit_seq i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; tt).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk85"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
(unit_seq _f g)
  ((<span class="kr">fun</span> (<span class="nv">i0</span> : Graph.graph0 sequence_graph) (<span class="nv">_</span> : A i0)
    =&gt; tt) i x) =
(<span class="kr">fun</span> (<span class="nv">i0</span> : Graph.graph0 sequence_graph) (<span class="nv">_</span> : A i0) =&gt;
 tt) j ((A _f g) x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> n m p a; <span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk86"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (Colimit unit_seq)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk87"><span class="highlight">srapply (Build_Contr _ (inj unit_seq <span class="mi">0</span> tt)); <span class="nb">intro</span> y; <span class="nb">symmetry</span>; <span class="nb">revert</span> y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Colimit unit_seq, y = inj unit_seq <span class="mi">0</span> tt</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk88"><span class="highlight">srapply seq_colimit_uniq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
idmap o inj unit_seq n ==
(<span class="kr">fun</span> <span class="nv">_</span> : Colimit unit_seq =&gt; inj unit_seq <span class="mi">0</span> tt)
o inj unit_seq n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk89" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk89"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : unit_seq n),
ap idmap (glue unit_seq n a) @ <span class="nl">?h</span> n a =
<span class="nl">?h</span> n.+<span class="mi">1</span> (a) ^+ @
ap (<span class="kr">fun</span> <span class="nv">_</span> : Colimit unit_seq =&gt; inj unit_seq <span class="mi">0</span> tt)
  (glue unit_seq n a)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk8a"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
idmap o inj unit_seq n ==
(<span class="kr">fun</span> <span class="nv">_</span> : Colimit unit_seq =&gt; inj unit_seq <span class="mi">0</span> tt)
o inj unit_seq n</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk8b"><span class="highlight"><span class="nb">intros</span> n a; <span class="nb">destruct</span> a; <span class="nb">induction</span> n <span class="kr">as</span> [ | n r].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj unit_seq <span class="mi">0</span> tt = inj unit_seq <span class="mi">0</span> tt</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk8c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inj unit_seq n tt = inj unit_seq <span class="mi">0</span> tt</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk8c"><hr></label><div class="goal-conclusion"><span class="highlight">inj unit_seq n.+<span class="mi">1</span> tt = inj unit_seq <span class="mi">0</span> tt</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk8d"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj unit_seq <span class="mi">0</span> tt = inj unit_seq <span class="mi">0</span> tt</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk8e"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">inj unit_seq n tt = inj unit_seq <span class="mi">0</span> tt</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj unit_seq n.+<span class="mi">1</span> tt = inj unit_seq <span class="mi">0</span> tt</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (glue unit_seq n tt @ r).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk8f"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h_seqcontr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">k</span> : Graph.graph0 sequence_graph,
Contr (A k)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">unit_seq</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">Build_Sequence (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">_</span> : (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; Unit) n) =&gt; tt)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : unit_seq n),
ap idmap (glue unit_seq n a) @
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : unit_seq n0) =&gt;
 <span class="kr">match</span>
   a0 <span class="kr">as</span> u
   <span class="kr">return</span> (inj unit_seq n0 u = inj unit_seq <span class="mi">0</span> tt)
 <span class="kr">with</span>
 | tt =&gt;
     Overture.nat_rect
       (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
        inj unit_seq n1 tt = inj unit_seq <span class="mi">0</span> tt) <span class="mi">1</span>
       (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
          (<span class="nv">r</span> : inj unit_seq n1 tt = inj unit_seq <span class="mi">0</span> tt)
        =&gt; glue unit_seq n1 tt @ r) n0
 <span class="kr">end</span>) n a =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : unit_seq n0) =&gt;
 <span class="kr">match</span>
   a0 <span class="kr">as</span> u
   <span class="kr">return</span> (inj unit_seq n0 u = inj unit_seq <span class="mi">0</span> tt)
 <span class="kr">with</span>
 | tt =&gt;
     Overture.nat_rect
       (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
        inj unit_seq n1 tt = inj unit_seq <span class="mi">0</span> tt) <span class="mi">1</span>
       (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
          (<span class="nv">r</span> : inj unit_seq n1 tt = inj unit_seq <span class="mi">0</span> tt)
        =&gt; glue unit_seq n1 tt @ r) n0
 <span class="kr">end</span>) n.+<span class="mi">1</span> (a) ^+ @
ap (<span class="kr">fun</span> <span class="nv">_</span> : Colimit unit_seq =&gt; inj unit_seq <span class="mi">0</span> tt)
  (glue unit_seq n a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> n; <span class="nb">destruct</span> a; <span class="nb">rewrite</span> ap_idmap, ap_const, concat_p1; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Fibered sequences; Section 4. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">FibSequence</span> (<span class="nv">A</span> : Sequence) := {
  fibSequence : sig A -&gt; <span class="kt">Type</span>;
  fibSequenceArr x : fibSequence x -&gt; fibSequence x^++
}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Coercion</span> <span class="nf">fibSequence</span> : FibSequence  &gt;-&gt; <span class="kt">Funclass</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> fibSequence {A}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> fibSequenceArr {A}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;b ^+f&quot;</span> := (fibSequenceArr _ _ b).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The Sigma of a fibered type sequence; Definition 4.3. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk90"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sig_seq</span> {<span class="nv">A</span>} (<span class="nv">B</span> : FibSequence A) : Sequence.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Sequence</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk91"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Sequence</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk92"><span class="highlight">srapply Build_Sequence.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat -&gt; <span class="kt">Type</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk93" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk93"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat, <span class="nl">?X</span> n -&gt; <span class="nl">?X</span> n.+<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk94"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nat -&gt; <span class="kt">Type</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> =&gt; {a : A n &amp; B (n;a)}).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk95"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; {a : A n0 &amp; B (n0; a)}) n -&gt;
(<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt; {a : A n0 &amp; B (n0; a)}) n.+<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> n [a b]; <span class="bp">exact</span> (a^+; b^+f).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The canonical projection from the sequential colimit of Sigmas to the sequential colimit of the first component; Definition 4.3. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk96"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_to_seq_colim_fst</span> {<span class="nv">A</span>} (<span class="nv">B</span> : FibSequence A)
  : Colimit (sig_seq B) -&gt; Colimit A.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (sig_seq B) -&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk97"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (sig_seq B) -&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk98"><span class="highlight">srapply Colimit_rec; srapply Build_Cocone.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
sig_seq B i -&gt; Colimit A</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk99" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk99"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o (sig_seq B) _f g == <span class="nl">?legs</span> i</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9a"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
sig_seq B i -&gt; Colimit A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> n [a _]; <span class="bp">exact</span> (inj _ n a).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9b"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">X</span> : sig_seq B n) =&gt;
 (<span class="kr">fun</span> (<span class="nv">a</span> : A n) (<span class="nv">_</span> : B (n; a)) =&gt; inj A n a) X.<span class="mi">1</span> X.<span class="mi">2</span>)
  j o (sig_seq B) _f g ==
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">X</span> : sig_seq B n) =&gt;
 (<span class="kr">fun</span> (<span class="nv">a</span> : A n) (<span class="nv">_</span> : B (n; a)) =&gt; inj A n a) X.<span class="mi">1</span> X.<span class="mi">2</span>)
  i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> n m p [a b]; <span class="nb">destruct</span> p; <span class="bp">exact</span> (glue _ n a).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Given a sequence fibered over A, aach point x : sig A induces a new type sequence; Section 4. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9c"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fib_seq_to_seq</span> {<span class="nv">A</span>} (<span class="nv">B</span> : FibSequence A) (<span class="nv">x</span> : sig A) : Sequence.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Sequence</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Sequence</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk9e"><span class="highlight">srapply Build_Sequence; <span class="nb">intro</span> k; <span class="nb">revert</span> x; <span class="nb">induction</span> k <span class="kr">as</span> [ | k h].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x} -&gt; <span class="kt">Type</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk9f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x} -&gt; <span class="kt">Type</span></span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk9f"><hr></label><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x} -&gt; <span class="kt">Type</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chka0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chka0"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal0</span>)
  <span class="mi">0</span> x -&gt;
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal0</span>)
  <span class="mi">1</span> x</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="sequential-v-chka1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt;
   <span class="nl">?Goal0</span>) k x -&gt;
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt;
   <span class="nl">?Goal0</span>) k.+<span class="mi">1</span> x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chka1"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal0</span>)
  k.+<span class="mi">1</span> x -&gt;
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) <span class="nl">?Goal</span>
  (<span class="kr">fun</span> (<span class="nv">k</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>) =&gt; <span class="nl">?Goal0</span>)
  k.+<span class="mi">2</span> x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka2"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x} -&gt; <span class="kt">Type</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; B x).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka3"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x} -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; A x} -&gt; <span class="kt">Type</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; h x^++).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka4"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h (x0) ^++) <span class="mi">0</span> x -&gt;
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h (x0) ^++) <span class="mi">1</span> x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">b</span> =&gt; b^+f).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka5"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h (x0) ^++) k x -&gt;
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h (x0) ^++) k.+<span class="mi">1</span> x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h (x0) ^++) k.+<span class="mi">1</span> x -&gt;
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
  (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; B x0)
  (<span class="kr">fun</span> (<span class="nv">_</span> : nat) (<span class="nv">h</span> : {x : _ &amp; A x} -&gt; <span class="kt">Type</span>)
     (<span class="nv">x0</span> : {x : _ &amp; A x}) =&gt; h (x0) ^++) k.+<span class="mi">2</span> x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; h x^++).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The induced sequence can be equivalently described by using shifting; Lemma 7.1. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fib_seq_to_seq&#39;</span> {<span class="nv">A</span>} (<span class="nv">B</span> : FibSequence A) (<span class="nv">x</span> : sig A) : Sequence
  := Build_Sequence (<span class="kr">fun</span> <span class="nv">k</span> =&gt; B x^++k) (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">b</span> =&gt; b^+f).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka6"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_fib_seq_to_seq</span> {<span class="nv">A</span>} (<span class="nv">B</span> : FibSequence A) (<span class="nv">x</span> : sig A)
  : fib_seq_to_seq B x ~d~ fib_seq_to_seq&#39; B x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fib_seq_to_seq B x ~d~ fib_seq_to_seq&#39; B x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fib_seq_to_seq B x ~d~ fib_seq_to_seq&#39; B x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chka8"><span class="highlight">srapply Build_diagram_equiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">DiagramMap (fib_seq_to_seq B x) (fib_seq_to_seq&#39; B x)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chka9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chka9"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, IsEquiv (<span class="nl">?m</span> i)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkaa"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">DiagramMap (fib_seq_to_seq B x) (fib_seq_to_seq&#39; B x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkab"><span class="highlight">srapply Build_DiagramMap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
fib_seq_to_seq B x i -&gt; fib_seq_to_seq&#39; B x i</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chkac"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x0</span> : fib_seq_to_seq B x i),
((fib_seq_to_seq&#39; B x) _f g) (<span class="nl">?DiagramMap_obj</span> i x0) =
<span class="nl">?DiagramMap_obj</span> j (((fib_seq_to_seq B x) _f g) x0)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkad"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
fib_seq_to_seq B x i -&gt; fib_seq_to_seq&#39; B x i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkae"><span class="highlight"><span class="nb">intro</span> n; <span class="nb">revert</span> x; <span class="nb">induction</span> n <span class="kr">as</span> [ | n e].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x <span class="mi">0</span> -&gt; fib_seq_to_seq&#39; B x <span class="mi">0</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkaf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x n -&gt; fib_seq_to_seq&#39; B x n</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chkaf"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x n.+<span class="mi">1</span> -&gt; fib_seq_to_seq&#39; B x n.+<span class="mi">1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb0"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x <span class="mi">0</span> -&gt; fib_seq_to_seq&#39; B x <span class="mi">0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; idmap).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb1"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x n -&gt; fib_seq_to_seq&#39; B x n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
fib_seq_to_seq B x n.+<span class="mi">1</span> -&gt; fib_seq_to_seq&#39; B x n.+<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; coe (ap B (seq_pair_shift_assoc x n)) o e x^++).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb2"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x0</span> : fib_seq_to_seq B x i),
((fib_seq_to_seq&#39; B x) _f g)
  ((<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
    Overture.nat_rect
      (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
       <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
       fib_seq_to_seq B x n0 -&gt; fib_seq_to_seq&#39; B x n0)
      (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; idmap)
      (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
         (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
              fib_seq_to_seq B x n0 -&gt;
              fib_seq_to_seq&#39; B x n0)
         (<span class="nv">x</span> : {x : _ &amp; A x}) =&gt;
       coe (ap B (seq_pair_shift_assoc x n0))
       o e (x) ^++) n x) i x0) =
(<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
 Overture.nat_rect
   (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x n0 -&gt; fib_seq_to_seq&#39; B x n0)
   (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x n0 -&gt;
           fib_seq_to_seq&#39; B x n0) (<span class="nv">x</span> : {x : _ &amp; A x})
    =&gt;
    coe (ap B (seq_pair_shift_assoc x n0)) o e (x) ^++)
   n x) j (((fib_seq_to_seq B x) _f g) x0)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb3"><span class="highlight"><span class="nb">intros</span> n m p; <span class="nb">destruct</span> p; <span class="nb">revert</span> x; <span class="nb">induction</span> n <span class="kr">as</span> [ | n p].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x <span class="mi">0</span>),
(Overture.nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
    coe (ap B (seq_pair_shift_assoc x1 n))
      (e (x1) ^++ x2)) <span class="mi">0</span> x x0) ^+ =
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n) (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
   coe (ap B (seq_pair_shift_assoc x1 n))
     (e (x1) ^++ x2)) <span class="mi">1</span> x (x0) ^+</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkb4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x n),
(Overture.nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt;
    fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
    coe (ap B (seq_pair_shift_assoc x1 n))
      (e (x1) ^++ x2)) n x x0) ^+ =
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n)
     (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
   coe (ap B (seq_pair_shift_assoc x1 n))
     (e (x1) ^++ x2)) n.+<span class="mi">1</span> x (x0) ^+</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chkb4"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x n.+<span class="mi">1</span>),
(Overture.nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
    coe (ap B (seq_pair_shift_assoc x1 n))
      (e (x1) ^++ x2)) n.+<span class="mi">1</span> x x0) ^+ =
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n) (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
   coe (ap B (seq_pair_shift_assoc x1 n))
     (e (x1) ^++ x2)) n.+<span class="mi">2</span> x (x0) ^+</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb5"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x <span class="mi">0</span>),
(Overture.nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
    coe (ap B (seq_pair_shift_assoc x1 n))
      (e (x1) ^++ x2)) <span class="mi">0</span> x x0) ^+ =
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n) (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
   coe (ap B (seq_pair_shift_assoc x1 n))
     (e (x1) ^++ x2)) <span class="mi">1</span> x (x0) ^+</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; idpath).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb6"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x n),
(Overture.nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt;
    fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
    coe (ap B (seq_pair_shift_assoc x1 n))
      (e (x1) ^++ x2)) n x x0) ^+ =
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n)
     (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
   coe (ap B (seq_pair_shift_assoc x1 n))
     (e (x1) ^++ x2)) n.+<span class="mi">1</span> x (x0) ^+</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
(<span class="nv">x0</span> : fib_seq_to_seq B x n.+<span class="mi">1</span>),
(Overture.nat_rect
   (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
    fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
   (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
   (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
      (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
           fib_seq_to_seq B x1 n -&gt;
           fib_seq_to_seq&#39; B x1 n)
      (<span class="nv">x1</span> : {x : _ &amp; A x})
      (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
    coe (ap B (seq_pair_shift_assoc x1 n))
      (e (x1) ^++ x2)) n.+<span class="mi">1</span> x x0) ^+ =
Overture.nat_rect
  (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
   <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
   fib_seq_to_seq B x1 n -&gt; fib_seq_to_seq&#39; B x1 n)
  (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
  (<span class="kr">fun</span> (<span class="nv">n</span> : nat)
     (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x1 n -&gt;
          fib_seq_to_seq&#39; B x1 n) (<span class="nv">x1</span> : {x : _ &amp; A x})
     (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n) =&gt;
   coe (ap B (seq_pair_shift_assoc x1 n))
     (e (x1) ^++ x2)) n.+<span class="mi">2</span> x (x0) ^+</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">b</span> =&gt; K _ _ _ @ (ap _ (p (x^++) b))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb7"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; A x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       Overture.nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x n0 -&gt;
          fib_seq_to_seq&#39; B x n0)
         (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x n0 -&gt;
                 fib_seq_to_seq&#39; B x n0)
            (<span class="nv">x</span> : {x : _ &amp; A x}) =&gt;
          coe (ap B (seq_pair_shift_assoc x n0))
          o e (x) ^++) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x n0 -&gt;
                  fib_seq_to_seq&#39; B x n0)
                 (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x n0 -&gt;
                         fib_seq_to_seq&#39; B x n0)
                    (<span class="nv">x</span> : {x : _ &amp; A x})
                    (<span class="nv">x1</span> : fib_seq_to_seq B (x) ^++ n0)
                  =&gt;
                  coe
                    (ap B (seq_pair_shift_assoc x n0))
                    (e (x) ^++ x1)) n x x0) =
            Overture.nat_rect
              (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x n0 -&gt;
               fib_seq_to_seq&#39; B x n0)
              (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x n0 -&gt;
                      fib_seq_to_seq&#39; B x n0)
                 (<span class="nv">x</span> : {x : _ &amp; A x})
                 (<span class="nv">x1</span> : fib_seq_to_seq B (x) ^++ n0) =&gt;
               coe (ap B (seq_pair_shift_assoc x n0))
                 (e (x) ^++ x1)) y x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           Overture.nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
              (<span class="nv">x0</span> : fib_seq_to_seq B x n0),
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n1 -&gt;
                  fib_seq_to_seq&#39; B x1 n1)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n1 -&gt;
                         fib_seq_to_seq&#39; B x1 n1)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n1)
                  =&gt;
                  coe
                    (ap B (seq_pair_shift_assoc x1 n1))
                    (e (x1) ^++ x2)) n0 x x0) ^+ =
              Overture.nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x1 n1 -&gt;
                 fib_seq_to_seq&#39; B x1 n1)
                (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x1 n1 -&gt;
                        fib_seq_to_seq&#39; B x1 n1)
                   (<span class="nv">x1</span> : {x : _ &amp; A x})
                   (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n1)
                 =&gt;
                 coe
                   (ap B (seq_pair_shift_assoc x1 n1))
                   (e (x1) ^++ x2)) n0.+<span class="mi">1</span> x (x0) ^+)
             (<span class="kr">fun</span> (<span class="nv">x</span> : {x : _ &amp; A x})
                (<span class="nv">x0</span> : fib_seq_to_seq B x <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x</span> : {x : _ &amp; A x})
                      (<span class="nv">x0</span> : fib_seq_to_seq B x n0),
                      (Overture.nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x1 n1 -&gt;
                          fib_seq_to_seq&#39; B x1 n1)
                         (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt;
                          idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x1</span> : {x : _ &amp; ...},
                                 fib_seq_to_seq B x1
                                   n1 -&gt;
                                 fib_seq_to_seq&#39; B x1
                                   n1)
                            (<span class="nv">x1</span> : {x : _ &amp; A x})
                            (<span class="nv">x2</span> : fib_seq_to_seq B
                                    (x1) ^++ n1) =&gt;
                          coe
                            (ap B
                               (seq_pair_shift_assoc
                                  x1 n1))
                            (e (x1) ^++ x2)) n0 x x0)
                      ^+ =
                      Overture.nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n1 -&gt;
                         fib_seq_to_seq&#39; B x1 n1)
                        (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x1</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B x1 n1 -&gt;
                                fib_seq_to_seq&#39; B x1
                                  n1)
                           (<span class="nv">x1</span> : {x : _ &amp; A x})
                           (<span class="nv">x2</span> : fib_seq_to_seq B
                                   (x1) ^++ n1) =&gt;
                         coe
                           (ap B
                              (seq_pair_shift_assoc x1
                                 n1)) (e (x1) ^++ x2))
                        n0.+<span class="mi">1</span> x (x0) ^+)
                (<span class="nv">x</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x n0) @
              ap
                (coe
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x n0))))
                (p0 (x) ^++ b)) n x
       <span class="kr">end</span>
   |} i)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkb8"><span class="highlight"><span class="nb">intro</span> n; <span class="nb">revert</span> x; <span class="nb">induction</span> n <span class="kr">as</span> [ | n e].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       Overture.nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B (x0) ^++ n0) =&gt;
          coe (ap B (seq_pair_shift_assoc x0 n0))
            (e (x0) ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n0 -&gt;
                  fib_seq_to_seq&#39; B x1 n0)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n0 -&gt;
                         fib_seq_to_seq&#39; B x1 n0)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n0)
                  =&gt;
                  coe
                    (ap B (seq_pair_shift_assoc x1 n0))
                    (e (x1) ^++ x2)) n x x0) =
            Overture.nat_rect
              (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n0 -&gt;
               fib_seq_to_seq&#39; B x1 n0)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n0 -&gt;
                      fib_seq_to_seq&#39; B x1 n0)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n0)
               =&gt;
               coe (ap B (seq_pair_shift_assoc x1 n0))
                 (e (x1) ^++ x2)) y x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           Overture.nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B (x2) ^++ n1)
                  =&gt;
                  coe
                    (ap B (seq_pair_shift_assoc x2 n1))
                    (e (x2) ^++ x3)) n0 x0 x1) ^+ =
              Overture.nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B (x2) ^++ n1)
                 =&gt;
                 coe
                   (ap B (seq_pair_shift_assoc x2 n1))
                   (e (x2) ^++ x3)) n0.+<span class="mi">1</span> x0 (x1) ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (Overture.nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                          idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp; ...},
                                 fib_seq_to_seq B x2
                                   n1 -&gt;
                                 fib_seq_to_seq&#39; B x2
                                   n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    (x2) ^++ n1) =&gt;
                          coe
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e (x2) ^++ x3)) n0 x0 x1)
                      ^+ =
                      Overture.nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B x2 n1 -&gt;
                                fib_seq_to_seq&#39; B x2
                                  n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   (x2) ^++ n1) =&gt;
                         coe
                           (ap B
                              (seq_pair_shift_assoc x2
                                 n1)) (e (x2) ^++ x3))
                        n0.+<span class="mi">1</span> x0 (x1) ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (coe
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0 n0))))
                (p0 (x0) ^++ b)) n x
       <span class="kr">end</span>
   |} <span class="mi">0</span>)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkb9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       Overture.nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B (x0) ^++ n0) =&gt;
          coe (ap B (seq_pair_shift_assoc x0 n0))
            (e (x0) ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n0 -&gt;
                  fib_seq_to_seq&#39; B x1 n0)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span>
                         <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n0 -&gt;
                         fib_seq_to_seq&#39; B x1 n0)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B
                            (x1) ^++ n0) =&gt;
                  coe
                    (ap B
                       (seq_pair_shift_assoc x1 n0))
                    (e (x1) ^++ x2)) n x x0) =
            Overture.nat_rect
              (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n0 -&gt;
               fib_seq_to_seq&#39; B x1 n0)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n0 -&gt;
                      fib_seq_to_seq&#39; B x1 n0)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++
                         n0) =&gt;
               coe
                 (ap B
                    (seq_pair_shift_assoc x1 n0))
                 (e (x1) ^++ x2)) y x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           Overture.nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span>
                         <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B
                            (x2) ^++ n1) =&gt;
                  coe
                    (ap B
                       (seq_pair_shift_assoc x2 n1))
                    (e (x2) ^++ x3)) n0 x0 x1) ^+ =
              Overture.nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B (x2) ^++
                           n1) =&gt;
                 coe
                   (ap B
                      (seq_pair_shift_assoc x2 n1))
                   (e (x2) ^++ x3)) n0.+<span class="mi">1</span> x0
                (x1) ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (Overture.nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span>
                          <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x}
                          =&gt; idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp;
                                      ...},
                                 fib_seq_to_seq B
                                   x2 n1 -&gt;
                                 fib_seq_to_seq&#39; B
                                   x2 n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    (x2) ^++ n1)
                          =&gt;
                          coe
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e (x2) ^++ x3)) n0 x0
                         x1) ^+ =
                      Overture.nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span>
                         <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B
                                  x2 n1 -&gt;
                                fib_seq_to_seq&#39; B
                                  x2 n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   (x2) ^++ n1) =&gt;
                         coe
                           (ap B
                              (seq_pair_shift_assoc
                                 x2 n1))
                           (e (x2) ^++ x3)) n0.+<span class="mi">1</span>
                        x0 (x1) ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (coe
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0
                            n0)))) (p0 (x0) ^++ b))
             n x
       <span class="kr">end</span>
   |} n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chkb9"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       Overture.nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B (x0) ^++ n0) =&gt;
          coe (ap B (seq_pair_shift_assoc x0 n0))
            (e (x0) ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n0 -&gt;
                  fib_seq_to_seq&#39; B x1 n0)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n0 -&gt;
                         fib_seq_to_seq&#39; B x1 n0)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n0)
                  =&gt;
                  coe
                    (ap B (seq_pair_shift_assoc x1 n0))
                    (e (x1) ^++ x2)) n x x0) =
            Overture.nat_rect
              (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n0 -&gt;
               fib_seq_to_seq&#39; B x1 n0)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n0 -&gt;
                      fib_seq_to_seq&#39; B x1 n0)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n0)
               =&gt;
               coe (ap B (seq_pair_shift_assoc x1 n0))
                 (e (x1) ^++ x2)) y x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           Overture.nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B (x2) ^++ n1)
                  =&gt;
                  coe
                    (ap B (seq_pair_shift_assoc x2 n1))
                    (e (x2) ^++ x3)) n0 x0 x1) ^+ =
              Overture.nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B (x2) ^++ n1)
                 =&gt;
                 coe
                   (ap B (seq_pair_shift_assoc x2 n1))
                   (e (x2) ^++ x3)) n0.+<span class="mi">1</span> x0 (x1) ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (Overture.nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                          idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp; ...},
                                 fib_seq_to_seq B x2
                                   n1 -&gt;
                                 fib_seq_to_seq&#39; B x2
                                   n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    (x2) ^++ n1) =&gt;
                          coe
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e (x2) ^++ x3)) n0 x0 x1)
                      ^+ =
                      Overture.nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B x2 n1 -&gt;
                                fib_seq_to_seq&#39; B x2
                                  n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   (x2) ^++ n1) =&gt;
                         coe
                           (ap B
                              (seq_pair_shift_assoc x2
                                 n1)) (e (x2) ^++ x3))
                        n0.+<span class="mi">1</span> x0 (x1) ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (coe
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0 n0))))
                (p0 (x0) ^++ b)) n x
       <span class="kr">end</span>
   |} n.+<span class="mi">1</span>)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkba"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       Overture.nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B (x0) ^++ n0) =&gt;
          coe (ap B (seq_pair_shift_assoc x0 n0))
            (e (x0) ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n0 -&gt;
                  fib_seq_to_seq&#39; B x1 n0)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n0 -&gt;
                         fib_seq_to_seq&#39; B x1 n0)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n0)
                  =&gt;
                  coe
                    (ap B (seq_pair_shift_assoc x1 n0))
                    (e (x1) ^++ x2)) n x x0) =
            Overture.nat_rect
              (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n0 -&gt;
               fib_seq_to_seq&#39; B x1 n0)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n0 -&gt;
                      fib_seq_to_seq&#39; B x1 n0)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n0)
               =&gt;
               coe (ap B (seq_pair_shift_assoc x1 n0))
                 (e (x1) ^++ x2)) y x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           Overture.nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B (x2) ^++ n1)
                  =&gt;
                  coe
                    (ap B (seq_pair_shift_assoc x2 n1))
                    (e (x2) ^++ x3)) n0 x0 x1) ^+ =
              Overture.nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B (x2) ^++ n1)
                 =&gt;
                 coe
                   (ap B (seq_pair_shift_assoc x2 n1))
                   (e (x2) ^++ x3)) n0.+<span class="mi">1</span> x0 (x1) ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (Overture.nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                          idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp; ...},
                                 fib_seq_to_seq B x2
                                   n1 -&gt;
                                 fib_seq_to_seq&#39; B x2
                                   n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    (x2) ^++ n1) =&gt;
                          coe
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e (x2) ^++ x3)) n0 x0 x1)
                      ^+ =
                      Overture.nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B x2 n1 -&gt;
                                fib_seq_to_seq&#39; B x2
                                  n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   (x2) ^++ n1) =&gt;
                         coe
                           (ap B
                              (seq_pair_shift_assoc x2
                                 n1)) (e (x2) ^++ x3))
                        n0.+<span class="mi">1</span> x0 (x1) ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (coe
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0 n0))))
                (p0 (x0) ^++ b)) n x
       <span class="kr">end</span>
   |} <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; isequiv_idmap _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkbb"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       Overture.nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B (x0) ^++ n0) =&gt;
          coe (ap B (seq_pair_shift_assoc x0 n0))
            (e (x0) ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n0 -&gt;
                  fib_seq_to_seq&#39; B x1 n0)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span>
                         <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n0 -&gt;
                         fib_seq_to_seq&#39; B x1 n0)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B
                            (x1) ^++ n0) =&gt;
                  coe
                    (ap B
                       (seq_pair_shift_assoc x1 n0))
                    (e (x1) ^++ x2)) n x x0) =
            Overture.nat_rect
              (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n0 -&gt;
               fib_seq_to_seq&#39; B x1 n0)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n0 -&gt;
                      fib_seq_to_seq&#39; B x1 n0)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++
                         n0) =&gt;
               coe
                 (ap B
                    (seq_pair_shift_assoc x1 n0))
                 (e (x1) ^++ x2)) y x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           Overture.nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span>
                         <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B
                            (x2) ^++ n1) =&gt;
                  coe
                    (ap B
                       (seq_pair_shift_assoc x2 n1))
                    (e (x2) ^++ x3)) n0 x0 x1) ^+ =
              Overture.nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B (x2) ^++
                           n1) =&gt;
                 coe
                   (ap B
                      (seq_pair_shift_assoc x2 n1))
                   (e (x2) ^++ x3)) n0.+<span class="mi">1</span> x0
                (x1) ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (Overture.nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span>
                          <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x}
                          =&gt; idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp;
                                      ...},
                                 fib_seq_to_seq B
                                   x2 n1 -&gt;
                                 fib_seq_to_seq&#39; B
                                   x2 n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    (x2) ^++ n1)
                          =&gt;
                          coe
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e (x2) ^++ x3)) n0 x0
                         x1) ^+ =
                      Overture.nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span>
                         <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B
                                  x2 n1 -&gt;
                                fib_seq_to_seq&#39; B
                                  x2 n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   (x2) ^++ n1) =&gt;
                         coe
                           (ap B
                              (seq_pair_shift_assoc
                                 x2 n1))
                           (e (x2) ^++ x3)) n0.+<span class="mi">1</span>
                        x0 (x1) ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (coe
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0
                            n0)))) (p0 (x0) ^++ b))
             n x
       <span class="kr">end</span>
   |} n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; A x},
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       Overture.nat_rect
         (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
          fib_seq_to_seq B x0 n0 -&gt;
          fib_seq_to_seq&#39; B x0 n0)
         (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; A x} =&gt; idmap)
         (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
            (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x0 n0 -&gt;
                 fib_seq_to_seq&#39; B x0 n0)
            (<span class="nv">x0</span> : {x : _ &amp; A x})
            (<span class="nv">x1</span> : fib_seq_to_seq B (x0) ^++ n0) =&gt;
          coe (ap B (seq_pair_shift_assoc x0 n0))
            (e (x0) ^++ x1)) n x;
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (<span class="kr">forall</span> <span class="nv">x0</span> : fib_seq_to_seq B x n,
            ((fib_seq_to_seq&#39; B x) _f p0)
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x1 n0 -&gt;
                  fib_seq_to_seq&#39; B x1 n0)
                 (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x1 n0 -&gt;
                         fib_seq_to_seq&#39; B x1 n0)
                    (<span class="nv">x1</span> : {x : _ &amp; A x})
                    (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n0)
                  =&gt;
                  coe
                    (ap B (seq_pair_shift_assoc x1 n0))
                    (e (x1) ^++ x2)) n x x0) =
            Overture.nat_rect
              (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
               <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
               fib_seq_to_seq B x1 n0 -&gt;
               fib_seq_to_seq&#39; B x1 n0)
              (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; A x} =&gt; idmap)
              (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                 (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x1</span> : {x : _ &amp; A x},
                      fib_seq_to_seq B x1 n0 -&gt;
                      fib_seq_to_seq&#39; B x1 n0)
                 (<span class="nv">x1</span> : {x : _ &amp; A x})
                 (<span class="nv">x2</span> : fib_seq_to_seq B (x1) ^++ n0)
               =&gt;
               coe (ap B (seq_pair_shift_assoc x1 n0))
                 (e (x1) ^++ x2)) y x
              (((fib_seq_to_seq B x) _f p0) x0))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           Overture.nat_rect
             (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
              <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
              (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
              (Overture.nat_rect
                 (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                  <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                  fib_seq_to_seq B x2 n1 -&gt;
                  fib_seq_to_seq&#39; B x2 n1)
                 (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                 (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                    (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                    (<span class="nv">x2</span> : {x : _ &amp; A x})
                    (<span class="nv">x3</span> : fib_seq_to_seq B (x2) ^++ n1)
                  =&gt;
                  coe
                    (ap B (seq_pair_shift_assoc x2 n1))
                    (e (x2) ^++ x3)) n0 x0 x1) ^+ =
              Overture.nat_rect
                (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                 fib_seq_to_seq B x2 n1 -&gt;
                 fib_seq_to_seq&#39; B x2 n1)
                (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt; idmap)
                (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                   (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                        fib_seq_to_seq B x2 n1 -&gt;
                        fib_seq_to_seq&#39; B x2 n1)
                   (<span class="nv">x2</span> : {x : _ &amp; A x})
                   (<span class="nv">x3</span> : fib_seq_to_seq B (x2) ^++ n1)
                 =&gt;
                 coe
                   (ap B (seq_pair_shift_assoc x2 n1))
                   (e (x2) ^++ x3)) n0.+<span class="mi">1</span> x0 (x1) ^+)
             (<span class="kr">fun</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">x1</span> : fib_seq_to_seq B x0 <span class="mi">0</span>) =&gt; <span class="mi">1</span>)
             (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
                (<span class="nv">p0</span> : <span class="kr">forall</span> (<span class="nv">x0</span> : {x : _ &amp; A x})
                      (<span class="nv">x1</span> : fib_seq_to_seq B x0 n0),
                      (Overture.nat_rect
                         (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                          <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                          fib_seq_to_seq B x2 n1 -&gt;
                          fib_seq_to_seq&#39; B x2 n1)
                         (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                          idmap)
                         (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                            (<span class="nv">e</span> : <span class="kr">forall</span>
                                 <span class="nv">x2</span> : {x : _ &amp; ...},
                                 fib_seq_to_seq B x2
                                   n1 -&gt;
                                 fib_seq_to_seq&#39; B x2
                                   n1)
                            (<span class="nv">x2</span> : {x : _ &amp; A x})
                            (<span class="nv">x3</span> : fib_seq_to_seq B
                                    (x2) ^++ n1) =&gt;
                          coe
                            (ap B
                               (seq_pair_shift_assoc
                                  x2 n1))
                            (e (x2) ^++ x3)) n0 x0 x1)
                      ^+ =
                      Overture.nat_rect
                        (<span class="kr">fun</span> <span class="nv">n1</span> : nat =&gt;
                         <span class="kr">forall</span> <span class="nv">x2</span> : {x : _ &amp; A x},
                         fib_seq_to_seq B x2 n1 -&gt;
                         fib_seq_to_seq&#39; B x2 n1)
                        (<span class="kr">fun</span> <span class="nv">x2</span> : {x : _ &amp; A x} =&gt;
                         idmap)
                        (<span class="kr">fun</span> (<span class="nv">n1</span> : nat)
                           (<span class="nv">e</span> : <span class="kr">forall</span>
                                <span class="nv">x2</span> : {x : _ &amp; A x},
                                fib_seq_to_seq B x2 n1 -&gt;
                                fib_seq_to_seq&#39; B x2
                                  n1)
                           (<span class="nv">x2</span> : {x : _ &amp; A x})
                           (<span class="nv">x3</span> : fib_seq_to_seq B
                                   (x2) ^++ n1) =&gt;
                         coe
                           (ap B
                              (seq_pair_shift_assoc x2
                                 n1)) (e (x2) ^++ x3))
                        n0.+<span class="mi">1</span> x0 (x1) ^+)
                (<span class="nv">x0</span> : {x : _ &amp; A x})
                (<span class="nv">b</span> : fib_seq_to_seq B x0 n0.+<span class="mi">1</span>) =&gt;
              K seq_pair_shift (fibSequenceArr B)
                (seq_pair_shift_assoc x0 n0) @
              ap
                (coe
                   (ap B
                      (ap seq_pair_shift
                         (seq_pair_shift_assoc x0 n0))))
                (p0 (x0) ^++ b)) n x
       <span class="kr">end</span>
   |} n.+<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> x; srapply isequiv_compose.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** A fibered type sequence defines a type family; Section 4. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkbc"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fib_seq_to_type_fam</span> `{Univalence} {A} (B : FibSequence A) : Colimit A -&gt; <span class="kt">Type</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit A -&gt; <span class="kt">Type</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkbd"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit A -&gt; <span class="kt">Type</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkbe"><span class="highlight">srapply Colimit_rec; srapply Build_Cocone.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, A i -&gt; <span class="kt">Type</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkbf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chkbf"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o A _f g == <span class="nl">?legs</span> i</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc0"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, A i -&gt; <span class="kt">Type</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; Colimit (fib_seq_to_seq B (n;a))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc1"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n) =&gt;
 Colimit (fib_seq_to_seq B (n; a))) j o A _f g ==
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n) =&gt;
 Colimit (fib_seq_to_seq B (n; a))) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc2"><span class="highlight"><span class="nb">intros</span> n m p a; <span class="nb">destruct</span> p; <span class="nb">apply</span> path_universe_uncurried.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) &lt;~&gt;
Colimit (fib_seq_to_seq B (n; a))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (equiv_colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n;a))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc3"><span class="highlight"><span class="kn">Definition</span> <span class="nf">fib_seq_to_type_fam_beta_glue</span> `{Univalence} {A} B n a :
  coe (ap (fib_seq_to_type_fam B) (glue A n a))=
  colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n;a)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Diagram sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">coe (ap (fib_seq_to_type_fam B) (glue A n a)) =
colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Diagram sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">coe (ap (fib_seq_to_type_fam B) (glue A n a)) =
colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc5"><span class="highlight">srapply (ap _ (Colimit_rec_beta_colimp _ _ _ _ _ _) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Diagram sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">coe
  (legs_comm
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
           (<span class="nv">a</span> : A n) =&gt;
         Colimit (fib_seq_to_seq B (n; a));
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
           (<span class="nv">a</span> : A n) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
           <span class="kr">return</span>
             (Colimit
                (fib_seq_to_seq B (y; (A _f p0) a)) =
              Colimit (fib_seq_to_seq B (n; a)))
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt;
             path_universe_uncurried
               (equiv_colim_succ_seq_to_colim_seq
                  (fib_seq_to_seq B (n; a)))
         <span class="kr">end</span>
     |} n n.+<span class="mi">1</span> <span class="mi">1</span> a) =
colim_succ_seq_to_colim_seq (fib_seq_to_seq B (n; a))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply (transport_idmap_path_universe_uncurried _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc6"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Delta</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">F</span>} (<span class="nv">p</span> : x1 = x2) (<span class="nv">psi</span> : coe (ap Y p) = F) <span class="nv">y</span>
  : (x1;y) = (x2;F y).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x1; y) = (x2; F y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(x1; y) = (x2; F y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> p; <span class="nb">destruct</span> psi; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc8"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Delta_proj</span> {<span class="nv">X</span> <span class="nv">Y</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">F</span>} (<span class="nv">p</span> : x1 = x2) (<span class="nv">psi</span> : coe (ap Y p) = F) <span class="nv">y</span>
  : ap pr1 (Delta p psi y) = p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap pr1 (Delta p psi y) = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkc9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap pr1 (Delta p psi y) = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> p; <span class="nb">destruct</span> psi; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits; Definition 5.1. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkca"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_to_sum_seq_colim</span> `{Univalence} {A} (B : FibSequence A)
  : Colimit (sig_seq B) -&gt; sig (fib_seq_to_type_fam B).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (sig_seq B) -&gt;
{x : _ &amp; fib_seq_to_type_fam B x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkcb"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Colimit (sig_seq B) -&gt;
{x : _ &amp; fib_seq_to_type_fam B x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkcc"><span class="highlight">srapply Colimit_rec; srapply Build_Cocone.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
sig_seq B i -&gt; {x : _ &amp; fib_seq_to_type_fam B x}</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkcd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chkcd"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
<span class="nl">?legs</span> j o (sig_seq B) _f g == <span class="nl">?legs</span> i</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkce"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
sig_seq B i -&gt; {x : _ &amp; fib_seq_to_type_fam B x}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> n [a b]; <span class="bp">exact</span> (inj A n a; inj (fib_seq_to_seq _ _) <span class="mi">0</span> b).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkcf"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j),
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">X</span> : sig_seq B n) =&gt;
 (<span class="kr">fun</span> (<span class="nv">a</span> : A n) (<span class="nv">b</span> : B (n; a)) =&gt;
  (inj A n a; inj (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)) X.<span class="mi">1</span>
   X.<span class="mi">2</span>) j o (sig_seq B) _f g ==
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
   (<span class="nv">X</span> : sig_seq B n) =&gt;
 (<span class="kr">fun</span> (<span class="nv">a</span> : A n) (<span class="nv">b</span> : B (n; a)) =&gt;
  (inj A n a; inj (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)) X.<span class="mi">1</span>
   X.<span class="mi">2</span>) i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd0"><span class="highlight"><span class="nb">intros</span> n m p [a b]; <span class="nb">destruct</span> p; srefine (_ @ ap _ (glue (fib_seq_to_seq _ _) <span class="mi">0</span> b)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B (n; a)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(inj A n.+<span class="mi">1</span> ((a; b)) ^+.<span class="mi">1</span>;
inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; ((a; b)) ^+.<span class="mi">1</span>)) <span class="mi">0</span>
  ((a; b)) ^+.<span class="mi">2</span>) =
(inj A n a; inj (fib_seq_to_seq B (n; a)) <span class="mi">1</span> (b) ^+)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply (Delta _ (fib_seq_to_type_fam_beta_glue B n a)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd1"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_to_sum_seq_colim_beta_glue</span> `{Univalence} {A} B n a b :
  ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a;b)) =
  Delta _ (fib_seq_to_type_fam_beta_glue B n a) (inj _ _ _) @
  ap (exist _ (inj A n a)) (glue (fib_seq_to_seq _ _) <span class="mi">0</span> b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Diagram sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt; B (n; a)) a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (seq_colim_sum_to_sum_seq_colim B)
  (glue (sig_seq B) n (a; b)) =
Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
  (fib_seq_to_type_fam_beta_glue B n a)
  (inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) <span class="mi">0</span> (b) ^+) @
ap (exist (fib_seq_to_type_fam B) (inj A n a))
  (glue (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Diagram sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt; B (n; a)) a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (seq_colim_sum_to_sum_seq_colim B)
  (glue (sig_seq B) n (a; b)) =
Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
  (fib_seq_to_type_fam_beta_glue B n a)
  (inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) <span class="mi">0</span> (b) ^+) @
ap (exist (fib_seq_to_type_fam B) (inj A n a))
  (glue (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply Colimit_rec_beta_colimp.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** An alternative induction principle for the sum of colimits; Lemma 5.2 and Section 6. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">SeqColimitSumInd</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> `{Univalence} {A} (B : FibSequence A).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">E</span> : sig (fib_seq_to_type_fam B) -&gt; <span class="kt">Type</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>, E (seq_colim_sum_to_sum_seq_colim B (inj (sig_seq B) n (a;b)))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">t</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>, ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a;b))
    # e n.+<span class="mi">1</span> (a^+) (b^+f) = e n a b).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The point-point case of the nested induction; corresponds to &quot;h&quot; in the paper. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd3"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Q</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>, E (inj _ n a; inj _ k b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd5"><span class="highlight"><span class="nb">induction</span> k <span class="kr">as</span> [ | k h].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) <span class="mi">0</span>),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkd6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chkd6"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k.+<span class="mi">1</span>),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+<span class="mi">1</span> b)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd7"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) <span class="mi">0</span>),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> e.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd8"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) k b)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k.+<span class="mi">1</span>),
E (inj A n a; inj (fib_seq_to_seq B (n; a)) k.+<span class="mi">1</span> b)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> n a b; <span class="bp">exact</span> (Delta _ (fib_seq_to_type_fam_beta_glue B n a) _ # h n.+<span class="mi">1</span> (a^+) b).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The path-point case of the nested induction is just reflexivity; corresponds to &quot;mu&quot; in the paper. *)</span>

</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkd9"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Eta</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x</span> : X} {<span class="nv">y1</span> <span class="nv">y2</span> : Y x} {<span class="nv">z</span> : sig Y} {<span class="nv">p</span> : y1 = y2}
    {<span class="nv">q1</span> : z = (x;y1)} {<span class="nv">q2</span> : z = (x;y2)} (<span class="nv">theta</span> : q2 = q1 @ ap _ p)
    : transport (Z o exist Y x) p o transport Z q1 == transport Z q2.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">theta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">q2 = q1 @ ap (exist Y x) p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport (Z o exist Y x) p o transport Z q1 ==
transport Z q2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkda"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">theta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">q2 = q1 @ ap (exist Y x) p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport (Z o exist Y x) p o transport Z q1 ==
transport Z q2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkdb"><span class="highlight"><span class="nb">symmetry in</span> theta; <span class="nb">destruct</span> theta; <span class="nb">destruct</span> p; <span class="nb">simpl</span>; <span class="nb">destruct</span> q1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x0</span> : Z z =&gt; transport Z <span class="mi">1</span> x0) ==
transport Z (<span class="mi">1</span> @ <span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkdc"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Epsilon</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">y1</span> <span class="nv">y2</span>} {<span class="nv">F</span>} (<span class="nv">p</span> : x1 = x2) {<span class="nv">q</span> : y1 = y2}
    {<span class="nv">psi</span> : coe (ap Y p) = F} {<span class="nv">r</span> : F y1 = F y2} (<span class="nv">theta</span> : ap F q = r)
    : transport (Z o exist Y x2) r o transport Z (Delta p psi y1) ==
      transport Z (Delta p psi y2) o transport (Z o exist Y x1) q.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F y1 = F y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">theta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ap F q = r</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport (Z o exist Y x2) r
o transport Z (Delta p psi y1) ==
transport Z (Delta p psi y2)
o transport (Z o exist Y x1) q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkdd"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F y1 = F y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">theta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ap F q = r</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport (Z o exist Y x2) r
o transport Z (Delta p psi y1) ==
transport Z (Delta p psi y2)
o transport (Z o exist Y x1) q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> theta; <span class="nb">destruct</span> q; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The point-path case of the nested induction; corresponds to &quot;H&quot; in the paper. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkde"><span class="highlight"><span class="kn">Definition</span> <span class="nf">R</span> <span class="nv">k</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>,
    transport (E o exist _ (inj A n a)) (glue _ k b) (Q k.+<span class="mi">1</span> n a (b^+)) = Q k n a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
transport
  (E o exist (fib_seq_to_type_fam B) (inj A n a))
  (glue (fib_seq_to_seq B (n; a)) k b)
  (Q k.+<span class="mi">1</span> n a (b) ^+) = Q k n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkdf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
transport
  (E o exist (fib_seq_to_type_fam B) (inj A n a))
  (glue (fib_seq_to_seq B (n; a)) k b)
  (Q k.+<span class="mi">1</span> n a (b) ^+) = Q k n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke0"><span class="highlight"><span class="nb">induction</span> k <span class="kr">as</span> [ | k h].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) <span class="mi">0</span>),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b) (Q <span class="mi">1</span> n a (b) ^+) =
Q <span class="mi">0</span> n a b</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chke1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">1</span> n a (b) ^+) = Q k n a b</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chke1"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k.+<span class="mi">1</span>),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">2</span> n a (b) ^+) = Q k.+<span class="mi">1</span> n a b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke2"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) <span class="mi">0</span>),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b) (Q <span class="mi">1</span> n a (b) ^+) =
Q <span class="mi">0</span> n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke3"><span class="highlight"><span class="nb">intros</span> n a b; srapply (_ @ t n a b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fib_seq_to_seq B (n; a) <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b) (Q <span class="mi">1</span> n a (b) ^+) =
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply (Eta (seq_colim_sum_to_sum_seq_colim_beta_glue B n a b)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke4"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">1</span> n a (b) ^+) = Q k n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k.+<span class="mi">1</span>),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">2</span> n a (b) ^+) = Q k.+<span class="mi">1</span> n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke5"><span class="highlight"><span class="nb">intros</span> n a b; srefine (_ @ ap _ (h n.+<span class="mi">1</span> (a^+) b)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : fib_seq_to_seq B (n; a) k),
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">1</span> n a (b) ^+) = Q k n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fib_seq_to_seq B (n; a) k.+<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
   E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)
  (Q k.+<span class="mi">2</span> n a (b) ^+) =
transport E
  (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
     (fib_seq_to_type_fam_beta_glue B n a)
     (inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) k b))
  (transport
     (<span class="kr">fun</span>
        <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n.+<span class="mi">1</span> (a) ^+)
      =&gt; E (inj A n.+<span class="mi">1</span> (a) ^+; x)) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b)
     (Q k.+<span class="mi">1</span> n.+<span class="mi">1</span> (a) ^+ (b) ^+))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply (Epsilon (glue A n a) (colim_succ_seq_to_colim_seq_beta_glue _ _ _)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The point case of the nested induction; corresponds to &quot;g&quot; in the paper. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke6"><span class="highlight"><span class="kn">Definition</span> <span class="nf">F</span> <span class="nv">n</span> <span class="nv">a</span> : <span class="kr">forall</span> <span class="nv">x</span>, E (inj _ n a; x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a),
E (inj A n a; x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a),
E (inj A n a; x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chke8"><span class="highlight">srapply Colimit_ind.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph)
(<span class="nv">x</span> : fib_seq_to_seq B (n; a) i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit (fib_seq_to_seq B (n; a)) =&gt;
 E (inj A n a; w)) (inj (fib_seq_to_seq B (n; a)) i x)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chke9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chke9"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq B (n; a) i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit (fib_seq_to_seq B (n; a)) =&gt;
   E (inj A n a; w)) (colimp i j g x)
  (<span class="nl">?q</span> j (((fib_seq_to_seq B (n; a)) _f g) x)) = <span class="nl">?q</span> i x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkea"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph)
(<span class="nv">x</span> : fib_seq_to_seq B (n; a) i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit (fib_seq_to_seq B (n; a)) =&gt;
 E (inj A n a; w)) (inj (fib_seq_to_seq B (n; a)) i x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">k</span> =&gt; Q k n a).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkeb"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq B (n; a) i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit (fib_seq_to_seq B (n; a)) =&gt;
   E (inj A n a; w)) (colimp i j g x)
  ((<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt; Q k n a) j
     (((fib_seq_to_seq B (n; a)) _f g) x)) =
(<span class="kr">fun</span> <span class="nv">k</span> : Graph.graph0 sequence_graph =&gt; Q k n a) i x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> k l p; <span class="nb">destruct</span> p; <span class="bp">exact</span> (R k n a).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkec"><span class="highlight"><span class="kn">Definition</span> <span class="nf">F_beta_glue</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span> : apD (F n a) (glue _ <span class="mi">0</span> b) = R <span class="mi">0</span> n a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fib_seq_to_seq B (n; a) <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD (F n a) (glue (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b) =
R <span class="mi">0</span> n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chked"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fib_seq_to_seq B (n; a) <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD (F n a) (glue (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b) =
R <span class="mi">0</span> n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply Colimit_ind_beta_colimp.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkee"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Phi</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">y1</span> <span class="nv">y2</span>} {<span class="nv">F</span>} (<span class="nv">p</span> : x1 = x2) {<span class="nv">q</span> : y1 = y2}
    {<span class="nv">psi</span> : coe (ap Y p) = F} {<span class="nv">G1</span> : <span class="kr">forall</span> <span class="nv">y</span>, Z (x1;y)} {<span class="nv">G2</span> : <span class="kr">forall</span> <span class="nv">y</span>, Z (x2;y)}
    {<span class="nv">r</span> : F y1 = F y2} (<span class="nv">theta</span> : ap F q = r)
    : <span class="kr">forall</span> <span class="nv">u1</span> <span class="nv">u2</span>,
      apD G2 r @ u2 = ap (transport _ r) u1 @ Epsilon p theta (G1 y1) @
                      ap (transport Z (Delta p psi y2)) (apD G1 q)
      -&gt; transport (<span class="kr">fun</span> <span class="nv">y</span> =&gt; G2 (F y) = Delta p psi y # G1 y) q u1 = u2.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x2, Z (x2; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F y1 = F y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">theta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ap F q = r</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span>
(<span class="nv">u1</span> : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1))
(<span class="nv">u2</span> : G2 (F y2) = transport Z (Delta p psi y2) (G1 y2)),
apD G2 r @ u2 =
(ap (transport (<span class="kr">fun</span> <span class="nv">x</span> : Y x2 =&gt; Z (x2; x)) r) u1 @
 Epsilon p theta (G1 y1)) @
ap (transport Z (Delta p psi y2)) (apD G1 q) -&gt;
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Y x1 =&gt;
   G2 (F y) = transport Z (Delta p psi y) (G1 y)) q u1 =
u2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkef"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x2, Z (x2; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">r</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F y1 = F y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">theta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ap F q = r</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span>
(<span class="nv">u1</span> : G2 (F y1) = transport Z (Delta p psi y1) (G1 y1))
(<span class="nv">u2</span> : G2 (F y2) = transport Z (Delta p psi y2) (G1 y2)),
apD G2 r @ u2 =
(ap (transport (<span class="kr">fun</span> <span class="nv">x</span> : Y x2 =&gt; Z (x2; x)) r) u1 @
 Epsilon p theta (G1 y1)) @
ap (transport Z (Delta p psi y2)) (apD G1 q) -&gt;
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Y x1 =&gt;
   G2 (F y) = transport Z (Delta p psi y) (G1 y)) q u1 =
u2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf0"><span class="highlight"><span class="nb">destruct</span> theta; <span class="nb">destruct</span> q; <span class="nb">intros</span> u1 u2; <span class="nb">rewrite</span> ap_idmap, !concat_p1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x2, Z (x2; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u1, u2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G2 (F y1) = transport Z (Delta p psi y1) (G1 y1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD G2 (ap F <span class="mi">1</span>) @ u2 = u1 -&gt;
transport
  (<span class="kr">fun</span> <span class="nv">y</span> : Y x1 =&gt;
   G2 (F y) = transport Z (Delta p psi y) (G1 y)) <span class="mi">1</span> u1 =
u2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf1"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x2, Z (x2; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u1, u2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G2 (F y1) = transport Z (Delta p psi y1) (G1 y1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> @ u2 = u1 -&gt; u1 = u2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> s; <span class="nb">destruct</span> s; srefine (concat_1p _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The path case of the nested induction; corresponds to &quot;omega&quot; in the paper. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf2"><span class="highlight"><span class="kn">Definition</span> <span class="nf">G</span> <span class="nv">n</span> <span class="nv">a</span> : <span class="kr">forall</span> <span class="nv">y</span>,
    F n a _ = Delta _ (fib_seq_to_type_fam_beta_glue B n a) y # F n.+<span class="mi">1</span> (a^+) y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : fib_seq_to_type_fam B (inj A n.+<span class="mi">1</span> (a) ^+),
F n a
  (colim_succ_seq_to_colim_seq
     (fib_seq_to_seq B (n; a)) y) =
transport E
  (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
     (fib_seq_to_type_fam_beta_glue B n a) y)
  (F n.+<span class="mi">1</span> (a) ^+ y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : fib_seq_to_type_fam B (inj A n.+<span class="mi">1</span> (a) ^+),
F n a
  (colim_succ_seq_to_colim_seq
     (fib_seq_to_seq B (n; a)) y) =
transport E
  (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
     (fib_seq_to_type_fam_beta_glue B n a) y)
  (F n.+<span class="mi">1</span> (a) ^+ y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf4"><span class="highlight">srapply Colimit_ind.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph)
(<span class="nv">x</span> : fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+) i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) =&gt;
 F n a
   (colim_succ_seq_to_colim_seq
      (fib_seq_to_seq B (n; a)) w) =
 transport E
   (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
      (fib_seq_to_type_fam_beta_glue B n a) w)
   (F n.+<span class="mi">1</span> (a) ^+ w))
  (inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) i x)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chkf5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chkf5"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+) i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+))
   =&gt;
   F n a
     (colim_succ_seq_to_colim_seq
        (fib_seq_to_seq B (n; a)) w) =
   transport E
     (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
        (fib_seq_to_type_fam_beta_glue B n a) w)
     (F n.+<span class="mi">1</span> (a) ^+ w)) (colimp i j g x)
  (<span class="nl">?q</span> j (((fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) _f g) x)) =
<span class="nl">?q</span> i x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf6"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph)
(<span class="nv">x</span> : fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+) i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) =&gt;
 F n a
   (colim_succ_seq_to_colim_seq
      (fib_seq_to_seq B (n; a)) w) =
 transport E
   (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
      (fib_seq_to_type_fam_beta_glue B n a) w)
   (F n.+<span class="mi">1</span> (a) ^+ w))
  (inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) i x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">b</span> =&gt; idpath).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf7"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+) i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+))
   =&gt;
   F n a
     (colim_succ_seq_to_colim_seq
        (fib_seq_to_seq B (n; a)) w) =
   transport E
     (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
        (fib_seq_to_type_fam_beta_glue B n a) w)
     (F n.+<span class="mi">1</span> (a) ^+ w)) (colimp i j g x)
  ((<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
      (<span class="nv">b</span> : fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+) k) =&gt; <span class="mi">1</span>) j
     (((fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) _f g) x)) =
(<span class="kr">fun</span> (<span class="nv">k</span> : Graph.graph0 sequence_graph)
   (<span class="nv">b</span> : fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+) k) =&gt; <span class="mi">1</span>) i x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf8"><span class="highlight"><span class="nb">intros</span> k l p b; <span class="nb">destruct</span> p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+) k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+))
   =&gt;
   F n a
     (colim_succ_seq_to_colim_seq
        (fib_seq_to_seq B (n; a)) w) =
   transport E
     (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
        (fib_seq_to_type_fam_beta_glue B n a) w)
     (F n.+<span class="mi">1</span> (a) ^+ w)) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b) <span class="mi">1</span> = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkf9"><span class="highlight">snrapply (Phi (glue A n a) (colim_succ_seq_to_colim_seq_beta_glue _ _ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+) k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD (F n a) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b) @ <span class="mi">1</span> =
(ap
   (transport
      (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
       E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)) <span class="mi">1</span> @
 Epsilon (glue A n a)
   (colim_succ_seq_to_colim_seq_beta_glue
      (fib_seq_to_seq B (n; a)) k b)
   (F n.+<span class="mi">1</span> (a) ^+
      (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+<span class="mi">1</span>
         (b) ^+))) @
ap
  (transport E
     (Delta (glue A n a)
        (fib_seq_to_type_fam_beta_glue B n a)
        (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))
  (apD (F n.+<span class="mi">1</span> (a) ^+) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkfa"><span class="highlight"><span class="nb">rewrite</span> (Colimit_ind_beta_colimp _ (<span class="kr">fun</span> <span class="nv">k</span> =&gt; Q k n a) _ _ _ idpath).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+) k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">R k.+<span class="mi">1</span> n a b @ <span class="mi">1</span> =
(ap
   (transport
      (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
       E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)) <span class="mi">1</span> @
 Epsilon (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
   (colim_succ_seq_to_colim_seq_beta_glue
      (fib_seq_to_seq B (n; a)) k b)
   (F n.+<span class="mi">1</span> (a) ^+
      (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+<span class="mi">1</span>
         (b) ^+))) @
ap
  (transport E
     (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
        (fib_seq_to_type_fam_beta_glue B n a)
        (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))
  (apD (F n.+<span class="mi">1</span> (a) ^+) (colimp k k.+<span class="mi">1</span> <span class="mi">1</span> b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkfb"><span class="highlight"><span class="nb">rewrite</span> (Colimit_ind_beta_colimp _ (<span class="kr">fun</span> <span class="nv">k</span> =&gt; Q k n.+<span class="mi">1</span> a^+) _ _ _ idpath).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+) k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">R k.+<span class="mi">1</span> n a b @ <span class="mi">1</span> =
(ap
   (transport
      (<span class="kr">fun</span> <span class="nv">x</span> : fib_seq_to_type_fam B (inj A n a) =&gt;
       E (inj A n a; x)) (colimp k.+<span class="mi">1</span> k.+<span class="mi">2</span> <span class="mi">1</span> b)) <span class="mi">1</span> @
 Epsilon (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
   (colim_succ_seq_to_colim_seq_beta_glue
      (fib_seq_to_seq B (n; a)) k b)
   (F n.+<span class="mi">1</span> (a) ^+
      (inj (succ_seq (fib_seq_to_seq B (n; a))) k.+<span class="mi">1</span>
         (b) ^+))) @
ap
  (transport E
     (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
        (fib_seq_to_type_fam_beta_glue B n a)
        (inj (succ_seq (fib_seq_to_seq B (n; a))) k b)))
  (R k n.+<span class="mi">1</span> (a) ^+ b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> concat_p1, concat_1p; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkfc"><span class="highlight"><span class="kn">Definition</span> <span class="nf">I</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} {<span class="nv">p</span> : x1 = x2} {<span class="nv">F</span>} (<span class="nv">psi</span> : coe (ap Y p) = F) {<span class="nv">G1</span> <span class="nv">G2</span>}
    : transport (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">y</span>, Z (x;y)) p G1 = G2 &lt;~&gt;
      <span class="kr">forall</span> <span class="nv">y</span>, G2 (F y) = Delta p psi y # G1 y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x2 : X &amp; idmap (Y x2)} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x1,
Z (x1; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x2,
Z (x2; y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x, Z (x; y))
  p G1 = G2 &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">y</span> : Y x1,
 G2 (F y) = transport Z (Delta p psi y) (G1 y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkfd"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x2 : X &amp; idmap (Y x2)} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x1,
Z (x1; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x2,
Z (x2; y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x, Z (x; y))
  p G1 = G2 &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">y</span> : Y x1,
 G2 (F y) = transport Z (Delta p psi y) (G1 y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkfe"><span class="highlight"><span class="nb">destruct</span> p; <span class="nb">destruct</span> psi.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x2 : X &amp; idmap (Y x2)} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x1,
Z (x1; y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x1, Z (x1; y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport (<span class="kr">fun</span> <span class="nv">x</span> : X =&gt; <span class="kr">forall</span> <span class="nv">y</span> : Y x, Z (x; y)) <span class="mi">1</span> G1 =
G2 &lt;~&gt;
(<span class="kr">forall</span> <span class="nv">y</span> : Y x1,
 G2 (coe (ap Y <span class="mi">1</span>) y) =
 transport Z (Delta <span class="mi">1</span> <span class="mi">1</span> y) (G1 y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srefine (<span class="nb">transitivity</span> (equiv_path_inverse _ _) (equiv_apD10 _ _ _)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The alternative induction rule in curried form; corresponds to curried &quot;G&quot; in</span>
<span class="sd">      the paper. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chkff"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_ind_cur</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, E (x;y).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : Colimit A) (<span class="nv">y</span> : fib_seq_to_type_fam B x),
E (x; y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk100"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : Colimit A) (<span class="nv">y</span> : fib_seq_to_type_fam B x),
E (x; y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk101"><span class="highlight">srapply (Colimit_ind _ F); <span class="nb">intros</span> n m p a; <span class="nb">destruct</span> p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : fib_seq_to_type_fam B w, E (w; y))
  (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a) (F n.+<span class="mi">1</span> (a) ^+) = F n a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> ((I (fib_seq_to_type_fam_beta_glue B n a))^-<span class="mi">1</span> (G n a)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The computation rule for the alternative induction rule in curried form. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk102"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_ind_cur_beta_glue</span> <span class="nv">n</span> <span class="nv">a</span> :
    I (fib_seq_to_type_fam_beta_glue B n a) (apD seq_colim_sum_ind_cur (glue _ n a)) = G n a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">I (fib_seq_to_type_fam_beta_glue B n a)
  (apD seq_colim_sum_ind_cur (glue A n a)) = G n a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk103"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">I (fib_seq_to_type_fam_beta_glue B n a)
  (apD seq_colim_sum_ind_cur (glue A n a)) = G n a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> moveR_equiv_M; srapply Colimit_ind_beta_colimp.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The alternative induction rule; corresponds to &quot;G&quot; in the paper. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk104"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_ind</span> : <span class="kr">forall</span> <span class="nv">x</span>, E x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; fib_seq_to_type_fam B x}, E x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk105"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; fib_seq_to_type_fam B x}, E x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> [x y]; <span class="nb">apply</span> seq_colim_sum_ind_cur.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk106"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Xi</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} <span class="nv">G</span> {<span class="nv">x</span> : X} {<span class="nv">y1</span> <span class="nv">y2</span> : Y x} {<span class="nv">z</span> : sig Y} {<span class="nv">p</span> : y1 = y2}
    {<span class="nv">q1</span> : z = (x;y1)} {<span class="nv">q2</span> : z = (x;y2)} (<span class="nv">theta</span> : q2 = q1 @ ap _ p)
    : apD (G o exist Y x) p =
      ap (transport (Z o exist Y x) p) (apD G q1)^ @ Eta theta (G z) @ apD G q2.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; Y x}, Z x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">theta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">q2 = q1 @ ap (exist Y x) p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD (G o exist Y x) p =
(ap (transport (Z o exist Y x) p) (apD G q1)^ @
 Eta theta (G z)) @ apD G q2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk107"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; Y x}, Z x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">theta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">q2 = q1 @ ap (exist Y x) p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD (G o exist Y x) p =
(ap (transport (Z o exist Y x) p) (apD G q1)^ @
 Eta theta (G z)) @ apD G q2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk108"><span class="highlight"><span class="nb">revert</span> theta; srapply (equiv_ind (equiv_path_inverse _ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; Y x}, Z x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y1)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y2)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : q1 @ ap (exist Y x) p = q2,
(<span class="kr">fun</span> <span class="nv">y</span> : q2 = q1 @ ap (exist Y x) p =&gt;
 apD (G o exist Y x) p =
 (ap (transport (Z o exist Y x) p) (apD G q1)^ @
  Eta y (G z)) @ apD G q2)
  (equiv_path_inverse (q1 @ ap (exist Y x) p) q2 x0)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk109"><span class="highlight"><span class="nb">intro</span> s; <span class="nb">destruct</span> s.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; Y x}, Z x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">z = (x; y1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD (<span class="kr">fun</span> <span class="nv">x0</span> : Y x =&gt; G (x; x0)) p =
(ap (transport (<span class="kr">fun</span> <span class="nv">x0</span> : Y x =&gt; Z (x; x0)) p)
   (apD G q1)^ @
 Eta
   (equiv_path_inverse (q1 @ ap (exist Y x) p)
      (q1 @ ap (exist Y x) p) <span class="mi">1</span>) (G z)) @
apD G (q1 @ ap (exist Y x) p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10a"><span class="highlight"><span class="nb">revert</span> q1; srapply (equiv_ind (equiv_path_inverse _ _)); <span class="nb">intro</span> s; <span class="nb">destruct</span> s.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; Y x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : {x : _ &amp; Y x}, Z x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y1, y2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y1 = y2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD (<span class="kr">fun</span> <span class="nv">x0</span> : Y x =&gt; G (x; x0)) p =
(ap (transport (<span class="kr">fun</span> <span class="nv">x0</span> : Y x =&gt; Z (x; x0)) p)
   (apD G (equiv_path_inverse (x; y1) (x; y1) <span class="mi">1</span>))^ @
 Eta
   (equiv_path_inverse
      (equiv_path_inverse (x; y1) (x; y1) <span class="mi">1</span> @
       ap (exist Y x) p)
      (equiv_path_inverse (x; y1) (x; y1) <span class="mi">1</span> @
       ap (exist Y x) p) <span class="mi">1</span>) (G (x; y1))) @
apD G
  (equiv_path_inverse (x; y1) (x; y1) <span class="mi">1</span> @
   ap (exist Y x) p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> p; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10b"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Mu</span> {<span class="nv">X</span> <span class="nv">Y</span> <span class="nv">Z</span>} {<span class="nv">x1</span> <span class="nv">x2</span> : X} (<span class="nv">p</span> : x1 = x2) {<span class="nv">F</span>} (<span class="nv">G</span> : <span class="kr">forall</span> <span class="nv">z</span>, Z z)
    {<span class="nv">psi</span> : coe (ap Y p) = F} {<span class="nv">q</span>} (<span class="nv">theta</span> : I psi (apD (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; G (x;y)) p) = q) <span class="nv">y</span>
    : apD G (Delta p psi y) = (q y)^.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x2 : X &amp; idmap (Y x2)} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : {x2 : X &amp; idmap (Y x2)}, Z z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x1,
(<span class="kr">fun</span> <span class="nv">y0</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x2 =&gt;
 G (x2; y0)) (F y) =
transport Z (Delta p psi y)
  ((<span class="kr">fun</span> <span class="nv">y0</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x1 =&gt;
    G (x1; y0)) y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">theta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">I psi
  (apD
     (<span class="kr">fun</span> (<span class="nv">x</span> : X)
        (<span class="nv">y</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x)
      =&gt; G (x; y)) p) = q</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD G (Delta p psi y) = (q y)^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x2 : X &amp; idmap (Y x2)} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x1, x2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x1 = x2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">idmap (Y x1) -&gt; idmap (Y x2)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : {x2 : X &amp; idmap (Y x2)}, Z z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">psi</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">coe (ap Y p) = F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Y x1,
(<span class="kr">fun</span> <span class="nv">y0</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x2 =&gt;
 G (x2; y0)) (F y) =
transport Z (Delta p psi y)
  ((<span class="kr">fun</span> <span class="nv">y0</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x1 =&gt;
    G (x1; y0)) y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">theta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">I psi
  (apD
     (<span class="kr">fun</span> (<span class="nv">x</span> : X)
        (<span class="nv">y</span> : (<span class="kr">fun</span> <span class="nv">x2</span> : X =&gt; idmap (Y x2)) x)
      =&gt; G (x; y)) p) = q</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y x1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD G (Delta p psi y) = (q y)^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> p; <span class="nb">destruct</span> psi; <span class="nb">destruct</span> theta; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The computation rule for the alternative induction rule. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10d"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_ind_beta_glue</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>,
    apD seq_colim_sum_ind (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n _)) =
    t n a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)),
apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)),
apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk10f"><span class="highlight"><span class="nb">intros</span> n a b; <span class="nb">pose</span> (h := F_beta_glue n a b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B (n; a)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">F_beta_glue n a b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">apD (F n a) (glue (fib_seq_to_seq B (n; a)) <span class="mi">0</span> b) =
R <span class="mi">0</span> n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk110"><span class="highlight"><span class="nb">rewrite</span> (Xi seq_colim_sum_ind (seq_colim_sum_to_sum_seq_colim_beta_glue B n a b)) <span class="kr">in</span> h.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B (n; a)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(ap
   (transport
      (<span class="kr">fun</span> <span class="nv">x0</span> : fib_seq_to_type_fam B (inj A n a)
       =&gt; E (inj A n a; x0)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b))
   (apD seq_colim_sum_ind
      (Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)
         (fib_seq_to_type_fam_beta_glue B n a)
         (inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) <span class="mi">0</span>
            (b) ^+)))^ @
 Eta
   (seq_colim_sum_to_sum_seq_colim_beta_glue B n a
      b)
   (seq_colim_sum_ind
      (seq_colim_sum_to_sum_seq_colim B
         (inj (sig_seq B) n.+<span class="mi">1</span> ((a; b)) ^+)))) @
apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b))) = R <span class="mi">0</span> n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk111"><span class="highlight"><span class="nb">rewrite</span> (Mu (glue _ n a) seq_colim_sum_ind (seq_colim_sum_ind_cur_beta_glue n a)) <span class="kr">in</span> h.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
E
  (seq_colim_sum_to_sum_seq_colim B
     (inj (sig_seq B) n (a; b)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
transport E
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (e n.+<span class="mi">1</span> (a) ^+ (b) ^+f) = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B (n; a)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(ap
   (transport
      (<span class="kr">fun</span> <span class="nv">x0</span> : fib_seq_to_type_fam B (inj A n a)
       =&gt; E (inj A n a; x0)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b))
   ((G n a
       (inj (fib_seq_to_seq B (n.+<span class="mi">1</span>; (a) ^+)) <span class="mi">0</span>
          (b) ^+))^)^ @
 Eta
   (seq_colim_sum_to_sum_seq_colim_beta_glue B n a
      b)
   (seq_colim_sum_ind
      (seq_colim_sum_to_sum_seq_colim B
         (inj (sig_seq B) n.+<span class="mi">1</span> ((a; b)) ^+)))) @
apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b))) = R <span class="mi">0</span> n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD seq_colim_sum_ind
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> concat_1p <span class="kr">in</span> h; <span class="bp">exact</span> (cancelL _ _ _ h).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">SeqColimitSumInd</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** An alternative recursion principle for the sum of colimits; Lemma 5.3. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">SeqColimitSumRec</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> `{Univalence} {A} (B : FibSequence A).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> <span class="nv">E</span> (<span class="nv">e</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span>, B (n;a) -&gt; E).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">t</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> (<span class="nv">b</span> : B (n;a)), e n.+<span class="mi">1</span> (a^+) (b^+f) = e n a b).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk112"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_rec</span> : sig (fib_seq_to_type_fam B)-&gt; E.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n), B (n; a) -&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), e n.+<span class="mi">1</span> (a) ^+ (b) ^+f = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; E</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk113"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n), B (n; a) -&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), e n.+<span class="mi">1</span> (a) ^+ (b) ^+f = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; E</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (seq_colim_sum_ind B _ e (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; transport_const _ _ @ t n a b)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk114"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_rec_beta_glue</span> : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span>,
    ap seq_colim_sum_rec (ap (seq_colim_sum_to_sum_seq_colim B) (glue (sig_seq B) n (a;b))) =
    t n a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n), B (n; a) -&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), e n.+<span class="mi">1</span> (a) ^+ (b) ^+f = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
ap seq_colim_sum_rec
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk115"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n), B (n; a) -&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), e n.+<span class="mi">1</span> (a) ^+ (b) ^+f = e n a b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a),
ap seq_colim_sum_rec
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) = t n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk116"><span class="highlight"><span class="nb">intros</span> n a b; srapply (cancelL _ _ _ ((apD_const _ _)^ @ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : A n), B (n; a) -&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">t</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), e n.+<span class="mi">1</span> (a) ^+ (b) ^+f = e n a b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt; B (n; a)) a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD seq_colim_sum_rec
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b))) =
transport_const
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  (seq_colim_sum_rec
     (seq_colim_sum_to_sum_seq_colim B
        (inj (sig_seq B) n.+<span class="mi">1</span> ((a; b)) ^+))) @ t n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply seq_colim_sum_ind_beta_glue.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">SeqColimitSumRec</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Lemma 5.4. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk117"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colimit_sum_uniq</span> `{Univalence} {A} (B : FibSequence A) E
  (F G : sig (fib_seq_to_type_fam B) -&gt; E)
  : F o (seq_colim_sum_to_sum_seq_colim B) == G o (seq_colim_sum_to_sum_seq_colim B) -&gt;
    F == G.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F, G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; E</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">F o seq_colim_sum_to_sum_seq_colim B ==
G o seq_colim_sum_to_sum_seq_colim B -&gt; F == G</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk118"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F, G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; E</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">F o seq_colim_sum_to_sum_seq_colim B ==
G o seq_colim_sum_to_sum_seq_colim B -&gt; F == G</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk119"><span class="highlight"><span class="nb">intro</span> h; srapply (seq_colim_sum_ind B _ (<span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> =&gt; h _)); <span class="nb">intros</span> n a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F, G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt; E</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">F o seq_colim_sum_to_sum_seq_colim B ==
G o seq_colim_sum_to_sum_seq_colim B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">a</span> : A n =&gt; B (n; a)) a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; fib_seq_to_type_fam B x} =&gt;
   F x = G x)
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (glue (sig_seq B) n (a; b)))
  ((<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
      (<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a) =&gt;
    h (inj (sig_seq B) n (a; b))) n.+<span class="mi">1</span> (a) ^+ (b) ^+f) =
(<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
   (<span class="nv">b</span> : (<span class="kr">fun</span> <span class="nv">a0</span> : A n =&gt; B (n; a0)) a) =&gt;
 h (inj (sig_seq B) n (a; b))) n a b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply ((transport_compose _ _ _ _)^ @ _); <span class="bp">exact</span> (apD h (glue (sig_seq B) n (a;b))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits is an equivalence; Theorem 5.1. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11a"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_seq_colim_sum_to_sum_seq_colim</span> `{Univalence} {A} (B : FibSequence A)
  : IsEquiv (seq_colim_sum_to_sum_seq_colim B).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (seq_colim_sum_to_sum_seq_colim B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (seq_colim_sum_to_sum_seq_colim B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11c"><span class="highlight"><span class="nb">assert</span> (L : {G : _ &amp; G o seq_colim_sum_to_sum_seq_colim B == idmap}).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{G
: {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
  Colimit (sig_seq B) &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 G (seq_colim_sum_to_sum_seq_colim B x)) == idmap}</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk11d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">L</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{G
: {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
  Colimit (sig_seq B) &amp;
G o seq_colim_sum_to_sum_seq_colim B == idmap}</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk11d"><hr></label><div class="goal-conclusion"><span class="highlight">IsEquiv (seq_colim_sum_to_sum_seq_colim B)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11e"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{G
: {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
  Colimit (sig_seq B) &amp;
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 G (seq_colim_sum_to_sum_seq_colim B x)) == idmap}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk11f"><span class="highlight">srapply (_;_).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt;
Colimit (sig_seq B)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk120" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk120"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   <span class="nv">G</span> : {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
       Colimit (sig_seq B) =&gt;
 (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
  G (seq_colim_sum_to_sum_seq_colim B x)) == idmap)
  <span class="nl">?proj1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk121"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; fib_seq_to_type_fam B x} -&gt;
Colimit (sig_seq B)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk122"><span class="highlight">srapply seq_colim_sum_rec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n),
B (n; a) -&gt; Colimit (sig_seq B)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk123" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk123"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)), <span class="nl">?e</span> n.+<span class="mi">1</span> (a) ^+ (b) ^+f = <span class="nl">?e</span> n a b</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk124"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n),
B (n; a) -&gt; Colimit (sig_seq B)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; inj (sig_seq B) n (a;b)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk125"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
(<span class="nv">b</span> : B (n; a)),
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a0</span> : A n0)
   (<span class="nv">b0</span> : B (n0; a0)) =&gt; inj (sig_seq B) n0 (a0; b0))
  n.+<span class="mi">1</span> (a) ^+ (b) ^+f =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a0</span> : A n0)
   (<span class="nv">b0</span> : B (n0; a0)) =&gt; inj (sig_seq B) n0 (a0; b0)) n
  a b</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> <span class="nv">b</span> =&gt; glue (sig_seq B) n (a;b)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk126"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   <span class="nv">G</span> : {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
       Colimit (sig_seq B) =&gt;
 (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
  G (seq_colim_sum_to_sum_seq_colim B x)) == idmap)
  (seq_colim_sum_rec B (Colimit (sig_seq B))
     (<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
        (<span class="nv">b</span> : B (n; a)) =&gt; inj (sig_seq B) n (a; b))
     (<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
        (<span class="nv">b</span> : B (n; a)) =&gt; glue (sig_seq B) n (a; b)))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk127"><span class="highlight">srapply seq_colimit_uniq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 seq_colim_sum_rec B (Colimit (sig_seq B))
   (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n0)
      (<span class="nv">b</span> : B (n0; a)) =&gt; inj (sig_seq B) n0 (a; b))
   (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n0)
      (<span class="nv">b</span> : B (n0; a)) =&gt; glue (sig_seq B) n0 (a; b))
   (seq_colim_sum_to_sum_seq_colim B x))
o inj (sig_seq B) n == idmap o inj (sig_seq B) n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk128" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk128"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : sig_seq B n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
   seq_colim_sum_rec B (Colimit (sig_seq B))
     (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
        (<span class="nv">a0</span> : A n0) (<span class="nv">b</span> : B (n0; a0)) =&gt;
      inj (sig_seq B) n0 (a0; b))
     (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
        (<span class="nv">a0</span> : A n0) (<span class="nv">b</span> : B (n0; a0)) =&gt;
      glue (sig_seq B) n0 (a0; b))
     (seq_colim_sum_to_sum_seq_colim B x))
  (glue (sig_seq B) n a) @ <span class="nl">?h</span> n a =
<span class="nl">?h</span> n.+<span class="mi">1</span> (a) ^+ @ ap idmap (glue (sig_seq B) n a)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk129"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 seq_colim_sum_rec B (Colimit (sig_seq B))
   (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n0)
      (<span class="nv">b</span> : B (n0; a)) =&gt; inj (sig_seq B) n0 (a; b))
   (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n0)
      (<span class="nv">b</span> : B (n0; a)) =&gt; glue (sig_seq B) n0 (a; b))
   (seq_colim_sum_to_sum_seq_colim B x))
o inj (sig_seq B) n == idmap o inj (sig_seq B) n</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; idpath).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12a"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : sig_seq B n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
   seq_colim_sum_rec B (Colimit (sig_seq B))
     (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
        (<span class="nv">a0</span> : A n0) (<span class="nv">b</span> : B (n0; a0)) =&gt;
      inj (sig_seq B) n0 (a0; b))
     (<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
        (<span class="nv">a0</span> : A n0) (<span class="nv">b</span> : B (n0; a0)) =&gt;
      glue (sig_seq B) n0 (a0; b))
     (seq_colim_sum_to_sum_seq_colim B x))
  (glue (sig_seq B) n a) @
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : sig_seq B n0) =&gt; <span class="mi">1</span>) n a =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : sig_seq B n0) =&gt; <span class="mi">1</span>) n.+<span class="mi">1</span> (a) ^+ @
ap idmap (glue (sig_seq B) n a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12b"><span class="highlight"><span class="nb">intros</span> n a; <span class="nb">rewrite</span> concat_1p, concat_p1, ap_compose, ap_idmap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">sig_seq B n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (seq_colim_sum_rec B (Colimit (sig_seq B))
     (<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
        (<span class="nv">b</span> : B (n; a)) =&gt; inj (sig_seq B) n (a; b))
     (<span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph) (<span class="nv">a</span> : A n)
        (<span class="nv">b</span> : B (n; a)) =&gt; colimp n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b)))
  (ap (seq_colim_sum_to_sum_seq_colim B)
     (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a)) = colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> seq_colim_sum_rec_beta_glue; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12c"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">L</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{G
: {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
  Colimit (sig_seq B) &amp;
G o seq_colim_sum_to_sum_seq_colim B == idmap}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (seq_colim_sum_to_sum_seq_colim B)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12d"><span class="highlight">srapply (isequiv_adjointify _ L.<span class="mi">1</span> _ L.<span class="mi">2</span>); srapply seq_colimit_sum_uniq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">L</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{G
: {x : _ &amp; fib_seq_to_type_fam B x} -&gt;
  Colimit (sig_seq B) &amp;
G o seq_colim_sum_to_sum_seq_colim B == idmap}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; fib_seq_to_type_fam B x} =&gt;
 seq_colim_sum_to_sum_seq_colim B (L.<span class="mi">1</span> x))
o seq_colim_sum_to_sum_seq_colim B ==
idmap o seq_colim_sum_to_sum_seq_colim B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> x; <span class="nb">rewrite</span> L.<span class="mi">2</span>; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_seq_colim_sum_to_sum_seq_colim</span> `{Univalence} {A} (B : FibSequence A)
  : Colimit (sig_seq B) &lt;~&gt; sig (fib_seq_to_type_fam B)
  := Build_Equiv _ _ _ (isequiv_seq_colim_sum_to_sum_seq_colim B).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits commutes with the first projection; Theorem 5.1. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12e"><span class="highlight"><span class="kn">Definition</span> <span class="nf">seq_colim_sum_to_sum_seq_colim_fst</span> `{Univalence} {A} (B : FibSequence A)
  : pr1 o (seq_colim_sum_to_sum_seq_colim B) == seq_colim_sum_to_seq_colim_fst B.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pr1 o seq_colim_sum_to_sum_seq_colim B ==
seq_colim_sum_to_seq_colim_fst B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk12f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pr1 o seq_colim_sum_to_sum_seq_colim B ==
seq_colim_sum_to_seq_colim_fst B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk130"><span class="highlight">srapply seq_colimit_uniq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 (seq_colim_sum_to_sum_seq_colim B x).<span class="mi">1</span>)
o inj (sig_seq B) n ==
seq_colim_sum_to_seq_colim_fst B o inj (sig_seq B) n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk131" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk131"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : sig_seq B n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
   (seq_colim_sum_to_sum_seq_colim B x).<span class="mi">1</span>)
  (glue (sig_seq B) n a) @ <span class="nl">?h</span> n a =
<span class="nl">?h</span> n.+<span class="mi">1</span> (a) ^+ @
ap (seq_colim_sum_to_seq_colim_fst B)
  (glue (sig_seq B) n a)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk132"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
(<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
 (seq_colim_sum_to_sum_seq_colim B x).<span class="mi">1</span>)
o inj (sig_seq B) n ==
seq_colim_sum_to_seq_colim_fst B o inj (sig_seq B) n</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> <span class="nv">a</span> =&gt; idpath).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk133"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
(<span class="nv">a</span> : sig_seq B n),
ap
  (<span class="kr">fun</span> <span class="nv">x</span> : Colimit (sig_seq B) =&gt;
   (seq_colim_sum_to_sum_seq_colim B x).<span class="mi">1</span>)
  (glue (sig_seq B) n a) @
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : sig_seq B n0) =&gt; <span class="mi">1</span>) n a =
(<span class="kr">fun</span> (<span class="nv">n0</span> : Graph.graph0 sequence_graph)
   (<span class="nv">a0</span> : sig_seq B n0) =&gt; <span class="mi">1</span>) n.+<span class="mi">1</span> (a) ^+ @
ap (seq_colim_sum_to_seq_colim_fst B)
  (glue (sig_seq B) n a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk134"><span class="highlight"><span class="nb">intros</span> n [a b]; <span class="nb">rewrite</span> concat_1p, concat_p1, ap_compose, !Colimit_rec_beta_colimp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B (n; a)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap pr1
  (legs_comm
     {|
       legs :=
         <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
           (<span class="nv">X</span> : sig_seq B n) =&gt;
         (inj A n X.<span class="mi">1</span>;
         inj (fib_seq_to_seq B (n; X.<span class="mi">1</span>)) <span class="mi">0</span> X.<span class="mi">2</span>);
       legs_comm :=
         <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
           (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
           (<span class="nv">x</span> : sig_seq B n) =&gt;
         <span class="kr">match</span>
           p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
           <span class="kr">return</span>
             ((inj A y
                 (((sig_seq B) _f p0) (x.<span class="mi">1</span>; x.<span class="mi">2</span>)).<span class="mi">1</span>;
              inj
                (fib_seq_to_seq B
                   (y;
                   (((sig_seq B) _f p0) (x.<span class="mi">1</span>; x.<span class="mi">2</span>)).<span class="mi">1</span>))
                <span class="mi">0</span> (((sig_seq B) _f p0) (x.<span class="mi">1</span>; x.<span class="mi">2</span>)).<span class="mi">2</span>) =
              (inj A n x.<span class="mi">1</span>;
              inj (fib_seq_to_seq B (n; x.<span class="mi">1</span>)) <span class="mi">0</span> x.<span class="mi">2</span>))
         <span class="kr">with</span>
         | <span class="mi">1</span> =&gt;
             Delta (colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x.<span class="mi">1</span>)
               (fib_seq_to_type_fam_beta_glue B n x.<span class="mi">1</span>)
               (inj
                  (fib_seq_to_seq B
                     (n.+<span class="mi">1</span>; ((x.<span class="mi">1</span>; x.<span class="mi">2</span>)) ^+.<span class="mi">1</span>)) <span class="mi">0</span>
                  ((x.<span class="mi">1</span>; x.<span class="mi">2</span>)) ^+.<span class="mi">2</span>) @
             ap
               (exist (fib_seq_to_type_fam B)
                  (inj A n x.<span class="mi">1</span>)) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> x.<span class="mi">2</span>)
         <span class="kr">end</span>
     |} n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b)) =
legs_comm
  {|
    legs :=
      <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
        (<span class="nv">X</span> : sig_seq B n) =&gt; inj A n X.<span class="mi">1</span>;
    legs_comm :=
      <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
        (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
        (<span class="nv">x</span> : sig_seq B n) =&gt;
      <span class="kr">match</span>
        p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
        <span class="kr">return</span>
          (inj A y (((sig_seq B) _f p0) (x.<span class="mi">1</span>; x.<span class="mi">2</span>)).<span class="mi">1</span> =
           inj A n x.<span class="mi">1</span>)
      <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x.<span class="mi">1</span>
      <span class="kr">end</span>
  |} n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk135"><span class="highlight"><span class="nb">rewrite</span> ap_pp, (Delta_proj _ (fib_seq_to_type_fam_beta_glue B n a)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B (n; a)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">colimp n n.+<span class="mi">1</span> <span class="mi">1</span> a @
ap pr1
  (ap (exist (fib_seq_to_type_fam B) (inj A n a))
     (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b)) =
legs_comm
  {|
    legs :=
      <span class="kr">fun</span> (<span class="nv">n</span> : Graph.graph0 sequence_graph)
        (<span class="nv">X</span> : sig_seq B n) =&gt; inj A n X.<span class="mi">1</span>;
    legs_comm :=
      <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
        (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
        (<span class="nv">x</span> : sig_seq B n) =&gt;
      <span class="kr">match</span>
        p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
        <span class="kr">return</span>
          (inj A y (((sig_seq B) _f p0) (x.<span class="mi">1</span>; x.<span class="mi">2</span>)).<span class="mi">1</span> =
           inj A n x.<span class="mi">1</span>)
      <span class="kr">with</span>
      | <span class="mi">1</span> =&gt; colimp n n.+<span class="mi">1</span> <span class="mi">1</span> x.<span class="mi">1</span>
      <span class="kr">end</span>
  |} n n.+<span class="mi">1</span> <span class="mi">1</span> (a; b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk136"><span class="highlight">srapply (whiskerL _ _ @ concat_p1 _); <span class="nb">rewrite</span> (ap_compose _ _ _)^; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B (n; a)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap
  (<span class="kr">fun</span> <span class="nv">_</span> : Colimit (fib_seq_to_seq B (n; a)) =&gt;
   inj A n a) (colimp <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> b) = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> ap_const; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The characterization of path spaces in sequential colimits; Theorem 7.4, first part. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">path_seq</span> (<span class="nv">A</span> : Sequence) (<span class="nv">a1</span> <span class="nv">a2</span> : A <span class="mi">0</span>)
  := Build_Sequence (<span class="kr">fun</span> <span class="nv">k</span> =&gt; a1^+k = a2^+k) (<span class="kr">fun</span> <span class="nv">k</span> <span class="nv">p</span> =&gt; ap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; a^+) p).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk137"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_path_colim_zero</span> `{Univalence} {A : Sequence} (a1 a2 : A <span class="mi">0</span>) :
  (inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2) &lt;~&gt; Colimit (path_seq A a1 a2).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2 &lt;~&gt; Colimit (path_seq A a1 a2)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk138"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2 &lt;~&gt; Colimit (path_seq A a1 a2)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk139"><span class="highlight"><span class="nb">pose</span> (B := Build_FibSequence A (<span class="kr">fun</span> <span class="nv">x</span> =&gt; a1^+(x.<span class="mi">1</span>) = x.<span class="mi">2</span>) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; a^+))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2 &lt;~&gt; Colimit (path_seq A a1 a2)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13a"><span class="highlight"><span class="nb">transitivity</span> (fib_seq_to_type_fam B (inj A <span class="mi">0</span> a2)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2 &lt;~&gt;
fib_seq_to_type_fam B (inj A <span class="mi">0</span> a2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk13b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk13b"><hr></label><div class="goal-conclusion"><span class="highlight">fib_seq_to_type_fam B (inj A <span class="mi">0</span> a2) &lt;~&gt;
Colimit (path_seq A a1 a2)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13c"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj A <span class="mi">0</span> a1 = inj A <span class="mi">0</span> a2 &lt;~&gt;
fib_seq_to_type_fam B (inj A <span class="mi">0</span> a2)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13d"><span class="highlight"><span class="nb">symmetry</span>; srapply equiv_path_from_contr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fib_seq_to_type_fam B (inj A <span class="mi">0</span> a1)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk13e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk13e"><hr></label><div class="goal-conclusion"><span class="highlight">Contr {y : Colimit A &amp; fib_seq_to_type_fam B y}</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk13f"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fib_seq_to_type_fam B (inj A <span class="mi">0</span> a1)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (inj (fib_seq_to_seq B (<span class="mi">0</span>;a1)) <span class="mi">0</span> idpath).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk140"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr {y : Colimit A &amp; fib_seq_to_type_fam B y}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk141"><span class="highlight">srefine (contr_equiv _ (seq_colim_sum_to_sum_seq_colim B)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (Colimit (sig_seq B))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply contr_colim_contr_seq; <span class="nb">intro</span> k; srapply contr_basedpaths.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk142"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fib_seq_to_type_fam B (inj A <span class="mi">0</span> a2) &lt;~&gt;
Colimit (path_seq A a1 a2)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk143"><span class="highlight">srapply equiv_functor_colimit; srefine (<span class="nb">transitivity</span> (equiv_fib_seq_to_seq B (<span class="mi">0</span>;a2)) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) ~d~ path_seq A a1 a2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk144"><span class="highlight">srapply Build_diagram_equiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">DiagramMap (fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2))
  (path_seq A a1 a2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk145" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk145"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph, IsEquiv (<span class="nl">?m</span> i)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk146"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">DiagramMap (fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2))
  (path_seq A a1 a2)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk147" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk147"><span class="highlight">srapply Build_DiagramMap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) i -&gt; path_seq A a1 a2 i</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk148" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk148"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) i),
((path_seq A a1 a2) _f g) (<span class="nl">?DiagramMap_obj</span> i x) =
<span class="nl">?DiagramMap_obj</span> j
  (((fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2)) _f g) x)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk149"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) i -&gt; path_seq A a1 a2 i</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">n</span> =&gt; coe (ap B (seq_shift_pair_from_zero a2 n))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14a"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j)
(<span class="nv">x</span> : fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) i),
((path_seq A a1 a2) _f g)
  ((<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
    coe (ap B (seq_shift_pair_from_zero a2 n))) i x) =
(<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
 coe (ap B (seq_shift_pair_from_zero a2 n))) j
  (((fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2)) _f g) x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> n m p b; <span class="nb">destruct</span> p; srapply (K _ _ (seq_shift_pair_from_zero a2 n)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14b"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">{|
  fibSequence :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt; (a1) ^+ (x.<span class="mi">1</span>) = x.<span class="mi">2</span>;
  fibSequenceArr :=
    <span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; A x} =&gt;
    ap (<span class="kr">fun</span> <span class="nv">a</span> : A x.<span class="mi">1</span> =&gt; (a) ^+)
|}</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FibSequence A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">i</span> : Graph.graph0 sequence_graph,
IsEquiv
  ({|
     DiagramMap_obj :=
       <span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
       coe (ap B (seq_shift_pair_from_zero a2 n));
     DiagramMap_comm :=
       <span class="kr">fun</span> (<span class="nv">n</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n m)
         (<span class="nv">b</span> : fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2) n) =&gt;
       <span class="kr">match</span>
         p <span class="kr">as</span> p0 <span class="kr">in</span> (_ = y)
         <span class="kr">return</span>
           (((path_seq A a1 a2) _f p0)
              (coe
                 (ap B (seq_shift_pair_from_zero a2 n))
                 b) =
            coe (ap B (seq_shift_pair_from_zero a2 y))
              (((fib_seq_to_seq&#39; B (<span class="mi">0</span>; a2)) _f p0) b))
       <span class="kr">with</span>
       | <span class="mi">1</span> =&gt;
           K seq_pair_shift (fibSequenceArr B)
             (seq_shift_pair_from_zero a2 n)
       <span class="kr">end</span>
   |} i)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> n; srapply isequiv_path.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The characterization of path spaces in sequential colimits; Theorem 7.4, second part. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14c"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_path_colim</span> `{Univalence} {A : Sequence} n (a1 a2 : A n) :
  (inj A n a1 = inj A n a2) &lt;~&gt; Colimit (path_seq (shift_seq A n) a1 a2).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj A n a1 = inj A n a2 &lt;~&gt;
Colimit (path_seq (shift_seq A n) a1 a2)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj A n a1 = inj A n a2 &lt;~&gt;
Colimit (path_seq (shift_seq A n) a1 a2)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14e"><span class="highlight">srefine (<span class="nb">transitivity</span> _ (equiv_path_colim_zero _ _)); <span class="nb">symmetry</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj (shift_seq A n) <span class="mi">0</span> a1 = inj (shift_seq A n) <span class="mi">0</span> a2 &lt;~&gt;
inj A n a1 = inj A n a2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply (@equiv_ap _ _ (colim_shift_seq_to_colim_seq A n)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Open Scope</span> trunc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Corollary 7.7.1, second part. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk14f"><span class="highlight"><span class="kn">Instance</span> <span class="nf">trunc_seq_colim</span> `{Univalence} {A : Sequence} k :
  (<span class="kr">forall</span> <span class="nv">n</span>, IsTrunc k (A n)) -&gt; IsTrunc k (Colimit A) | <span class="mi">100</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k (A n)) -&gt; IsTrunc k (Colimit A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk150"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k (A n)) -&gt; IsTrunc k (Colimit A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk151"><span class="highlight"><span class="nb">revert</span> A; <span class="nb">induction</span> k <span class="kr">as</span> [ | k IHk].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, Contr (A n)) -&gt;
Contr (Colimit A)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk152" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk152"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt; IsTrunc k.+<span class="mi">1</span> (Colimit A)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk153"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, Contr (A n)) -&gt;
Contr (Colimit A)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply contr_colim_contr_seq.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk154"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt; IsTrunc k.+<span class="mi">1</span> (Colimit A)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk155"><span class="highlight"><span class="nb">intros</span> A trH; srapply Colimit_ind.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph) (<span class="nv">x</span> : A i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : Colimit A,
 (<span class="kr">fix</span> IsTrunc_internal
    (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
    <span class="kr">match</span> n <span class="kr">with</span>
    | -<span class="mi">2</span> =&gt; Contr_internal A
    | n&#39;.+<span class="mi">1</span> =&gt;
        <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A,
        IsTrunc_internal n&#39; (x0 = y0)
    <span class="kr">end</span>) k (w = y)) (inj A i x)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk156" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk156"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : Colimit A,
   (<span class="kr">fix</span> IsTrunc_internal
      (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} :
        <span class="kt">Type</span> :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | -<span class="mi">2</span> =&gt; Contr_internal A
      | n&#39;.+<span class="mi">1</span> =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A,
          IsTrunc_internal n&#39; (x0 = y0)
      <span class="kr">end</span>) k (w = y)) (colimp i j g x)
  (<span class="nl">?q</span> j ((A _f g) x)) = <span class="nl">?q</span> i x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk157"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph) (<span class="nv">x</span> : A i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
 <span class="kr">forall</span> <span class="nv">y</span> : Colimit A,
 (<span class="kr">fix</span> IsTrunc_internal
    (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
    <span class="kr">match</span> n <span class="kr">with</span>
    | -<span class="mi">2</span> =&gt; Contr_internal A
    | n&#39;.+<span class="mi">1</span> =&gt;
        <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A,
        IsTrunc_internal n&#39; (x0 = y0)
    <span class="kr">end</span>) k (w = y)) (inj A i x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk158"><span class="highlight"><span class="nb">intro</span> n; <span class="nb">revert</span> trH; <span class="nb">revert</span> A; <span class="nb">induction</span> n <span class="kr">as</span> [ | n IHn].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A <span class="mi">0</span>%nat) (<span class="nv">y</span> : Colimit A),
(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A0
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A0,
       IsTrunc_internal n&#39; (x0 = y0)
   <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat x = y)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk159" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A n) (<span class="nv">y</span> : Colimit A),
(<span class="kr">fix</span> IsTrunc_internal (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
<span class="kr">match</span> n <span class="kr">with</span>
| -<span class="mi">2</span> =&gt; Contr_internal A0
| n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A0, IsTrunc_internal n&#39; (x0 = y0)
<span class="kr">end</span>) k (inj A n x = y)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk159"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A (n.+<span class="mi">1</span>)%nat) (<span class="nv">y</span> : Colimit A),
(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A0
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A0,
       IsTrunc_internal n&#39; (x0 = y0)
   <span class="kr">end</span>) k (inj A (n.+<span class="mi">1</span>)%nat x = y)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk15a"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A <span class="mi">0</span>%nat) (<span class="nv">y</span> : Colimit A),
(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A0
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A0,
       IsTrunc_internal n&#39; (x0 = y0)
   <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat x = y)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk15b"><span class="highlight"><span class="nb">intros</span> A trH a; srapply Colimit_ind.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span>%nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph) (<span class="nv">x</span> : A i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
 (<span class="kr">fix</span> IsTrunc_internal
    (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
    <span class="kr">match</span> n <span class="kr">with</span>
    | -<span class="mi">2</span> =&gt; Contr_internal A
    | n&#39;.+<span class="mi">1</span> =&gt;
        <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A, IsTrunc_internal n&#39; (x0 = y)
    <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = w)) (inj A i x)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk15c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span>%nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk15c"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
   (<span class="kr">fix</span> IsTrunc_internal
      (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} :
        <span class="kt">Type</span> :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | -<span class="mi">2</span> =&gt; Contr_internal A
      | n&#39;.+<span class="mi">1</span> =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
          IsTrunc_internal n&#39; (x0 = y)
      <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = w)) (colimp i j g x)
  (<span class="nl">?q</span> j ((A _f g) x)) = <span class="nl">?q</span> i x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk15d"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span>%nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : Graph.graph0 sequence_graph) (<span class="nv">x</span> : A i),
(<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
 (<span class="kr">fix</span> IsTrunc_internal
    (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
    <span class="kr">match</span> n <span class="kr">with</span>
    | -<span class="mi">2</span> =&gt; Contr_internal A
    | n&#39;.+<span class="mi">1</span> =&gt;
        <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A, IsTrunc_internal n&#39; (x0 = y)
    <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = w)) (inj A i x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk15e"><span class="highlight"><span class="nb">intros</span> m b; <span class="nb">revert</span> b; <span class="nb">revert</span> a; <span class="nb">revert</span> trH; <span class="nb">revert</span> A; <span class="nb">induction</span> m <span class="kr">as</span> [ | m IHm].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A <span class="mi">0</span>%nat,
(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A0
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
   <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A <span class="mi">0</span>%nat b)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="sequential-v-chk15f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m),
(<span class="kr">fix</span> IsTrunc_internal (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
<span class="kr">match</span> n <span class="kr">with</span>
| -<span class="mi">2</span> =&gt; Contr_internal A0
| n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
<span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="sequential-v-chk15f"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A (m.+<span class="mi">1</span>)%nat),
(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A0
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
   <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A (m.+<span class="mi">1</span>)%nat b)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk160"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A <span class="mi">0</span>%nat,
(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A0
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
   <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A <span class="mi">0</span>%nat b)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk161"><span class="highlight"><span class="nb">intros</span> A trH a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span>%nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc_internal n&#39; (x = y)
   <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A <span class="mi">0</span>%nat b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srefine (istrunc_equiv_istrunc _ (equiv_inverse (equiv_path_colim _ a b))).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk162"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m),
(<span class="kr">fix</span> IsTrunc_internal (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
<span class="kr">match</span> n <span class="kr">with</span>
| -<span class="mi">2</span> =&gt; Contr_internal A0
| n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
<span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A (m.+<span class="mi">1</span>)%nat),
(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A0
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
   <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A (m.+<span class="mi">1</span>)%nat b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">          </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk163"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m),
(<span class="kr">fix</span> IsTrunc_internal (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
<span class="kr">match</span> n <span class="kr">with</span>
| -<span class="mi">2</span> =&gt; Contr_internal A0
| n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
<span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A (m.+<span class="mi">1</span>)%nat),
(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A0
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
   <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A (m.+<span class="mi">1</span>)%nat b)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk164"><span class="highlight"><span class="nb">intros</span> A trH a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m),
(<span class="kr">fix</span> IsTrunc_internal (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
<span class="kr">match</span> n <span class="kr">with</span>
| -<span class="mi">2</span> =&gt; Contr_internal A0
| n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
<span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span>%nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A (m.+<span class="mi">1</span>)%nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc_internal n&#39; (x = y)
   <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A (m.+<span class="mi">1</span>)%nat b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk165"><span class="highlight">srefine (istrunc_equiv_istrunc _ (equiv_inverse (equiv_concat_l (glue A _ a) _))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m),
(<span class="kr">fix</span> IsTrunc_internal (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
<span class="kr">match</span> n <span class="kr">with</span>
| -<span class="mi">2</span> =&gt; Contr_internal A0
| n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
<span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span>%nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A (m.+<span class="mi">1</span>)%nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc k (inj A <span class="mi">1</span>%nat (a) ^+ = inj A (m.+<span class="mi">1</span>)%nat b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk166"><span class="highlight">srapply (@istrunc_equiv_istrunc _ _ _ k (IHm (succ_seq A) _ (@arr _ A <span class="mi">0</span>%nat _ <span class="mi">1</span>%path a) b)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b</span> : A m),
(<span class="kr">fix</span> IsTrunc_internal (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
<span class="kr">match</span> n <span class="kr">with</span>
| -<span class="mi">2</span> =&gt; Contr_internal A0
| n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A0, IsTrunc_internal n&#39; (x = y)
<span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span>%nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A (m.+<span class="mi">1</span>)%nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">inj (succ_seq A) <span class="mi">0</span>%nat (a) ^+ = inj (succ_seq A) m b &lt;~&gt;
inj A <span class="mi">1</span>%nat (a) ^+ = inj A (m.+<span class="mi">1</span>)%nat b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">            </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply (equiv_ap (colim_succ_seq_to_colim_seq A)).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk167"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span>%nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
   (<span class="kr">fix</span> IsTrunc_internal
      (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} :
        <span class="kt">Type</span> :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | -<span class="mi">2</span> =&gt; Contr_internal A
      | n&#39;.+<span class="mi">1</span> =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
          IsTrunc_internal n&#39; (x0 = y)
      <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = w)) (colimp i j g x)
  ((<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph) (<span class="nv">b</span> : A m) =&gt;
    Overture.nat_rect
      (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
       <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
       (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
        IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
       <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
       (<span class="kr">fix</span> IsTrunc_internal
          (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} :
            <span class="kt">Type</span> :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | -<span class="mi">2</span> =&gt; Contr_internal A0
          | n&#39;.+<span class="mi">1</span> =&gt;
              <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
              IsTrunc_internal n&#39; (x0 = y)
          <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
      (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> <span class="nv">b0</span> : A <span class="mi">0</span>%nat)
       =&gt;
       istrunc_equiv_istrunc
         (Colimit (path_seq (shift_seq A <span class="mi">0</span>) a b0))
         (equiv_path_colim <span class="mi">0</span>%nat a b0)^-<span class="mi">1</span>)
      (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
         (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
                (<span class="kr">forall</span>
                 <span class="nv">n</span> : Graph.graph0 sequence_graph,
                 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
                <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
                (<span class="kr">fix</span> IsTrunc_internal
                   (n : trunc_index) (A0 : <span class="kt">Type</span>)
                   {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
                   <span class="kr">match</span> n <span class="kr">with</span>
                   | -<span class="mi">2</span> =&gt; Contr_internal A0
                   | n&#39;.+<span class="mi">1</span> =&gt;
                       <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
                       IsTrunc_internal n&#39; (x0 = y)
                   <span class="kr">end</span>) k
                  (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
         (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat)
         (<span class="nv">b0</span> : A (m0.+<span class="mi">1</span>)%nat) =&gt;
       istrunc_equiv_istrunc
         (inj A <span class="mi">1</span>%nat (a) ^+ = inj A (m0.+<span class="mi">1</span>)%nat b0)
         (equiv_concat_l (glue A <span class="mi">0</span>%nat a)
            (inj A (m0.+<span class="mi">1</span>)%nat b0))^-<span class="mi">1</span>) m A trH a b) j
     ((A _f g) x)) =
(<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph) (<span class="nv">b</span> : A m) =&gt;
 Overture.nat_rect
   (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
    (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
     IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
    <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
    (<span class="kr">fix</span> IsTrunc_internal
       (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} :
         <span class="kt">Type</span> :=
       <span class="kr">match</span> n <span class="kr">with</span>
       | -<span class="mi">2</span> =&gt; Contr_internal A0
       | n&#39;.+<span class="mi">1</span> =&gt;
           <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
           IsTrunc_internal n&#39; (x0 = y)
       <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
   (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> <span class="nv">b0</span> : A <span class="mi">0</span>%nat) =&gt;
    istrunc_equiv_istrunc
      (Colimit (path_seq (shift_seq A <span class="mi">0</span>) a b0))
      (equiv_path_colim <span class="mi">0</span>%nat a b0)^-<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
      (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
             (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
              IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
             <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
             (<span class="kr">fix</span> IsTrunc_internal
                (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span>
                 n} : <span class="kt">Type</span> :=
                <span class="kr">match</span> n <span class="kr">with</span>
                | -<span class="mi">2</span> =&gt; Contr_internal A0
                | n&#39;.+<span class="mi">1</span> =&gt;
                    <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
                    IsTrunc_internal n&#39; (x0 = y)
                <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
      (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat)
      (<span class="nv">b0</span> : A (m0.+<span class="mi">1</span>)%nat) =&gt;
    istrunc_equiv_istrunc
      (inj A <span class="mi">1</span>%nat (a) ^+ = inj A (m0.+<span class="mi">1</span>)%nat b0)
      (equiv_concat_l (glue A <span class="mi">0</span>%nat a)
         (inj A (m0.+<span class="mi">1</span>)%nat b0))^-<span class="mi">1</span>) m A trH a b) i x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk168" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk168"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A <span class="mi">0</span>%nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
   (<span class="kr">fix</span> IsTrunc_internal
      (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} :
        <span class="kt">Type</span> :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | -<span class="mi">2</span> =&gt; Contr_internal A
      | n&#39;.+<span class="mi">1</span> =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A,
          IsTrunc_internal n&#39; (x0 = y)
      <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = w)) (colimp i j g x)
  ((<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph) (<span class="nv">b</span> : A m) =&gt;
    Overture.nat_rect
      (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
       <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
       (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
        IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
       <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
       (<span class="kr">fix</span> IsTrunc_internal
          (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} :
            <span class="kt">Type</span> :=
          <span class="kr">match</span> n <span class="kr">with</span>
          | -<span class="mi">2</span> =&gt; Contr_internal A0
          | n&#39;.+<span class="mi">1</span> =&gt;
              <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
              IsTrunc_internal n&#39; (x0 = y)
          <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
      (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> <span class="nv">b0</span> : A <span class="mi">0</span>%nat)
       =&gt;
       istrunc_equiv_istrunc
         (Colimit (path_seq (shift_seq A <span class="mi">0</span>) a b0))
         (equiv_path_colim <span class="mi">0</span>%nat a b0)^-<span class="mi">1</span>)
      (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
         (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
                (<span class="kr">forall</span>
                 <span class="nv">n</span> : Graph.graph0 sequence_graph,
                 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
                <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
                (<span class="kr">fix</span> IsTrunc_internal
                   (n : trunc_index) (A0 : <span class="kt">Type</span>)
                   {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
                   <span class="kr">match</span> n <span class="kr">with</span>
                   | -<span class="mi">2</span> =&gt; Contr_internal A0
                   | n&#39;.+<span class="mi">1</span> =&gt;
                       <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
                       IsTrunc_internal n&#39; (x0 = y)
                   <span class="kr">end</span>) k
                  (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
         (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat)
         (<span class="nv">b0</span> : A (m0.+<span class="mi">1</span>)%nat) =&gt;
       istrunc_equiv_istrunc
         (inj A <span class="mi">1</span>%nat (a) ^+ = inj A (m0.+<span class="mi">1</span>)%nat b0)
         (equiv_concat_l (glue A <span class="mi">0</span>%nat a)
            (inj A (m0.+<span class="mi">1</span>)%nat b0))^-<span class="mi">1</span>) m A trH a b) j
     ((A _f g) x)) =
(<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph) (<span class="nv">b</span> : A m) =&gt;
 Overture.nat_rect
   (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
    (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
     IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
    <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
    (<span class="kr">fix</span> IsTrunc_internal
       (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} :
         <span class="kt">Type</span> :=
       <span class="kr">match</span> n <span class="kr">with</span>
       | -<span class="mi">2</span> =&gt; Contr_internal A0
       | n&#39;.+<span class="mi">1</span> =&gt;
           <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
           IsTrunc_internal n&#39; (x0 = y)
       <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
   (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> <span class="nv">b0</span> : A <span class="mi">0</span>%nat) =&gt;
    istrunc_equiv_istrunc
      (Colimit (path_seq (shift_seq A <span class="mi">0</span>) a b0))
      (equiv_path_colim <span class="mi">0</span>%nat a b0)^-<span class="mi">1</span>)
   (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
      (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
             (<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
              IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
             <span class="kr">forall</span> (<span class="nv">a</span> : A <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A m0),
             (<span class="kr">fix</span> IsTrunc_internal
                (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span>
                 n} : <span class="kt">Type</span> :=
                <span class="kr">match</span> n <span class="kr">with</span>
                | -<span class="mi">2</span> =&gt; Contr_internal A0
                | n&#39;.+<span class="mi">1</span> =&gt;
                    <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
                    IsTrunc_internal n&#39; (x0 = y)
                <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = inj A m0 b0))
      (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat)
      (<span class="nv">b0</span> : A (m0.+<span class="mi">1</span>)%nat) =&gt;
    istrunc_equiv_istrunc
      (inj A <span class="mi">1</span>%nat (a) ^+ = inj A (m0.+<span class="mi">1</span>)%nat b0)
      (equiv_concat_l (glue A <span class="mi">0</span>%nat a)
         (inj A (m0.+<span class="mi">1</span>)%nat b0))^-<span class="mi">1</span>) m A trH a b) i x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> n m p b; snrapply path_ishprop; snrapply ishprop_istrunc; <span class="bp">exact</span> _.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk169"><span class="highlight">*</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A n) (<span class="nv">y</span> : Colimit A),
(<span class="kr">fix</span> IsTrunc_internal (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
<span class="kr">match</span> n <span class="kr">with</span>
| -<span class="mi">2</span> =&gt; Contr_internal A0
| n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A0, IsTrunc_internal n&#39; (x0 = y0)
<span class="kr">end</span>) k (inj A n x = y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph,
 IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A (n.+<span class="mi">1</span>)%nat) (<span class="nv">y</span> : Colimit A),
(<span class="kr">fix</span> IsTrunc_internal
   (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
   <span class="kr">match</span> n <span class="kr">with</span>
   | -<span class="mi">2</span> =&gt; Contr_internal A0
   | n&#39;.+<span class="mi">1</span> =&gt;
       <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A0,
       IsTrunc_internal n&#39; (x0 = y0)
   <span class="kr">end</span>) k (inj A (n.+<span class="mi">1</span>)%nat x = y)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16a"><span class="highlight"><span class="nb">intros</span> A trH a; srapply (functor_forall_equiv_pb (colim_succ_seq_to_colim_seq A)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)) -&gt;
<span class="kr">forall</span> (<span class="nv">x</span> : A n) (<span class="nv">y</span> : Colimit A),
(<span class="kr">fix</span> IsTrunc_internal (n : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
<span class="kr">match</span> n <span class="kr">with</span>
| -<span class="mi">2</span> =&gt; Contr_internal A0
| n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A0, IsTrunc_internal n&#39; (x0 = y0)
<span class="kr">end</span>) k (inj A n x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A (n.+<span class="mi">1</span>)%nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> : Colimit (succ_seq A),
(<span class="kr">fun</span> <span class="nv">b</span> : Colimit A =&gt;
 (<span class="kr">fix</span> IsTrunc_internal
    (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} : <span class="kt">Type</span> :=
    <span class="kr">match</span> n <span class="kr">with</span>
    | -<span class="mi">2</span> =&gt; Contr_internal A
    | n&#39;.+<span class="mi">1</span> =&gt;
        <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc_internal n&#39; (x = y)
    <span class="kr">end</span>) k (inj A (n.+<span class="mi">1</span>)%nat a = b))
  (colim_succ_seq_to_colim_seq A a0)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> x; srapply (@istrunc_equiv_istrunc _ _ _ k (IHn (succ_seq A) _ a x)); srapply equiv_ap.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16b"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> <span class="nv">j</span> : Graph.graph0 sequence_graph)
(<span class="nv">g</span> : Graph.graph1 sequence_graph i j) (<span class="nv">x</span> : A i),
transport
  (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
   <span class="kr">forall</span> <span class="nv">y</span> : Colimit A,
   (<span class="kr">fix</span> IsTrunc_internal
      (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} :
        <span class="kt">Type</span> :=
      <span class="kr">match</span> n <span class="kr">with</span>
      | -<span class="mi">2</span> =&gt; Contr_internal A
      | n&#39;.+<span class="mi">1</span> =&gt;
          <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y0</span> : A,
          IsTrunc_internal n&#39; (x0 = y0)
      <span class="kr">end</span>) k (w = y)) (colimp i j g x)
  ((<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
    Overture.nat_rect
      (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
       <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
       (<span class="kr">forall</span> <span class="nv">n1</span> : Graph.graph0 sequence_graph,
        IsTrunc k.+<span class="mi">1</span> (A n1)) -&gt;
       <span class="kr">forall</span> (<span class="nv">x0</span> : A n0) (<span class="nv">y</span> : Colimit A),
       (<span class="kr">fix</span> IsTrunc_internal
          (n1 : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n1} :
            <span class="kt">Type</span> :=
          <span class="kr">match</span> n1 <span class="kr">with</span>
          | -<span class="mi">2</span> =&gt; Contr_internal A0
          | n&#39;.+<span class="mi">1</span> =&gt;
              <span class="kr">forall</span> <span class="nv">x1</span> <span class="nv">y0</span> : A0,
              IsTrunc_internal n&#39; (x1 = y0)
          <span class="kr">end</span>) k (inj A n0 x0 = y))
      (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n0</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n0)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat) =&gt;
       Colimit_ind
         (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
          (<span class="kr">fix</span> IsTrunc_internal
             (n0 : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span>
              n0} : <span class="kt">Type</span> :=
             <span class="kr">match</span> n0 <span class="kr">with</span>
             | -<span class="mi">2</span> =&gt; Contr_internal A0
             | n&#39;.+<span class="mi">1</span> =&gt;
                 <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
                 IsTrunc_internal n&#39; (x0 = y)
             <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = w))
         (<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph)
            (<span class="nv">b</span> : A m) =&gt;
          Overture.nat_rect
            (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
             <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
             (<span class="kr">forall</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph,
              IsTrunc k.+<span class="mi">1</span> (A0 n0)) -&gt;
             <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0),
             (<span class="kr">fix</span> IsTrunc_internal
                (n0 : trunc_index) (A1 : <span class="kt">Type</span>) {<span class="kr">struct</span>
                 n0} : <span class="kt">Type</span> :=
                <span class="kr">match</span> n0 <span class="kr">with</span>
                | -<span class="mi">2</span> =&gt; Contr_internal A1
                | n&#39;.+<span class="mi">1</span> =&gt;
                    <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A1,
                    IsTrunc_internal n&#39; (...)
                <span class="kr">end</span>) k
               (inj A0 <span class="mi">0</span>%nat a0 = inj A0 m0 b0))
            (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
               (<span class="nv">trH0</span> : <span class="kr">forall</span>
                       <span class="nv">n0</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n0))
               (<span class="nv">a0</span> <span class="nv">b0</span> : A0 <span class="mi">0</span>%nat) =&gt;
             istrunc_equiv_istrunc
               (Colimit
                  (path_seq (shift_seq A0 <span class="mi">0</span>) a0 b0))
               (equiv_path_colim <span class="mi">0</span>%nat a0 b0)^-<span class="mi">1</span>)
            (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
               (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                      (<span class="kr">forall</span>
                       <span class="nv">n0</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n0)) -&gt;
                      <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                      (<span class="nv">b0</span> : A0 m0),
                      (<span class="kr">fix</span> IsTrunc_internal
                         (n0 : trunc_index)
                         (A1 : <span class="kt">Type</span>) {<span class="kr">struct</span> n0} :
                           <span class="kt">Type</span> :=
                         <span class="kr">match</span> ... <span class="kr">with</span>
                         | ... =&gt; Contr_internal A1
                         | ... =&gt; <span class="kr">forall</span> ..., ...
                         <span class="kr">end</span>) k
                        (inj A0 <span class="mi">0</span>%nat a0 =
                         inj A0 m0 b0))
               (<span class="nv">A0</span> : Sequence)
               (<span class="nv">trH0</span> : <span class="kr">forall</span>
                       <span class="nv">n0</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n0))
               (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 (m0.+<span class="mi">1</span>)%nat)
             =&gt;
             istrunc_equiv_istrunc
               (inj A0 <span class="mi">1</span>%nat (a0) ^+ =
                inj A0 (m0.+<span class="mi">1</span>)%nat b0)
               (equiv_concat_l (glue A0 <span class="mi">0</span>%nat a0)
                  (inj A0 (m0.+<span class="mi">1</span>)%nat b0))^-<span class="mi">1</span>) m A trH
            a b)
         (<span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
            (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
            (<span class="nv">b</span> : A n0) =&gt;
          path_ishprop
            (transport
               (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
                (<span class="kr">fix</span> IsTrunc_internal
                   (n1 : trunc_index) (A0 : <span class="kt">Type</span>)
                   {<span class="kr">struct</span> n1} : <span class="kt">Type</span> :=
                   <span class="kr">match</span> n1 <span class="kr">with</span>
                   | -<span class="mi">2</span> =&gt; Contr_internal A0
                   | n&#39;.+<span class="mi">1</span> =&gt;
                       <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
                       IsTrunc_internal n&#39; (x0 = y)
                   <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = w))
               (colimp n0 m p b)
               ((<span class="kr">fun</span>
                   (<span class="nv">m0</span> : Graph.graph0 sequence_graph)
                   (<span class="nv">b0</span> : A m0) =&gt;
                 Overture.nat_rect
                   (<span class="kr">fun</span> <span class="nv">m1</span> : nat =&gt;
                    <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                    (<span class="kr">forall</span> ..., ...) -&gt;
                    <span class="kr">forall</span> (<span class="nv">a0</span> : ...) (<span class="nv">b1</span> : ...),
                    ... k ...)
                   (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
                      (<span class="nv">trH0</span> : <span class="kr">forall</span> <span class="nv">n1</span> : ...,
                              IsTrunc k.+<span class="mi">1</span> ...)
                      (<span class="nv">a0</span> <span class="nv">b1</span> : A0 <span class="mi">0</span>%nat) =&gt;
                    istrunc_equiv_istrunc
                      (Colimit (...))
                      (equiv_path_colim <span class="mi">0</span>%nat a0 b1)^-<span class="mi">1</span>)
                   (<span class="kr">fun</span> (<span class="nv">m1</span> : nat)
                      (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                             ... -&gt; ...)
                      (<span class="nv">A0</span> : Sequence)
                      (<span class="nv">trH0</span> : <span class="kr">forall</span> <span class="nv">n1</span> : ...,
                              IsTrunc k.+<span class="mi">1</span> ...)
                      (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                      (<span class="nv">b1</span> : A0 (m1.+<span class="mi">1</span>)%nat) =&gt;
                    istrunc_equiv_istrunc
                      (inj A0 <span class="mi">1</span>%nat ... =
                       inj A0 ...%nat b1)
                      (equiv_concat_l (...) (...))^-<span class="mi">1</span>)
                   m0 A trH a b0) m ((A _f p) b)))
            (Overture.nat_rect
               (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
                <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                (<span class="kr">forall</span>
                 <span class="nv">n1</span> : Graph.graph0 sequence_graph,
                 IsTrunc k.+<span class="mi">1</span> (A0 n1)) -&gt;
                <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0),
                (<span class="kr">fix</span> IsTrunc_internal
                   (n1 : trunc_index) (A1 : <span class="kt">Type</span>)
                   {<span class="kr">struct</span> n1} : <span class="kt">Type</span> :=
                   <span class="kr">match</span> ... <span class="kr">with</span>
                   | ... =&gt; Contr_internal A1
                   | ... =&gt; <span class="kr">forall</span> ..., ...
                   <span class="kr">end</span>) k
                  (inj A0 <span class="mi">0</span>%nat a0 = inj A0 m0 b0))
               (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
                  (<span class="nv">trH0</span> : <span class="kr">forall</span>
                          <span class="nv">n1</span> : Graph.graph0
                                 sequence_graph,
                          IsTrunc k.+<span class="mi">1</span> (A0 n1))
                  (<span class="nv">a0</span> <span class="nv">b0</span> : A0 <span class="mi">0</span>%nat) =&gt;
                istrunc_equiv_istrunc
                  (Colimit
                     (path_seq (shift_seq A0 <span class="mi">0</span>) a0 b0))
                  (equiv_path_colim <span class="mi">0</span>%nat a0 b0)^-<span class="mi">1</span>)
               (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
                  (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                         (<span class="kr">forall</span>
                          <span class="nv">n1</span> : Graph.graph0
                                 sequence_graph,
                          IsTrunc k.+<span class="mi">1</span> (A0 n1)) -&gt;
                         <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                         (<span class="nv">b0</span> : A0 m0),
                         (<span class="kr">fix</span> IsTrunc_internal ... :
                              <span class="kt">Type</span> :=
                            ...
                            ...
                            ...
                            <span class="kr">end</span>) k
                           (inj A0 <span class="mi">0</span>%nat a0 =
                            inj A0 m0 b0))
                  (<span class="nv">A0</span> : Sequence)
                  (<span class="nv">trH0</span> : <span class="kr">forall</span>
                          <span class="nv">n1</span> : Graph.graph0
                                 sequence_graph,
                          IsTrunc k.+<span class="mi">1</span> (A0 n1))
                  (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                  (<span class="nv">b0</span> : A0 (m0.+<span class="mi">1</span>)%nat) =&gt;
                istrunc_equiv_istrunc
                  (inj A0 <span class="mi">1</span>%nat (a0) ^+ =
                   inj A0 (m0.+<span class="mi">1</span>)%nat b0)
                  (equiv_concat_l (glue A0 <span class="mi">0</span>%nat a0)
                     (inj A0 (m0.+<span class="mi">1</span>)%nat b0))^-<span class="mi">1</span>) n0 A
               trH a b)))
      (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
         (<span class="nv">IHn</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
                (<span class="kr">forall</span>
                 <span class="nv">n1</span> : Graph.graph0 sequence_graph,
                 IsTrunc k.+<span class="mi">1</span> (A n1)) -&gt;
                <span class="kr">forall</span> (<span class="nv">x0</span> : A n0) (<span class="nv">y</span> : Colimit A),
                (<span class="kr">fix</span> IsTrunc_internal
                   (n1 : trunc_index) (A0 : <span class="kt">Type</span>)
                   {<span class="kr">struct</span> n1} : <span class="kt">Type</span> :=
                   <span class="kr">match</span> n1 <span class="kr">with</span>
                   | -<span class="mi">2</span> =&gt; Contr_internal A0
                   | n&#39;.+<span class="mi">1</span> =&gt;
                       <span class="kr">forall</span> <span class="nv">x1</span> <span class="nv">y0</span> : A0,
                       IsTrunc_internal n&#39; (x1 = y0)
                   <span class="kr">end</span>) k (inj A n0 x0 = y))
         (<span class="nv">A</span> : Sequence)
         (<span class="nv">trH</span> : <span class="kr">forall</span>
                <span class="nv">n1</span> : Graph.graph0 sequence_graph,
                IsTrunc k.+<span class="mi">1</span> (A n1))
         (<span class="nv">a</span> : A (n0.+<span class="mi">1</span>)%nat) =&gt;
       functor_forall_equiv_pb
         (colim_succ_seq_to_colim_seq A)
         (<span class="kr">fun</span> <span class="nv">x0</span> : Colimit (succ_seq A) =&gt;
          istrunc_equiv_istrunc
            (inj (succ_seq A) n0 a = x0)
            (equiv_ap (colim_succ_seq_to_colim_seq A)
               (inj (succ_seq A) n0 a) x0))) n A trH)
     j ((A _f g) x)) =
(<span class="kr">fun</span> <span class="nv">n</span> : Graph.graph0 sequence_graph =&gt;
 Overture.nat_rect
   (<span class="kr">fun</span> <span class="nv">n0</span> : nat =&gt;
    <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
    (<span class="kr">forall</span> <span class="nv">n1</span> : Graph.graph0 sequence_graph,
     IsTrunc k.+<span class="mi">1</span> (A n1)) -&gt;
    <span class="kr">forall</span> (<span class="nv">x0</span> : A n0) (<span class="nv">y</span> : Colimit A),
    (<span class="kr">fix</span> IsTrunc_internal
       (n1 : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n1} :
         <span class="kt">Type</span> :=
       <span class="kr">match</span> n1 <span class="kr">with</span>
       | -<span class="mi">2</span> =&gt; Contr_internal A0
       | n&#39;.+<span class="mi">1</span> =&gt;
           <span class="kr">forall</span> <span class="nv">x1</span> <span class="nv">y0</span> : A0,
           IsTrunc_internal n&#39; (x1 = y0)
       <span class="kr">end</span>) k (inj A n0 x0 = y))
   (<span class="kr">fun</span> (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n0)) (<span class="nv">a</span> : A <span class="mi">0</span>%nat) =&gt;
    Colimit_ind
      (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
       (<span class="kr">fix</span> IsTrunc_internal
          (n0 : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span> n0} :
            <span class="kt">Type</span> :=
          <span class="kr">match</span> n0 <span class="kr">with</span>
          | -<span class="mi">2</span> =&gt; Contr_internal A0
          | n&#39;.+<span class="mi">1</span> =&gt;
              <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
              IsTrunc_internal n&#39; (x0 = y)
          <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = w))
      (<span class="kr">fun</span> (<span class="nv">m</span> : Graph.graph0 sequence_graph) (<span class="nv">b</span> : A m)
       =&gt;
       Overture.nat_rect
         (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
          <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
          (<span class="kr">forall</span> <span class="nv">n0</span> : Graph.graph0 sequence_graph,
           IsTrunc k.+<span class="mi">1</span> (A0 n0)) -&gt;
          <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0),
          (<span class="kr">fix</span> IsTrunc_internal
             (n0 : trunc_index) (A1 : <span class="kt">Type</span>) {<span class="kr">struct</span>
              n0} : <span class="kt">Type</span> :=
             <span class="kr">match</span> n0 <span class="kr">with</span>
             | -<span class="mi">2</span> =&gt; Contr_internal A1
             | n&#39;.+<span class="mi">1</span> =&gt;
                 <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A1,
                 IsTrunc_internal n&#39; (x0 = y)
             <span class="kr">end</span>) k (inj A0 <span class="mi">0</span>%nat a0 = inj A0 m0 b0))
         (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
            (<span class="nv">trH0</span> : <span class="kr">forall</span>
                    <span class="nv">n0</span> : Graph.graph0 sequence_graph,
                    IsTrunc k.+<span class="mi">1</span> (A0 n0))
            (<span class="nv">a0</span> <span class="nv">b0</span> : A0 <span class="mi">0</span>%nat) =&gt;
          istrunc_equiv_istrunc
            (Colimit (path_seq (shift_seq A0 <span class="mi">0</span>) a0 b0))
            (equiv_path_colim <span class="mi">0</span>%nat a0 b0)^-<span class="mi">1</span>)
         (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
            (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                   (<span class="kr">forall</span>
                    <span class="nv">n0</span> : Graph.graph0 sequence_graph,
                    IsTrunc k.+<span class="mi">1</span> (A0 n0)) -&gt;
                   <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                   (<span class="nv">b0</span> : A0 m0),
                   (<span class="kr">fix</span> IsTrunc_internal
                      (n0 : trunc_index) (A1 : <span class="kt">Type</span>)
                      {<span class="kr">struct</span> n0} : <span class="kt">Type</span> :=
                      <span class="kr">match</span> n0 <span class="kr">with</span>
                      | -<span class="mi">2</span> =&gt; Contr_internal A1
                      | n&#39;.+<span class="mi">1</span> =&gt;
                          <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A1,
                          IsTrunc_internal n&#39; (...)
                      <span class="kr">end</span>) k
                     (inj A0 <span class="mi">0</span>%nat a0 = inj A0 m0 b0))
            (<span class="nv">A0</span> : Sequence)
            (<span class="nv">trH0</span> : <span class="kr">forall</span>
                    <span class="nv">n0</span> : Graph.graph0 sequence_graph,
                    IsTrunc k.+<span class="mi">1</span> (A0 n0))
            (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 (m0.+<span class="mi">1</span>)%nat) =&gt;
          istrunc_equiv_istrunc
            (inj A0 <span class="mi">1</span>%nat (a0) ^+ =
             inj A0 (m0.+<span class="mi">1</span>)%nat b0)
            (equiv_concat_l (glue A0 <span class="mi">0</span>%nat a0)
               (inj A0 (m0.+<span class="mi">1</span>)%nat b0))^-<span class="mi">1</span>) m A trH a
         b)
      (<span class="kr">fun</span> (<span class="nv">n0</span> <span class="nv">m</span> : Graph.graph0 sequence_graph)
         (<span class="nv">p</span> : Graph.graph1 sequence_graph n0 m)
         (<span class="nv">b</span> : A n0) =&gt;
       path_ishprop
         (transport
            (<span class="kr">fun</span> <span class="nv">w</span> : Colimit A =&gt;
             (<span class="kr">fix</span> IsTrunc_internal
                (n1 : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span>
                 n1} : <span class="kt">Type</span> :=
                <span class="kr">match</span> n1 <span class="kr">with</span>
                | -<span class="mi">2</span> =&gt; Contr_internal A0
                | n&#39;.+<span class="mi">1</span> =&gt;
                    <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A0,
                    IsTrunc_internal n&#39; (x0 = y)
                <span class="kr">end</span>) k (inj A <span class="mi">0</span>%nat a = w))
            (colimp n0 m p b)
            ((<span class="kr">fun</span> (<span class="nv">m0</span> : Graph.graph0 sequence_graph)
                (<span class="nv">b0</span> : A m0) =&gt;
              Overture.nat_rect
                (<span class="kr">fun</span> <span class="nv">m1</span> : nat =&gt;
                 <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                 (<span class="kr">forall</span>
                  <span class="nv">n1</span> : Graph.graph0 sequence_graph,
                  IsTrunc k.+<span class="mi">1</span> (...)) -&gt;
                 <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b1</span> : A0 m1),
                 (... ...) k (... = ...))
                (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
                   (<span class="nv">trH0</span> : <span class="kr">forall</span>
                           <span class="nv">n1</span> : Graph.graph0
                                  sequence_graph,
                           IsTrunc k.+<span class="mi">1</span> (A0 n1))
                   (<span class="nv">a0</span> <span class="nv">b1</span> : A0 <span class="mi">0</span>%nat) =&gt;
                 istrunc_equiv_istrunc
                   (Colimit (path_seq (...) a0 b1))
                   (equiv_path_colim <span class="mi">0</span>%nat a0 b1)^-<span class="mi">1</span>)
                (<span class="kr">fun</span> (<span class="nv">m1</span> : nat)
                   (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                          (<span class="kr">forall</span> ..., ...) -&gt;
                          <span class="kr">forall</span> (<span class="nv">a0</span> : ...)
                          (<span class="nv">b1</span> : ...), ... k ...)
                   (<span class="nv">A0</span> : Sequence)
                   (<span class="nv">trH0</span> : <span class="kr">forall</span>
                           <span class="nv">n1</span> : Graph.graph0
                                  sequence_graph,
                           IsTrunc k.+<span class="mi">1</span> (A0 n1))
                   (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                   (<span class="nv">b1</span> : A0 (m1.+<span class="mi">1</span>)%nat) =&gt;
                 istrunc_equiv_istrunc
                   (inj A0 <span class="mi">1</span>%nat (a0) ^+ =
                    inj A0 (m1.+<span class="mi">1</span>)%nat b1)
                   (equiv_concat_l (glue A0 <span class="mi">0</span>%nat a0)
                      (inj A0 (m1.+<span class="mi">1</span>)%nat b1))^-<span class="mi">1</span>) m0
                A trH a b0) m ((A _f p) b)))
         (Overture.nat_rect
            (<span class="kr">fun</span> <span class="nv">m0</span> : nat =&gt;
             <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
             (<span class="kr">forall</span> <span class="nv">n1</span> : Graph.graph0 sequence_graph,
              IsTrunc k.+<span class="mi">1</span> (A0 n1)) -&gt;
             <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 m0),
             (<span class="kr">fix</span> IsTrunc_internal
                (n1 : trunc_index) (A1 : <span class="kt">Type</span>) {<span class="kr">struct</span>
                 n1} : <span class="kt">Type</span> :=
                <span class="kr">match</span> n1 <span class="kr">with</span>
                | -<span class="mi">2</span> =&gt; Contr_internal A1
                | n&#39;.+<span class="mi">1</span> =&gt;
                    <span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : A1,
                    IsTrunc_internal n&#39; (...)
                <span class="kr">end</span>) k
               (inj A0 <span class="mi">0</span>%nat a0 = inj A0 m0 b0))
            (<span class="kr">fun</span> (<span class="nv">A0</span> : Sequence)
               (<span class="nv">trH0</span> : <span class="kr">forall</span>
                       <span class="nv">n1</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n1))
               (<span class="nv">a0</span> <span class="nv">b0</span> : A0 <span class="mi">0</span>%nat) =&gt;
             istrunc_equiv_istrunc
               (Colimit
                  (path_seq (shift_seq A0 <span class="mi">0</span>) a0 b0))
               (equiv_path_colim <span class="mi">0</span>%nat a0 b0)^-<span class="mi">1</span>)
            (<span class="kr">fun</span> (<span class="nv">m0</span> : nat)
               (<span class="nv">IHm</span> : <span class="kr">forall</span> <span class="nv">A0</span> : Sequence,
                      (<span class="kr">forall</span>
                       <span class="nv">n1</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n1)) -&gt;
                      <span class="kr">forall</span> (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat)
                      (<span class="nv">b0</span> : A0 m0),
                      (<span class="kr">fix</span> IsTrunc_internal
                         (n1 : trunc_index)
                         (A1 : <span class="kt">Type</span>) {<span class="kr">struct</span> n1} :
                           <span class="kt">Type</span> :=
                         <span class="kr">match</span> ... <span class="kr">with</span>
                         | ... =&gt; Contr_internal A1
                         | ... =&gt; <span class="kr">forall</span> ..., ...
                         <span class="kr">end</span>) k
                        (inj A0 <span class="mi">0</span>%nat a0 =
                         inj A0 m0 b0))
               (<span class="nv">A0</span> : Sequence)
               (<span class="nv">trH0</span> : <span class="kr">forall</span>
                       <span class="nv">n1</span> : Graph.graph0
                              sequence_graph,
                       IsTrunc k.+<span class="mi">1</span> (A0 n1))
               (<span class="nv">a0</span> : A0 <span class="mi">0</span>%nat) (<span class="nv">b0</span> : A0 (m0.+<span class="mi">1</span>)%nat)
             =&gt;
             istrunc_equiv_istrunc
               (inj A0 <span class="mi">1</span>%nat (a0) ^+ =
                inj A0 (m0.+<span class="mi">1</span>)%nat b0)
               (equiv_concat_l (glue A0 <span class="mi">0</span>%nat a0)
                  (inj A0 (m0.+<span class="mi">1</span>)%nat b0))^-<span class="mi">1</span>) n0 A
            trH a b)))
   (<span class="kr">fun</span> (<span class="nv">n0</span> : nat)
      (<span class="nv">IHn</span> : <span class="kr">forall</span> <span class="nv">A</span> : Sequence,
             (<span class="kr">forall</span> <span class="nv">n1</span> : Graph.graph0 sequence_graph,
              IsTrunc k.+<span class="mi">1</span> (A n1)) -&gt;
             <span class="kr">forall</span> (<span class="nv">x0</span> : A n0) (<span class="nv">y</span> : Colimit A),
             (<span class="kr">fix</span> IsTrunc_internal
                (n1 : trunc_index) (A0 : <span class="kt">Type</span>) {<span class="kr">struct</span>
                 n1} : <span class="kt">Type</span> :=
                <span class="kr">match</span> n1 <span class="kr">with</span>
                | -<span class="mi">2</span> =&gt; Contr_internal A0
                | n&#39;.+<span class="mi">1</span> =&gt;
                    <span class="kr">forall</span> <span class="nv">x1</span> <span class="nv">y0</span> : A0,
                    IsTrunc_internal n&#39; (x1 = y0)
                <span class="kr">end</span>) k (inj A n0 x0 = y))
      (<span class="nv">A</span> : Sequence)
      (<span class="nv">trH</span> : <span class="kr">forall</span> <span class="nv">n1</span> : Graph.graph0 sequence_graph,
             IsTrunc k.+<span class="mi">1</span> (A n1)) (<span class="nv">a</span> : A (n0.+<span class="mi">1</span>)%nat)
    =&gt;
    functor_forall_equiv_pb
      (colim_succ_seq_to_colim_seq A)
      (<span class="kr">fun</span> <span class="nv">x0</span> : Colimit (succ_seq A) =&gt;
       istrunc_equiv_istrunc
         (inj (succ_seq A) n0 a = x0)
         (equiv_ap (colim_succ_seq_to_colim_seq A)
            (inj (succ_seq A) n0 a) x0))) n A trH) i x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="sequential-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="sequential-v-chk16c"><span class="highlight"><span class="nb">intros</span> n m p a; snrapply path_ishprop; snrapply istrunc_forall.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHk</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : Sequence,
(<span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k (A n)) -&gt;
IsTrunc k (Colimit A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Sequence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">trH</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">n</span> : Graph.graph0 sequence_graph, IsTrunc k.+<span class="mi">1</span> (A n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph0 sequence_graph</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Graph.graph1 sequence_graph n m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a0</span> : Colimit A,
IsHProp
  ((<span class="kr">fun</span> <span class="nv">a1</span> : Colimit A =&gt;
    (<span class="kr">fix</span> IsTrunc_internal
       (n : trunc_index) (A : <span class="kt">Type</span>) {<span class="kr">struct</span> n} :
         <span class="kt">Type</span> :=
       <span class="kr">match</span> n <span class="kr">with</span>
       | -<span class="mi">2</span> =&gt; Contr_internal A
       | n&#39;.+<span class="mi">1</span> =&gt;
           <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc_internal n&#39; (x = y)
       <span class="kr">end</span>) k (inj A n a = a1)) a0)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> x; srapply ishprop_istrunc.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span></span></pre>
</div>
</div></body>
</html>
