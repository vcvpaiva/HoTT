<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>canonical_names.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Export</span>
  HoTT.Basics
  HoTT.Types
  HoTT.Truncations
  HoTT.Basics.Utf8.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Declare Scope</span> mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Delimit Scope</span> mc_scope <span class="kr">with</span> mc.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Open Scope</span> mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Generalizable Variables</span> <span class="nf">A</span> B f g x y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Monomorphic</span> <span class="kn">Universe</span> <span class="nf">Ularge</span> Uhuge.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Monomorphic</span> <span class="kn">Constraint</span> <span class="nf">Ularge</span> &lt; Uhuge.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">merely_destruct</span> {<span class="nv">A</span>} {<span class="nv">P</span> : <span class="kt">Type</span>} {<span class="nv">sP</span> : IsHProp P}
  (<span class="nv">x</span> : merely A) : (A -&gt; P) -&gt; P.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHProp P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">merely A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(A -&gt; P) -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHProp P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">merely A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(A -&gt; P) -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk2"><span class="highlight"><span class="nb">intros</span> E;<span class="nb">revert</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHProp P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">merely A -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk3"><span class="highlight"><span class="nb">apply</span> Trunc_ind.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHProp P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Trunc (-<span class="mi">1</span>) A -&gt; IsHProp P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="canonical-names-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHProp P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; P</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="canonical-names-v-chk4"><hr></label><div class="goal-conclusion"><span class="highlight">A -&gt; P</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk5"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHProp P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Trunc (-<span class="mi">1</span>) A -&gt; IsHProp P</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk6"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sP</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHProp P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> E.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot; g ‚àò f &quot;</span> := (Compose g f)%mc.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚àò)&quot;</span> := Compose (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">id</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">a</span> : A) := a.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(=)&quot;</span> := paths (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x =)&quot;</span> := (paths x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(= x )&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; paths y x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(&lt;&gt;)&quot;</span> := (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; ~x = y) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x &lt;&gt;)&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; x &lt;&gt; y) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(&lt;&gt; x )&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y &lt;&gt; x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Apart</span> <span class="nv">A</span> := apart : Relation A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;‚â∂&quot;</span> := apart : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚â∂)&quot;</span> := apart (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x ‚â∂)&quot;</span> := (apart x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚â∂ x )&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; apart y x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Even for setoids with decidable equality x &lt;&gt; y does not imply x ‚â∂ y.</span>
<span class="c">Therefore we introduce the following class. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">TrivialApart</span> <span class="nv">A</span> {<span class="nv">Aap</span> : Apart A} :=
  { trivial_apart_prop :&gt; is_mere_relation A apart
  ; trivial_apart : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x ‚â∂ y &lt;-&gt; x &lt;&gt; y }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">sig_apart</span> `{Apart A} (P: A -&gt; <span class="kt">Type</span>) : Apart (sig P) := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; x.<span class="mi">1</span> ‚â∂ y.<span class="mi">1</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">10</span> (Apart (sig _)) =&gt; <span class="nb">apply</span> @sig_apart : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Cast</span> <span class="nv">A</span> <span class="nv">B</span> := cast: A -&gt; B.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> cast _ _ {Cast} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39; x&quot;</span> := (cast _ _ x) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Typeclasses Transparent</span> Cast.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Other canonically named relations/operations/constants: *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">SgOp</span> <span class="nv">A</span> := sg_op: A -&gt; A -&gt; A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">MonUnit</span> <span class="nv">A</span> := mon_unit: A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Plus</span> <span class="nv">A</span> := plus: A -&gt; A -&gt; A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Mult</span> <span class="nv">A</span> := mult: A -&gt; A -&gt; A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">One</span> <span class="nv">A</span> := one: A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Zero</span> <span class="nv">A</span> := zero: A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Negate</span> <span class="nv">A</span> := negate: A -&gt; A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">DecRecip</span> <span class="nv">A</span> := dec_recip: A -&gt; A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ApartZero</span> <span class="nv">R</span> `{Zero R} `{Apart R} := sig (‚â∂ zero).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Recip</span> <span class="nv">A</span> `{Apart A} `{Zero A} := recip: ApartZero A -&gt; A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Typeclasses Transparent</span> SgOp MonUnit Plus Mult Zero One Negate.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Meet</span> <span class="nv">A</span> := meet: A -&gt; A -&gt; A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Join</span> <span class="nv">A</span> := join: A -&gt; A -&gt; A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Top</span> <span class="nv">A</span> := top: A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Bottom</span> <span class="nv">A</span> := bottom: A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Typeclasses Transparent</span> Meet Join Top Bottom.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Le</span> <span class="nv">A</span> := le: Relation A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Lt</span> <span class="nv">A</span> := lt: Relation A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Typeclasses Transparent</span> Le Lt.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">NonNeg</span> <span class="nv">R</span> `{Zero R} `{Le R} := sig (le zero).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Pos</span> <span class="nv">R</span> `{Zero R} `{Lt R} := sig (lt zero).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">NonPos</span> <span class="nv">R</span> `{Zero R} `{Le R} := sig (<span class="kr">fun</span> <span class="nv">y</span> =&gt; le y zero).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">plus_is_sg_op</span> `{f : Plus A} : SgOp A := f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">mult_is_sg_op</span> `{f : Mult A} : SgOp A := f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">one_is_mon_unit</span> `{c : One A} : MonUnit A := c.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">zero_is_mon_unit</span> `{c : Zero A} : MonUnit A := c.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">meet_is_sg_op</span> `{f : Meet A} : SgOp A := f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">join_is_sg_op</span> `{f : Join A} : SgOp A := f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">top_is_mon_unit</span> `{s : Top A} : MonUnit A := s.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">bottom_is_mon_unit</span> `{s : Bottom A} : MonUnit A := s.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (Apart (ApartZero _)) =&gt; <span class="nb">apply</span> @sig_apart : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (Apart (NonNeg _)) =&gt; <span class="nb">apply</span> @sig_apart : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (Apart (Pos _)) =&gt; <span class="nb">apply</span> @sig_apart : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Notations: *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Declare Scope</span> mc_add_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;+&quot;</span> := sg_op : mc_add_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(+)&quot;</span> := sg_op (<span class="kn">only parsing</span>) : mc_add_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x +)&quot;</span> := (sg_op x) (<span class="kn">only parsing</span>) : mc_add_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(+ x )&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y + x) (<span class="kn">only parsing</span>) : mc_add_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Declare Scope</span> mc_mult_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;*&quot;</span> := sg_op : mc_mult_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x *.)&quot;</span> := (sg_op x) (<span class="kn">only parsing</span>) : mc_mult_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(.*.)&quot;</span> := sg_op (<span class="kn">only parsing</span>) : mc_mult_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(.* x )&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y * x) (<span class="kn">only parsing</span>) : mc_mult_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;+&quot;</span> := plus : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(+)&quot;</span> := plus (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x +)&quot;</span> := (plus x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(+ x )&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y + x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;*&quot;</span> := mult : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight"><span class="c">(* We don&#39;t add &quot;( * )&quot;, &quot;( * x )&quot; and &quot;( x * )&quot; notations</span>
<span class="c">   because they conflict with comments. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x *.)&quot;</span> := (mult x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(.*.)&quot;</span> := mult (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(.* x )&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y * x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;- x&quot;</span> := (negate x) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(-)&quot;</span> := negate (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x - y&quot;</span> := (x + -y) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;0&quot;</span> := zero : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;1&quot;</span> := one : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;2&quot;</span> := (<span class="mi">1</span> + <span class="mi">1</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;3&quot;</span> := (<span class="mi">1</span> + (<span class="mi">1</span> + <span class="mi">1</span>)) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;4&quot;</span> := (<span class="mi">1</span> + (<span class="mi">1</span> + (<span class="mi">1</span> + <span class="mi">1</span>))) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;5&quot;</span> := (<span class="mi">1</span> + (<span class="mi">1</span> + (<span class="mi">1</span> + (<span class="mi">1</span> + <span class="mi">1</span>)))) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;6&quot;</span> := (<span class="mi">1</span> + (<span class="mi">1</span> + (<span class="mi">1</span> + (<span class="mi">1</span> + (<span class="mi">1</span> + <span class="mi">1</span>))))) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;- 1&quot;</span> := (-(<span class="mi">1</span>)) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;- 2&quot;</span> := (-(<span class="mi">2</span>)) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;- 3&quot;</span> := (-(<span class="mi">3</span>)) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;- 4&quot;</span> := (-(<span class="mi">4</span>)) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;/ x&quot;</span> := (dec_recip x) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(/)&quot;</span> := dec_recip (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x / y&quot;</span> := (x * /y) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;// x&quot;</span> := (recip x) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(//)&quot;</span> := recip (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x // y&quot;</span> := (x * //y) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;‚ä§&quot;</span> := top : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;‚ä•&quot;</span> := bottom : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;‚äì&quot;</span> := meet : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚äì)&quot;</span> := meet (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( X ‚äì)&quot;</span> := (meet X) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚äì X )&quot;</span> := (<span class="kr">fun</span> <span class="nv">Y</span> =&gt; Y ‚äì X) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;‚äî&quot;</span> := join : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚äî)&quot;</span> := join (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( X ‚äî)&quot;</span> := (join X) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚äî X )&quot;</span> := (<span class="kr">fun</span> <span class="nv">Y</span> =&gt; Y ‚äî X) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;‚â§&quot;</span> := le : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚â§)&quot;</span> := le (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x ‚â§)&quot;</span> := (le x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚â§ x )&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y ‚â§ x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;&lt;=&quot;</span> := le (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(&lt;=)&quot;</span> := le (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x &lt;=)&quot;</span> := (le x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(&lt;= x )&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y ‚â§ x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;&lt;&quot;</span> := lt : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(&lt;)&quot;</span> := lt (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x &lt;)&quot;</span> := (lt x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(&lt; x )&quot;</span> := (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y &lt; x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x ‚â§ y ‚â§ z&quot;</span> := (x ‚â§ y /\ y ‚â§ z) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x ‚â§ y &lt; z&quot;</span> := (x ‚â§ y /\ y &lt; z) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &lt; y &lt; z&quot;</span> := (x &lt; y /\ y &lt; z) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &lt; y ‚â§ z&quot;</span> := (x &lt; y /\ y ‚â§ z) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** It is likely that ‚â§ and &lt; are transitive (and ‚â§ reflexive) so inform [auto] of this. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">auto_trans</span> := <span class="kr">match goal with</span>
                    [ H: <span class="nl">?R</span> <span class="nl">?x</span> <span class="nl">?y</span>, I: <span class="nl">?R</span> <span class="nl">?y</span> <span class="nl">?z</span> |- <span class="nl">?R</span> <span class="nl">?x</span> <span class="nl">?z</span>] =&gt; <span class="nb">apply</span> (<span class="nb">transitivity</span> H I)
                  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">2</span> (<span class="nl">?x</span> ‚â§ <span class="nl">?y</span>) =&gt; <span class="bp">reflexivity</span> : core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (<span class="nl">?x</span> ‚â§ <span class="nl">?z</span>) =&gt; auto_trans : core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (<span class="nl">?x</span> &lt; <span class="nl">?z</span>) =&gt; auto_trans : core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Abs</span> <span class="nv">A</span> `{Le A} `{Zero A} `{Negate A}
  := abs_sig: <span class="kr">forall</span> (<span class="nv">x</span> : A), { y : A | (<span class="mi">0</span> ‚â§ x -&gt; y = x) /\ (x ‚â§ <span class="mi">0</span> -&gt; y = -x)}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abs</span> `{Abs A} := <span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (abs_sig x).<span class="mi">1</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Common properties: *)</span>
<span class="c">(* Class Inverse `(A -&gt; B) : Type := inverse: B -&gt; A.</span>
<span class="c">Arguments inverse {A B} _ {Inverse} _.</span>
<span class="c">Typeclasses Transparent Inverse.</span>
<span class="c">Notation &quot;f ‚Åª¬π&quot; := (inverse f) : mc_scope. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Idempotent</span> `(f: A -&gt; A -&gt; A) (x : A) : <span class="kt">Type</span> := idempotency: f x x = x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> idempotency {A} _ _ {Idempotent}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">UnaryIdempotent</span> {<span class="nv">A</span>} (<span class="nv">f</span>: A -&gt; A) : <span class="kt">Type</span> :=
  unary_idempotent :&gt; Idempotent Compose f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk7"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">unary_idempotency</span> `{UnaryIdempotent A f} x : f (f x) = f x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">UnaryIdempotent f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (f x) = f x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk8"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">UnaryIdempotent f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (f x) = f x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk9"><span class="highlight"><span class="nb">change</span> (f (f x)) <span class="kr">with</span> (Compose f f x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">UnaryIdempotent f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(f ‚àò f) x = f x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chka"><span class="highlight"><span class="nb">apply</span> (ap (<span class="kr">fun</span> <span class="nv">g</span> =&gt; g x)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">UnaryIdempotent f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f ‚àò f = f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chkb"><span class="highlight"><span class="nb">change</span> (Compose f f = f).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">UnaryIdempotent f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f ‚àò f = f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chkc"><span class="highlight"><span class="nb">apply</span> idempotency.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">UnaryIdempotent f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Idempotent Compose f</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">BinaryIdempotent</span> `(op: A -&gt; A -&gt; A) : <span class="kt">Type</span>
  := binary_idempotent :&gt; <span class="kr">forall</span> <span class="nv">x</span>, Idempotent op x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">LeftIdentity</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">op</span> : A -&gt; B -&gt; B) (<span class="nv">x</span> : A): <span class="kt">Type</span>
  := left_identity: <span class="kr">forall</span> <span class="nv">y</span>, op x y = y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">RightIdentity</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">op</span> : A -&gt; B -&gt; A) (<span class="nv">y</span> : B): <span class="kt">Type</span>
  := right_identity: <span class="kr">forall</span> <span class="nv">x</span>, op x y = x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Absorption</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">op1</span>: A -&gt; C -&gt; A) (<span class="nv">op2</span>: A -&gt; B -&gt; C) : <span class="kt">Type</span>
  := absorption: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, op1 x (op2 x y) = x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">LeftAbsorb</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">op</span> : A -&gt; B -&gt; A) (<span class="nv">x</span> : A): <span class="kt">Type</span>
  := left_absorb: <span class="kr">forall</span> <span class="nv">y</span>, op x y = x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">RightAbsorb</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">op</span> : A -&gt; B -&gt; B) (<span class="nv">y</span> : B): <span class="kt">Type</span>
  := right_absorb: <span class="kr">forall</span> <span class="nv">x</span>, op x y = y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">LeftInverse</span> {<span class="nv">A</span>} {<span class="nv">B</span>} {<span class="nv">C</span>} (<span class="nv">op</span> : A -&gt; B -&gt; C) (<span class="nv">inv</span> : B -&gt; A) (<span class="nv">unit</span> : C)
  := left_inverse: <span class="kr">forall</span> <span class="nv">x</span>, op (inv x) x = unit.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">RightInverse</span> {<span class="nv">A</span>} {<span class="nv">B</span>} {<span class="nv">C</span>} (<span class="nv">op</span> : A -&gt; B -&gt; C) (<span class="nv">inv</span> : A -&gt; B) (<span class="nv">unit</span> : C)
  := right_inverse: <span class="kr">forall</span> <span class="nv">x</span>, op x (inv x) = unit.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Commutative</span> {<span class="nv">B</span> <span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; A -&gt; B) : <span class="kt">Type</span>
  := commutativity: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f x y = f y x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global</span> <span class="kn">Hint Unfold</span> Commutative : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">HeteroAssociative</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">AB</span> <span class="nv">BC</span> <span class="nv">ABC</span>}
  (<span class="nv">fA_BC</span>: A -&gt; BC -&gt; ABC) (<span class="nv">fBC</span>: B -&gt; C -&gt; BC)
  (<span class="nv">fAB_C</span>: AB -&gt; C -&gt; ABC) (<span class="nv">fAB</span> : A -&gt; B -&gt; AB): <span class="kt">Type</span>
  := associativity : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, fA_BC x (fBC y z) = fAB_C (fAB x y) z.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Associative</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; A -&gt; A)
  := simple_associativity :&gt; HeteroAssociative f f f f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Involutive</span> {<span class="nv">A</span>} (<span class="nv">f</span> : A -&gt; A) := involutive: <span class="kr">forall</span> <span class="nv">x</span>, f (f x) = x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">TotalRelation</span> `(R : Relation A) : <span class="kt">Type</span> := total : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y |_| R y x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> total {A} _ {TotalRelation} _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Trichotomy</span> `(R : Relation A)
  := trichotomy : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, R x y |_| x = y |_| R y x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> trichotomy {A} R {Trichotomy} _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> irreflexivity {A} _ {Irreflexive} _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">CoTransitive</span> `(R : Relation A) : <span class="kt">Type</span> := cotransitive
  : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R x y -&gt; <span class="kr">forall</span> <span class="nv">z</span>, hor (R x z) (R z y).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> cotransitive {A R CoTransitive x y} _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">AntiSymmetric</span> `(R : Relation A) : <span class="kt">Type</span>
  := antisymmetry: <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R x y -&gt; R y x -&gt; x = y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> antisymmetry {A} _ {AntiSymmetric} _ _ _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">EquivRel</span> `(R : Relation A) : <span class="kt">Type</span> := Build_EquivRel
  { EquivRel_Reflexive :&gt; Reflexive R ;
    EquivRel_Symmetric :&gt; Symmetric R ;
    EquivRel_Transitive :&gt; Transitive R }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">SigEquivRel</span> {<span class="nv">A</span>:<span class="kt">Type</span>} (<span class="nv">R</span> : Relation A) : <span class="kt">Type</span> :=
  {_ : Reflexive R | { _ : Symmetric R | Transitive R}}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chkd"><span class="highlight"><span class="kn">Instance</span> <span class="nf">trunc_sig_equiv_rel</span> `{Funext} {A : <span class="kt">Type</span>}
  (R : Relation A) {n} `{!<span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A), IsTrunc n (R x y)}
  :  IsTrunc n (SigEquivRel R).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc n (R x y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n (SigEquivRel R)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chke"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc n (R x y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n (SigEquivRel R)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chkf"><span class="highlight"><span class="nb">apply</span> @istrunc_sigma.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc n (R x y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n (Reflexive R)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="canonical-names-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc n (R x y)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="canonical-names-v-chk10"><hr></label><div class="goal-conclusion"><span class="highlight">Reflexive R -&gt;
IsTrunc n {_ : Symmetric R &amp; Transitive R}</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk11"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc n (R x y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n (Reflexive R)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> istrunc_forall.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk12"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc n (R x y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Reflexive R -&gt;
IsTrunc n {_ : Symmetric R &amp; Transitive R}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk13"><span class="highlight"><span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc n (R x y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Reflexive R</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n {_ : Symmetric R &amp; Transitive R}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> @istrunc_sigma; <span class="nb">intros</span>; <span class="nb">apply</span> istrunc_forall.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk14"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">issig_equiv_rel</span> {<span class="nv">A</span>:<span class="kt">Type</span>} (<span class="nv">R</span> : Relation A)
  : SigEquivRel R &lt;~&gt; EquivRel R.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">SigEquivRel R &lt;~&gt; EquivRel R</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk15"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">SigEquivRel R &lt;~&gt; EquivRel R</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">issig.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk16"><span class="highlight"><span class="kn">Instance</span> <span class="nf">istrunc_equiv_rel</span> `{Funext} {A : <span class="kt">Type</span>}
  (R : Relation A) {n} `{!<span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A), IsTrunc n (R x y)}
  : IsTrunc n (EquivRel R).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc n (R x y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n (EquivRel R)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk17"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Relation A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsTrunc n (R x y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n (EquivRel R)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (istrunc_equiv_istrunc (SigEquivRel R) (issig_equiv_rel R)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Conjugate</span> <span class="nv">A</span> := conj : A -&gt; A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">DistrOpp</span> {<span class="nv">A</span>} `(SgOp A) `(Conjugate A)
  := distropp : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, conj (sg_op x y) = sg_op (conj y) (conj x).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">SwapOp</span> {<span class="nv">A</span>} `(Negate A) `(Conjugate A)
  := swapop : <span class="kr">forall</span> <span class="nv">x</span>, conj (-x) = - (conj x).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">FactorNegLeft</span> {<span class="nv">A</span>} `(Negate A) `(SgOp A)
  := factorneg_l : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, sg_op (-x) y = - (sg_op x y).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">FactorNegRight</span> {<span class="nv">A</span>} `(Negate A) `(SgOp A)
  := factorneg_r : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, sg_op x (-y) = - (sg_op x y).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">LeftHeteroDistribute</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>}
  (<span class="nv">f</span> : A -&gt; B -&gt; C) (<span class="nv">g_r</span> : B -&gt; B -&gt; B) (<span class="nv">g</span> : C -&gt; C -&gt; C) : <span class="kt">Type</span>
  := distribute_l : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>, f a (g_r b c) = g (f a b) (f a c).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">RightHeteroDistribute</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>}
  (<span class="nv">f</span> : A -&gt; B -&gt; C) (<span class="nv">g_l</span> : A -&gt; A -&gt; A) (<span class="nv">g</span> : C -&gt; C -&gt; C) : <span class="kt">Type</span>
  := distribute_r: <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>, f (g_l a b) c = g (f a c) (f b c).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">LeftDistribute</span> {<span class="nv">A</span>} (<span class="nv">f</span> <span class="nv">g</span>: A -&gt; A -&gt; A)
  := simple_distribute_l :&gt; LeftHeteroDistribute f g g.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">RightDistribute</span> {<span class="nv">A</span>} (<span class="nv">f</span> <span class="nv">g</span>: A -&gt; A -&gt; A)
  := simple_distribute_r :&gt; RightHeteroDistribute f g g.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">HeteroSymmetric</span> {<span class="nv">A</span>} {<span class="nv">T</span> : A -&gt; A -&gt; <span class="kt">Type</span>}
  (<span class="nv">R</span> : <span class="kr">forall</span> {<span class="nv">x</span> <span class="nv">y</span>}, T x y -&gt; T y x -&gt; <span class="kt">Type</span>) : <span class="kt">Type</span>
  := hetero_symmetric `(a : T x y) (b : T y x) : R a b -&gt; R b a.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Although cancellation is the same as being injective, we want a proper</span>
<span class="c">  name to refer to this commonly used property. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">cancellation</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> `(op : A -&gt; A -&gt; A) (z : A).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">LeftCancellation</span> := left_cancellation : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, op z x = op z y -&gt; x = y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">RightCancellation</span> := right_cancellation : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, op x z = op y z -&gt; x = y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">Aap</span> : Apart A}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">StrongLeftCancellation</span> := strong_left_cancellation
    : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x ‚â∂ y -&gt; op z x ‚â∂ op z y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">StrongRightCancellation</span> := strong_right_cancellation
    : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x ‚â∂ y -&gt; op x z ‚â∂ op y z.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">cancellation</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Common names for properties that hold in N, Z, Q, ... *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">ZeroProduct</span> <span class="nv">A</span> `{!Mult A} `{!Zero A} : <span class="kt">Type</span>
  := zero_product : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x * y = <span class="mi">0</span> -&gt; x = <span class="mi">0</span> |_| y = <span class="mi">0</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">ZeroDivisor</span> {<span class="nv">R</span>} `{Zero R} `{Mult R} (x : R) : <span class="kt">Type</span>
  := zero_divisor : x &lt;&gt; <span class="mi">0</span> /\ <span class="kr">exists</span> <span class="nv">y</span>, y &lt;&gt; <span class="mi">0</span> /\ x * y = <span class="mi">0</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">NoZeroDivisors</span> <span class="nv">R</span> `{Zero R} `{Mult R} : <span class="kt">Type</span>
  := no_zero_divisors x : ~ZeroDivisor x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk18"><span class="highlight"><span class="kn">Instance</span> <span class="nf">zero_product_no_zero_divisors</span> `{ZeroProduct A}
  : NoZeroDivisors A.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Mult0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Mult A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Zero0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Zero A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ZeroProduct A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">NoZeroDivisors A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk19"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Mult0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Mult A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Zero0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Zero A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ZeroProduct A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">NoZeroDivisors A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="canonical-names-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="canonical-names-v-chk1a"><span class="highlight"><span class="nb">intros</span> x [? [? [? E]]].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Mult0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Mult A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Zero0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Zero A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ZeroProduct A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fst</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">proj1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fst0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">proj1 &lt;&gt; <span class="mi">0</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x * proj1 = <span class="mi">0</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Empty</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (zero_product _ _ E); <span class="nb">auto</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* A common induction principle for both the naturals and integers *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Biinduction</span> <span class="nv">R</span> `{Zero R} `{One R} `{Plus R} : <span class="kt">Type</span>
  := biinduction (P : R -&gt; <span class="kt">Type</span>)
  : P <span class="mi">0</span> -&gt; (<span class="kr">forall</span> <span class="nv">n</span>, P n &lt;-&gt; P (<span class="mi">1</span> + n)) -&gt; <span class="kr">forall</span> <span class="nv">n</span>, P n.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

<span class="sd">(** Additional operations **)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">CutMinus</span> <span class="nv">A</span> := cut_minus : A -&gt; A -&gt; A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;‚à∏&quot;</span> := cut_minus : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚à∏)&quot;</span> := cut_minus (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x ‚à∏)&quot;</span> := (cut_minus x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(‚à∏ y )&quot;</span> := (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x ‚à∏ y) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">comparison</span> : <span class="kt">Set</span> := LT | EQ | GT.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Compare</span> <span class="nv">A</span> := <span class="nb">compare</span> : A -&gt; A -&gt; comparison.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;?=&quot;</span> := <span class="nb">compare</span> : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(?=)&quot;</span> := <span class="nb">compare</span> (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x ?=)&quot;</span> := (<span class="nb">compare</span> x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(?= y )&quot;</span> := (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x ?= y) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Eqb</span> <span class="nv">A</span> := eqb : A -&gt; A -&gt; Bool.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;=?&quot;</span> := eqb : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(=?)&quot;</span> := eqb (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x =?)&quot;</span> := (eqb x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(=? y )&quot;</span> := (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x =? y) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Ltb</span> <span class="nv">A</span> := ltb : A -&gt; A -&gt; Bool.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;&lt;?&quot;</span> := ltb : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(&lt;?)&quot;</span> := ltb (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x &lt;?)&quot;</span> := (ltb x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(&lt;? y )&quot;</span> := (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x &lt;? y) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Leb</span> <span class="nv">A</span> := leb : A -&gt; A -&gt; Bool.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Infix</span> <span class="s2">&quot;&lt;=?&quot;</span> := leb : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(&lt;=?)&quot;</span> := leb (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x &lt;=?)&quot;</span> := (leb x) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;(&lt;=? y )&quot;</span> := (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x &lt;=? y) (<span class="kn">only parsing</span>) : mc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Return</span> (<span class="nv">M</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) := ret : <span class="kr">forall</span> {<span class="nv">A</span>}, A -&gt; M A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Bind</span> (<span class="nv">M</span> : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>) := bind : <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span>}, M A -&gt; (A -&gt; M B) -&gt; M B.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Enumerable</span>@{i} (A : <span class="kt">Type</span>@{i}) :=
  { enumerator : nat -&gt; A
  ; enumerator_issurj :&gt;
    IsConnMap@{i} (trunc_S minus_two) enumerator }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> enumerator A {_} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> enumerator_issurj A {_} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(*</span>
<span class="c">  The following class is nice to parametrize instances by additional properties, for example:</span>
<span class="c">  [forall z, PropHolds (z &lt;&gt; 0) -&gt; LeftCancellation op z]</span>
<span class="c">  This tool is very powerful as we can combine it with instances as:</span>
<span class="c">  [forall x y, PropHolds (x &lt;&gt; 0) -&gt; PropHolds (y &lt;&gt; 0) -&gt; PropHolds (x * y &lt;&gt; 0)]</span>
<span class="c">  Of course, one should be very careful not to make too many instances as that could</span>
<span class="c">  easily lead to a blow-up of the search space (or worse, cycles).</span>
<span class="c">*)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">PropHolds</span> (<span class="nv">P</span> : <span class="kt">Type</span>) := prop_holds: P.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (PropHolds _) =&gt; <span class="bp">assumption</span> : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">solve_propholds</span> :=
  <span class="kr">match goal with</span>
  | [ |- PropHolds (<span class="nl">?P</span>) ] =&gt; <span class="nb">apply</span> _
  | [ |- <span class="nl">?P</span> ] =&gt; <span class="nb">change</span> (PropHolds P); <span class="nb">apply</span> _
  <span class="kr">end</span>.</span></span></span></pre>
</div>
</div></body>
</html>
