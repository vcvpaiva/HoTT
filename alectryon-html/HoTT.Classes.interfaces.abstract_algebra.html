<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>abstract_algebra.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Spaces.Nat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Export</span> HoTT.Classes.interfaces.canonical_names.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> HProp.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Generalizable Variables</span> <span class="nf">A</span> B f g x y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* </span>
<span class="c">For various structures we omit declaration of substructures. For example, if we </span>
<span class="c">say:</span>

<span class="c">Class Setoid_Morphism :=</span>
<span class="c">  { setoidmor_a :&gt; Setoid A</span>
<span class="c">  ; setoidmor_b :&gt; Setoid B</span>
<span class="c">  ; sm_proper :&gt; Proper ((=) ==&gt; (=)) f }.</span>

<span class="c">then each time a Setoid instance is required, Coq will try to prove that a</span>
<span class="c">Setoid_Morphism exists. This obviously results in an enormous blow-up of the</span>
<span class="c">search space. Moreover, one should be careful to declare a Setoid_Morphisms</span>
<span class="c">as a substructure. Consider [f t1 t2], now if we want to perform setoid rewriting</span>
<span class="c">in [t2] Coq will first attempt to prove that [f t1] is Proper, for which it will </span>
<span class="c">attempt to prove [Setoid_Morphism (f t1)]. If many structures declare</span>
<span class="c">Setoid_Morphism as a substructure, setoid rewriting will become horribly slow.</span>
<span class="c">*)</span>

<span class="c">(* An unbundled variant of the former CoRN CSetoid. We do not </span>
<span class="c">  include a proof that A is a Setoid because it can be derived. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsApart</span> <span class="nv">A</span> {<span class="nv">Aap</span> : Apart A} : <span class="kt">Type</span> :=
  { apart_set :&gt; IsHSet A
  ; apart_mere :&gt; is_mere_relation _ apart
  ; apart_symmetric :&gt; Symmetric (‚â∂)
  ; apart_cotrans :&gt; CoTransitive (‚â∂)
  ; tight_apart : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, ~(x ‚â∂ y) &lt;-&gt; x = y }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk0"><span class="highlight"><span class="kn">Instance</span> <span class="nf">apart_irrefl</span> `{IsApart A} : Irreflexive (‚â∂).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Apart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsApart A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Irreflexive apart</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Apart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsApart A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Irreflexive apart</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2"><span class="highlight"><span class="nb">intros</span> x ap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Apart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsApart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x ‚â∂ x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Empty</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3"><span class="highlight"><span class="nb">apply</span> (tight_apart x x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Apart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsApart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x ‚â∂ x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = x</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Apart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsApart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x ‚â∂ x</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abstract-algebra-v-chk4"><hr></label><div class="goal-conclusion"><span class="highlight">x ‚â∂ x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Apart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsApart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x ‚â∂ x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk6"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Apart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsApart A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ap</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x ‚â∂ x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x ‚â∂ x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> tight_apart {A Aap IsApart} _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">setoid_morphisms</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">Aap</span> : Apart A} {<span class="nv">Bap</span> : Apart B} (<span class="nv">f</span> : A -&gt; B).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">StrongExtensionality</span> := strong_extensionality : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f x ‚â∂ f y -&gt; x ‚â∂ y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">setoid_morphisms</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* HOTT TODO check if this is ok/useful *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (<span class="nl">?f</span> _ = <span class="nl">?f</span> _) =&gt; <span class="nb">eapply</span> (ap f) : core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">setoid_binary_morphisms</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} {<span class="nv">Aap</span>: Apart A} 
    {<span class="nv">Bap</span> : Apart B} {<span class="nv">Cap</span> : Apart C} (<span class="nv">f</span> : A -&gt; B -&gt; C).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">StrongBinaryExtensionality</span> := strong_binary_extensionality
    : <span class="kr">forall</span> <span class="nv">x‚ÇÅ</span> <span class="nv">y‚ÇÅ</span> <span class="nv">x‚ÇÇ</span> <span class="nv">y‚ÇÇ</span>, f x‚ÇÅ y‚ÇÅ ‚â∂ f x‚ÇÇ y‚ÇÇ -&gt; hor (x‚ÇÅ ‚â∂ x‚ÇÇ) (y‚ÇÅ ‚â∂ y‚ÇÇ).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">setoid_binary_morphisms</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(*</span>
<span class="c">Since apartness usually only becomes relevant when considering fields (e.g. the </span>
<span class="c">real numbers), we do not include it in the lower part of the algebraic hierarchy</span>
<span class="c">(as opposed to CoRN).</span>
<span class="c">*)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">upper_classes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Universe</span> <span class="nf">i</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">A</span> : <span class="kt">Type</span>@{i}).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> mc_mult_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsSemiGroup</span> {<span class="nv">Aop</span>: SgOp A} :=
    { sg_set :&gt; IsHSet A
    ; sg_ass :&gt; Associative (.*.) }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsCommutativeSemiGroup</span> {<span class="nv">Aop</span> : SgOp A} :=
    { comsg_sg :&gt; @IsSemiGroup (.*.)
    ; comsg_comm :&gt; Commutative (.*.) }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsSemiLattice</span> {<span class="nv">Aop</span> : SgOp A} :=
    { semilattice_sg :&gt; @IsCommutativeSemiGroup (.*.)
    ; semilattice_idempotent :&gt; BinaryIdempotent (.*.)}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsMonoid</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} :=
    { monoid_semigroup :&gt; IsSemiGroup
    ; monoid_left_id :&gt; LeftIdentity (.*.) mon_unit
    ; monoid_right_id :&gt; RightIdentity (.*.) mon_unit }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsCommutativeMonoid</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} :=
    { commonoid_mon :&gt; @IsMonoid (.*.) Aunit
    ; commonoid_commutative :&gt; Commutative (.*.) }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsGroup</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} {<span class="nv">Anegate</span> : Negate A} :=
    { group_monoid :&gt; @IsMonoid (.*.) Aunit
    ; negate_l :&gt; LeftInverse (.*.) (-) mon_unit
    ; negate_r :&gt; RightInverse (.*.) (-) mon_unit }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsBoundedSemiLattice</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} :=
    { bounded_semilattice_mon :&gt; @IsCommutativeMonoid (.*.) Aunit
    ; bounded_semilattice_idempotent :&gt; BinaryIdempotent (.*.)}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsAbGroup</span> {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Aunit</span> : MonUnit A} {<span class="nv">Anegate</span> : Negate A} :=
    { abgroup_group :&gt; @IsGroup (.*.) Aunit Anegate
    ; abgroup_commutative :&gt; Commutative (.*.) }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Close Scope</span> mc_mult_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">Aplus</span> : Plus A} {<span class="nv">Amult</span> : Mult A} {<span class="nv">Azero</span> : Zero A} {<span class="nv">Aone</span> : One A}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsSemiRing</span> :=
    { semiplus_monoid :&gt; @IsCommutativeMonoid plus_is_sg_op zero_is_mon_unit
    ; semimult_monoid :&gt; @IsCommutativeMonoid mult_is_sg_op one_is_mon_unit
    ; semiring_distr :&gt; LeftDistribute (.*.) (+)
    ; semiring_left_absorb :&gt; LeftAbsorb (.*.) <span class="mi">0</span> }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">Anegate</span> : Negate A}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsRing</span> :=
    { ring_group :&gt; @IsAbGroup plus_is_sg_op zero_is_mon_unit _
    ; ring_monoid :&gt; @IsCommutativeMonoid mult_is_sg_op one_is_mon_unit
    ; ring_dist :&gt; LeftDistribute (.*.) (+) }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* For now, we follow CoRN/ring_theory&#39;s example in having Ring and SemiRing</span>
<span class="c">    require commutative multiplication. *)</span>

</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsIntegralDomain</span> :=
    { intdom_ring : IsRing
    ; intdom_nontrivial : PropHolds (not (<span class="mi">1</span> = <span class="mi">0</span>))
    ; intdom_nozeroes :&gt; NoZeroDivisors A }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* We do not include strong extensionality for (-) and (/)</span>
<span class="c">    because it can de derived *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsField</span> {<span class="nv">Aap</span>: Apart A} {<span class="nv">Arecip</span>: Recip A} :=
    { field_ring :&gt; IsRing
    ; field_apart :&gt; IsApart A
    ; field_plus_ext :&gt; StrongBinaryExtensionality (+)
    ; field_mult_ext :&gt; StrongBinaryExtensionality (.*.)
    ; field_nontrivial : PropHolds (<span class="mi">1</span> ‚â∂ <span class="mi">0</span>)
    ; recip_inverse : <span class="kr">forall</span> <span class="nv">x</span>, x.<span class="mi">1</span> // x = <span class="mi">1</span> }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* We let /0 = 0 so properties as Injective (/),</span>
<span class="c">    f (/x) = / (f x), / /x = x, /x * /y = /(x * y) </span>
<span class="c">    hold without any additional assumptions *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsDecField</span> {<span class="nv">Adec_recip</span> : DecRecip A} :=
    { decfield_ring :&gt; IsRing
    ; decfield_nontrivial : PropHolds (<span class="mi">1</span> &lt;&gt; <span class="mi">0</span>)
    ; dec_recip_0 : /<span class="mi">0</span> = <span class="mi">0</span>
    ; dec_recip_inverse : <span class="kr">forall</span> <span class="nv">x</span>, x &lt;&gt; <span class="mi">0</span> -&gt; x / x = <span class="mi">1</span> }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">FieldCharacteristic</span>@{j} {Aap : Apart@{i j} A} (k : nat) : <span class="kt">Type</span>@{j}
    := field_characteristic : <span class="kr">forall</span> <span class="nv">n</span> : nat, Nat.lt@{i} <span class="mi">0</span> n -&gt;
      iff@{j j j} (<span class="kr">forall</span> <span class="nv">m</span> : nat, not@{j j} (paths@{<span class="kt">Set</span>} n (Nat.mul k m)))
        (@apart A Aap (Nat.nat_iter n (<span class="mi">1</span> +) <span class="mi">0</span>) <span class="mi">0</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">upper_classes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Due to bug #2528 *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">4</span> (PropHolds (<span class="mi">1</span> &lt;&gt; <span class="mi">0</span>)) =&gt;
  <span class="nb">eapply</span> @intdom_nontrivial : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">5</span> (PropHolds (<span class="mi">1</span> ‚â∂ <span class="mi">0</span>)) =&gt;
  <span class="nb">eapply</span> @field_nontrivial : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">5</span> (PropHolds (<span class="mi">1</span> &lt;&gt; <span class="mi">0</span>)) =&gt;
  <span class="nb">eapply</span> @decfield_nontrivial : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* </span>
<span class="c">For a strange reason IsRing instances of Integers are sometimes obtained by</span>
<span class="c">Integers -&gt; IntegralDomain -&gt; Ring and sometimes directly. Making this an</span>
<span class="c">instance with a low priority instead of using intdom_ring:&gt; IsRing forces Coq to</span>
<span class="c">take the right way </span>
<span class="c">*)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">10</span> (IsRing _) =&gt; <span class="nb">apply</span> @intdom_ring : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> recip_inverse {A Aplus Amult Azero Aone Anegate Aap Arecip IsField} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> dec_recip_inverse
  {A Aplus Amult Azero Aone Anegate Adec_recip IsDecField} _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> dec_recip_0 {A Aplus Amult Azero Aone Anegate Adec_recip IsDecField}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">lattice</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> <span class="nv">A</span> {<span class="nv">Ajoin</span>: Join A} {<span class="nv">Ameet</span>: Meet A} {<span class="nv">Abottom</span> : Bottom A} {<span class="nv">Atop</span> : Top A}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsJoinSemiLattice</span> := 
    join_semilattice :&gt; @IsSemiLattice A join_is_sg_op.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsBoundedJoinSemiLattice</span> := 
    bounded_join_semilattice :&gt; @IsBoundedSemiLattice A
      join_is_sg_op bottom_is_mon_unit.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsMeetSemiLattice</span> := 
    meet_semilattice :&gt; @IsSemiLattice A meet_is_sg_op.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsBoundedMeetSemiLattice</span> :=
    bounded_meet_semilattice :&gt; @IsBoundedSemiLattice A
      meet_is_sg_op top_is_mon_unit.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsLattice</span> := 
    { lattice_join :&gt; IsJoinSemiLattice
    ; lattice_meet :&gt; IsMeetSemiLattice
    ; join_meet_absorption :&gt; Absorption (‚äî) (‚äì) 
    ; meet_join_absorption :&gt; Absorption (‚äì) (‚äî)}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsBoundedLattice</span> :=
    { boundedlattice_join :&gt; IsBoundedJoinSemiLattice
    ; boundedlattice_meet :&gt; IsBoundedMeetSemiLattice
    ; boundedjoin_meet_absorption :&gt; Absorption (‚äî) (‚äì)
    ; boundedmeet_join_absorption :&gt; Absorption (‚äì) (‚äî)}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsDistributiveLattice</span> := 
    { distr_lattice_lattice :&gt; IsLattice
    ; join_meet_distr_l :&gt; LeftDistribute (‚äî) (‚äì) }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">lattice</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">morphism_classes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">sgmorphism_classes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">Aop</span> : SgOp A} {<span class="nv">Bop</span> : SgOp B}
    {<span class="nv">Aunit</span> : MonUnit A} {<span class="nv">Bunit</span> : MonUnit B}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> mc_mult_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsSemiGroupPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    preserves_sg_op : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f (x * y) = f x * f y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsUnitPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    preserves_mon_unit : f mon_unit = mon_unit.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsMonoidPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { monmor_sgmor :&gt; IsSemiGroupPreserving f
    ; monmor_unitmor :&gt; IsUnitPreserving f }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">sgmorphism_classes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">ringmorphism_classes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">Aplus</span> : Plus A} {<span class="nv">Bplus</span> : Plus B}
    {<span class="nv">Amult</span> : Mult A} {<span class="nv">Bmult</span> : Mult B} {<span class="nv">Azero</span> : Zero A} {<span class="nv">Bzero</span> : Zero B}
    {<span class="nv">Aone</span> : One A} {<span class="nv">Bone</span> : One B}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsSemiRingPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { semiringmor_plus_mor :&gt; @IsMonoidPreserving A B
        plus_is_sg_op plus_is_sg_op zero_is_mon_unit zero_is_mon_unit f
    ; semiringmor_mult_mor :&gt; @IsMonoidPreserving A B
        mult_is_sg_op mult_is_sg_op one_is_mon_unit one_is_mon_unit f }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">Aap</span> : Apart A} {<span class="nv">Bap</span> : Apart B}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsSemiRingStrongPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { strong_semiringmor_sr_mor :&gt; IsSemiRingPreserving f
    ; strong_semiringmor_strong_mor :&gt; StrongExtensionality f }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">ringmorphism_classes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">latticemorphism_classes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">Ajoin</span> : Join A} {<span class="nv">Bjoin</span> : Join B}
    {<span class="nv">Ameet</span> : Meet A} {<span class="nv">Bmeet</span> : Meet B}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsJoinPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    join_slmor_sgmor :&gt; @IsSemiGroupPreserving A B join_is_sg_op join_is_sg_op f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsMeetPreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    meet_slmor_sgmor :&gt; @IsSemiGroupPreserving A B meet_is_sg_op meet_is_sg_op f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">Abottom</span> : Bottom A} {<span class="nv">Bbottom</span> : Bottom B}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsBoundedJoinPreserving</span> (<span class="nv">f</span> : A -&gt; B) := bounded_join_slmor_monmor
      :&gt; @IsMonoidPreserving A B join_is_sg_op join_is_sg_op
         bottom_is_mon_unit bottom_is_mon_unit f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsLatticePreserving</span> (<span class="nv">f</span> : A -&gt; B) :=
    { latticemor_join_mor :&gt; IsJoinPreserving f
    ; latticemor_meet_mor :&gt; IsMeetPreserving f }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">latticemorphism_classes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">morphism_classes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">jections</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsInjective</span> := injective : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, f x = f y -&gt; x = y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk7"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">isinjective_ne</span> `{!IsInjective} x y :
    x &lt;&gt; y -&gt; f x &lt;&gt; f y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsInjective</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x &lt;&gt; y -&gt; f x &lt;&gt; f y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk8"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsInjective</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x &lt;&gt; y -&gt; f x &lt;&gt; f y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk9"><span class="highlight"><span class="nb">intros</span> E1 E2.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsInjective</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x &lt;&gt; y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f x = f y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Empty</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chka"><span class="highlight"><span class="nb">apply</span> E1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsInjective</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x &lt;&gt; y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f x = f y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x = y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkb"><span class="highlight"><span class="nb">apply</span> injective.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsInjective</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x &lt;&gt; y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f x = f y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f x = f y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">jections</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isinj_idmap</span> <span class="nv">A</span> : @IsInjective A A idmap
  := <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; idmap.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Unfold</span> IsInjective : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">strong_injective</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">Aap</span> : Apart A} {<span class="nv">Bap</span> : Apart B} (<span class="nv">f</span> : A -&gt; B) .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsStrongInjective</span> :=
    { strong_injective : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x ‚â∂ y -&gt; f x ‚â∂ f y
    ; strong_injective_mor : StrongExtensionality f }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">strong_injective</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">extras</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">CutMinusSpec</span> <span class="nv">A</span> (<span class="nv">cm</span> : CutMinus A) `{Zero A} `{Plus A} `{Le A} := {
  cut_minus_le : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, y ‚â§ x -&gt; x ‚à∏ y + y = x ;
  cut_minus_0 : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, x ‚â§ y -&gt; x ‚à∏ y = <span class="mi">0</span>
}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkc"><span class="highlight"><span class="kn">Instance</span> <span class="nf">ishprop_issemigrouppreserving</span> `{Funext} {A B : <span class="kt">Type</span>} `{IsHSet B}
  `{SgOp A} `{SgOp B} {f : A -&gt; B} : IsHProp (IsSemiGroupPreserving f).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsSemiGroupPreserving f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkd"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsSemiGroupPreserving f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> IsSemiGroupPreserving; <span class="bp">exact</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">issig_IsSemiRingPreserving</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
  `{Plus A, Plus B, Mult A, Mult B, Zero A, Zero B, One A, One B} {f : A -&gt; B}
  : _ &lt;~&gt; IsSemiRingPreserving f := <span class="kp">ltac</span>:(issig).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">issig_IsMonoidPreserving</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{SgOp A} `{SgOp B}
  `{MonUnit A} `{MonUnit B} {f : A -&gt; B} : _ &lt;~&gt; IsMonoidPreserving f
  := <span class="kp">ltac</span>:(issig).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chke"><span class="highlight"><span class="kn">Instance</span> <span class="nf">ishprop_ismonoidpreserving</span> `{Funext} {A B : <span class="kt">Type</span>} `{SgOp A}
  `{SgOp B} `{IsHSet B} `{MonUnit A} `{MonUnit B} (f : A -&gt; B)
  : IsHProp (IsMonoidPreserving f).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsMonoidPreserving f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chkf"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsMonoidPreserving f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk10"><span class="highlight">srapply (istrunc_equiv_istrunc _ issig_IsMonoidPreserving).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp
  {_ : IsSemiGroupPreserving f &amp; IsUnitPreserving f}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk11"><span class="highlight">srapply (istrunc_equiv_istrunc _ (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsSemiGroupPreserving f * IsUnitPreserving f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk12"><span class="highlight">srapply istrunc_prod.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsUnitPreserving f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk13"><span class="highlight"><span class="nb">unfold</span> IsUnitPreserving.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (f mon_unit = mon_unit)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk14"><span class="highlight"><span class="kn">Instance</span> <span class="nf">ishprop_issemiringpreserving</span> `{Funext} {A B : <span class="kt">Type</span>} `{IsHSet B}
  `{Plus A, Plus B, Mult A, Mult B, Zero A, Zero B, One A, One B}
  (f : A -&gt; B)
  : IsHProp (IsSemiRingPreserving f).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Plus A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Plus B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Mult A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Mult B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Zero A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Zero B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">One A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">One B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsSemiRingPreserving f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk15"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Plus A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Plus B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Mult A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Mult B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Zero A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Zero B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">One A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">One B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsSemiRingPreserving f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk16"><span class="highlight">snrapply (istrunc_equiv_istrunc _ issig_IsSemiRingPreserving).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Plus A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Plus B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Mult A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H3</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Mult B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H4</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Zero A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H5</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Zero B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H6</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">One A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H7</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">One B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp
  {_ : IsMonoidPreserving f &amp; IsMonoidPreserving f}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">issig_issemigroup</span> <span class="nv">x</span> <span class="nv">y</span> : _ &lt;~&gt; @IsSemiGroup x y := <span class="kp">ltac</span>:(issig).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk17"><span class="highlight"><span class="kn">Instance</span> <span class="nf">ishprop_issemigroup</span> `{Funext}
  : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, IsHProp (@IsSemiGroup x y).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : <span class="kt">Type</span>) (<span class="nv">y</span> : SgOp x),
IsHProp (IsSemiGroup x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk18"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">x</span> : <span class="kt">Type</span>) (<span class="nv">y</span> : SgOp x),
IsHProp (IsSemiGroup x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk19"><span class="highlight"><span class="nb">intros</span> x y a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>) (a = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1a"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eisretr (issig_issemigroup x y) a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_issemigroup x y
     ((issig_issemigroup x y)^-<span class="mi">1</span> a) = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1b"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eisretr (issig_issemigroup x y) b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_issemigroup x y
     ((issig_issemigroup x y)^-<span class="mi">1</span> a) =
   issig_issemigroup x y
     ((issig_issemigroup x y)^-<span class="mi">1</span> b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1c"><span class="highlight"><span class="nb">set</span> (a&#39; := (issig_issemigroup x y)^-<span class="mi">1</span> a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">(issig_issemigroup x y)^-<span class="mi">1</span> a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_issemigroup x y a&#39; =
   issig_issemigroup x y
     ((issig_issemigroup x y)^-<span class="mi">1</span> b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1d"><span class="highlight"><span class="nb">set</span> (b&#39; := (issig_issemigroup x y)^-<span class="mi">1</span> b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">(issig_issemigroup x y)^-<span class="mi">1</span> a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">(issig_issemigroup x y)^-<span class="mi">1</span> b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_issemigroup x y a&#39; = issig_issemigroup x y b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1e"><span class="highlight"><span class="nb">clearbody</span> a&#39; b&#39;; <span class="nb">clear</span> a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_issemigroup x y a&#39; = issig_issemigroup x y b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk1f"><span class="highlight">srapply (contr_equiv _ (ap (issig_issemigroup x y))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a&#39; = b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk20"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) a&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsHSet x) (Associative sg_op)
        a&#39;) = b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk21"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) b&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsHSet x) (Associative sg_op)
        a&#39;) =
   (equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsHSet x) (Associative sg_op)
        b&#39;))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk22"><span class="highlight"><span class="nb">set</span> (a := equiv_sigma_prod0 _ _ a&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (IsHSet x) (Associative sg_op) a&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsHSet x * Associative sg_op)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     a =
   (equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsHSet x) (Associative sg_op)
        b&#39;))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk23"><span class="highlight"><span class="nb">set</span> (b := equiv_sigma_prod0 _ _ b&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsHSet x &amp; Associative sg_op}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (IsHSet x) (Associative sg_op) a&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsHSet x * Associative sg_op)%type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (IsHSet x) (Associative sg_op) b&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsHSet x * Associative sg_op)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     a =
   (equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk24"><span class="highlight"><span class="nb">clearbody</span> a b; <span class="nb">clear</span> a&#39; b&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsHSet x * Associative sg_op)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     a =
   (equiv_sigma_prod0 (IsHSet x) (Associative sg_op))^-<span class="mi">1</span>
     b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk25"><span class="highlight">srapply (contr_equiv _ (ap (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsHSet x * Associative sg_op)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk26"><span class="highlight">srapply (contr_equiv _ (equiv_path_prod _ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsHSet x * Associative sg_op)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr ((fst a = fst b) * (snd a = snd b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk27"><span class="highlight">srapply contr_prod.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsHSet x * Associative sg_op)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (snd a = snd b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk28"><span class="highlight"><span class="nb">destruct</span> a <span class="kr">as</span> [a&#39; a], b <span class="kr">as</span> [b&#39; b].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Associative sg_op</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Associative sg_op</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (snd (a&#39;, a) = snd (b&#39;, b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk29"><span class="highlight"><span class="kp">do</span> <span class="mi">3</span> (nrefine (contr_equiv&#39; _ (@equiv_path_forall H _ _ _ _));
  nrefine (@contr_forall H _ _ _); <span class="nb">intro</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Associative sg_op</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Associative sg_op</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a0, a1, a2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (snd (a&#39;, a) a0 a1 a2 = snd (b&#39;, b) a0 a1 a2)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">issig_ismonoid</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : _ &lt;~&gt; @IsMonoid x y z := <span class="kp">ltac</span>:(issig).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2a"><span class="highlight"><span class="kn">Instance</span> <span class="nf">ishprop_ismonoid</span> `{Funext} x y z : IsHProp (@IsMonoid x y z).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsMonoid x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsMonoid x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2c"><span class="highlight"><span class="nb">intros</span> a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>) (a = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2d"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eisretr (issig_ismonoid x y z) a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_ismonoid x y z ((issig_ismonoid x y z)^-<span class="mi">1</span> a) =
   b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2e"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eisretr (issig_ismonoid x y z) b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_ismonoid x y z ((issig_ismonoid x y z)^-<span class="mi">1</span> a) =
   issig_ismonoid x y z ((issig_ismonoid x y z)^-<span class="mi">1</span> b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk2f"><span class="highlight"><span class="nb">set</span> (a&#39; := (issig_ismonoid x y z)^-<span class="mi">1</span> a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">(issig_ismonoid x y z)^-<span class="mi">1</span> a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_ismonoid x y z a&#39; =
   issig_ismonoid x y z ((issig_ismonoid x y z)^-<span class="mi">1</span> b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk30"><span class="highlight"><span class="nb">set</span> (b&#39; := (issig_ismonoid x y z)^-<span class="mi">1</span> b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">(issig_ismonoid x y z)^-<span class="mi">1</span> a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">(issig_ismonoid x y z)^-<span class="mi">1</span> b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_ismonoid x y z a&#39; = issig_ismonoid x y z b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk31"><span class="highlight"><span class="nb">clearbody</span> a&#39; b&#39;; <span class="nb">clear</span> a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_ismonoid x y z a&#39; = issig_ismonoid x y z b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk32"><span class="highlight">srapply (contr_equiv _ (ap (issig_ismonoid x y z))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a&#39; = b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk33"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) a&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsSemiGroup x)
        {_ : LeftIdentity sg_op mon_unit &amp;
        RightIdentity sg_op mon_unit} a&#39;) = b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk34"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) b&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsSemiGroup x)
        {_ : LeftIdentity sg_op mon_unit &amp;
        RightIdentity sg_op mon_unit} a&#39;) =
   (equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsSemiGroup x)
        {_ : LeftIdentity sg_op mon_unit &amp;
        RightIdentity sg_op mon_unit} b&#39;))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk35"><span class="highlight"><span class="nb">set</span> (a := equiv_sigma_prod0 _ _ a&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (IsSemiGroup x)
  {_ : LeftIdentity sg_op mon_unit &amp;
  RightIdentity sg_op mon_unit} a&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsSemiGroup x)
        {_ : LeftIdentity sg_op mon_unit &amp;
        RightIdentity sg_op mon_unit} b&#39;))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk36"><span class="highlight"><span class="nb">set</span> (b := equiv_sigma_prod0 _ _ b&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsSemiGroup x &amp;
{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (IsSemiGroup x)
  {_ : LeftIdentity sg_op mon_unit &amp;
  RightIdentity sg_op mon_unit} a&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (IsSemiGroup x)
  {_ : LeftIdentity sg_op mon_unit &amp;
  RightIdentity sg_op mon_unit} b&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span> b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk37"><span class="highlight"><span class="nb">clearbody</span> a b; <span class="nb">clear</span> a&#39; b&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsSemiGroup x)
      {_ : LeftIdentity sg_op mon_unit &amp;
      RightIdentity sg_op mon_unit})^-<span class="mi">1</span> b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk38"><span class="highlight">srapply (contr_equiv _ (ap (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk39"><span class="highlight">srapply (contr_equiv _ (equiv_path_prod _ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr ((fst a = fst b) * (snd a = snd b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3a"><span class="highlight">srapply contr_prod.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsSemiGroup x *
 {_ : LeftIdentity sg_op mon_unit &amp;
 RightIdentity sg_op mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (snd a = snd b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3b"><span class="highlight"><span class="nb">destruct</span> a <span class="kr">as</span> [a&#39; a], b <span class="kr">as</span> [b&#39; b]; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3c"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
        (RightIdentity sg_op mon_unit) a) = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3d"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
        (RightIdentity sg_op mon_unit) a) =
   (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
        (RightIdentity sg_op mon_unit) b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3e"><span class="highlight"><span class="nb">set</span> (a&#39;&#39; := equiv_sigma_prod0 _ _ a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
  (RightIdentity sg_op mon_unit) a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
        (RightIdentity sg_op mon_unit) b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk3f"><span class="highlight"><span class="nb">set</span> (b&#39;&#39; := equiv_sigma_prod0 _ _ b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftIdentity sg_op mon_unit &amp;
RightIdentity sg_op mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
  (RightIdentity sg_op mon_unit) a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
  (RightIdentity sg_op mon_unit) b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span> b&#39;&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk40"><span class="highlight"><span class="nb">clearbody</span> a&#39;&#39; b&#39;&#39;; <span class="nb">clear</span> a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'', b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0 (LeftIdentity sg_op mon_unit)
      (RightIdentity sg_op mon_unit))^-<span class="mi">1</span> b&#39;&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk41"><span class="highlight">srapply (contr_equiv _ (ap (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'', b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a&#39;&#39; = b&#39;&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk42"><span class="highlight">srapply (contr_equiv _ (equiv_path_prod _ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'', b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftIdentity sg_op mon_unit * RightIdentity sg_op mon_unit)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr ((fst a&#39;&#39; = fst b&#39;&#39;) * (snd a&#39;&#39; = snd b&#39;&#39;))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk43"><span class="highlight"><span class="nb">destruct</span> a&#39;&#39; <span class="kr">as</span> [a a&#39;&#39;], b&#39;&#39; <span class="kr">as</span> [b b&#39;&#39;]; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr ((a = b) * (a&#39;&#39; = b&#39;&#39;))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk44"><span class="highlight">srapply contr_prod.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a = b)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk45" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abstract-algebra-v-chk45"><hr></label><div class="goal-conclusion"><span class="highlight">Contr (a&#39;&#39; = b&#39;&#39;)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk46"><span class="highlight"><span class="kp">all</span>: srapply contr_paths_contr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (LeftIdentity sg_op mon_unit)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk47" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abstract-algebra-v-chk47"><hr></label><div class="goal-conclusion"><span class="highlight">Contr (RightIdentity sg_op mon_unit)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk48"><span class="highlight"><span class="kp">all</span>: srapply contr_inhabited_hprop.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (LeftIdentity sg_op mon_unit)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsSemiGroup x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftIdentity sg_op mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightIdentity sg_op mon_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abstract-algebra-v-chk49"><hr></label><div class="goal-conclusion"><span class="highlight">IsHProp (RightIdentity sg_op mon_unit)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">all</span>: srapply istrunc_forall.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">issig_isgroup</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : _ &lt;~&gt; @IsGroup w x y z := <span class="kp">ltac</span>:(issig).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4a"><span class="highlight"><span class="kn">Instance</span> <span class="nf">ishprop_isgroup</span> `{Funext} w x y z : IsHProp (@IsGroup w x y z).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsGroup w)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (IsGroup w)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4c"><span class="highlight"><span class="nb">intros</span> a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsGroup w</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>) (a = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4d"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eisretr (issig_isgroup w x y z) a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsGroup w</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_isgroup w x y z
     ((issig_isgroup w x y z)^-<span class="mi">1</span> a) = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4e"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eisretr (issig_isgroup w x y z) b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsGroup w</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_isgroup w x y z
     ((issig_isgroup w x y z)^-<span class="mi">1</span> a) =
   issig_isgroup w x y z
     ((issig_isgroup w x y z)^-<span class="mi">1</span> b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk4f"><span class="highlight"><span class="nb">set</span> (a&#39; := (issig_isgroup w x y z)^-<span class="mi">1</span> a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsGroup w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">(issig_isgroup w x y z)^-<span class="mi">1</span> a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_isgroup w x y z a&#39; =
   issig_isgroup w x y z
     ((issig_isgroup w x y z)^-<span class="mi">1</span> b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk50"><span class="highlight"><span class="nb">set</span> (b&#39; := (issig_isgroup w x y z)^-<span class="mi">1</span> b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsGroup w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">(issig_isgroup w x y z)^-<span class="mi">1</span> a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">(issig_isgroup w x y z)^-<span class="mi">1</span> b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_isgroup w x y z a&#39; = issig_isgroup w x y z b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk51"><span class="highlight"><span class="nb">clearbody</span> a&#39; b&#39;; <span class="nb">clear</span> a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc_internal (-<span class="mi">2</span>)
  (issig_isgroup w x y z a&#39; = issig_isgroup w x y z b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk52"><span class="highlight">srapply (contr_equiv _ (ap (issig_isgroup w x y z))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a&#39; = b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk53"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) a&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsMonoid w)
        {_ : LeftInverse sg_op negate mon_unit &amp;
        RightInverse sg_op negate mon_unit} a&#39;) = b&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk54"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) b&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsMonoid w)
        {_ : LeftInverse sg_op negate mon_unit &amp;
        RightInverse sg_op negate mon_unit} a&#39;) =
   (equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsMonoid w)
        {_ : LeftInverse sg_op negate mon_unit &amp;
        RightInverse sg_op negate mon_unit} b&#39;))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk55"><span class="highlight"><span class="nb">set</span> (a := equiv_sigma_prod0 _ _ a&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (IsMonoid w)
  {_ : LeftInverse sg_op negate mon_unit &amp;
  RightInverse sg_op negate mon_unit} a&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span>
     (equiv_sigma_prod0 (IsMonoid w)
        {_ : LeftInverse sg_op negate mon_unit &amp;
        RightInverse sg_op negate mon_unit} b&#39;))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk56"><span class="highlight"><span class="nb">set</span> (b := equiv_sigma_prod0 _ _ b&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : IsMonoid w &amp;
{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (IsMonoid w)
  {_ : LeftInverse sg_op negate mon_unit &amp;
  RightInverse sg_op negate mon_unit} a&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0 (IsMonoid w)
  {_ : LeftInverse sg_op negate mon_unit &amp;
  RightInverse sg_op negate mon_unit} b&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span> b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk57"><span class="highlight"><span class="nb">clearbody</span> a b; <span class="nb">clear</span> a&#39; b&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span> a =
   (equiv_sigma_prod0 (IsMonoid w)
      {_ : LeftInverse sg_op negate mon_unit &amp;
      RightInverse sg_op negate mon_unit})^-<span class="mi">1</span> b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk58"><span class="highlight">srapply (contr_equiv _ (ap (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk59"><span class="highlight">srapply (contr_equiv _ (equiv_path_prod _ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr ((fst a = fst b) * (snd a = snd b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5a"><span class="highlight">srapply contr_prod.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(IsMonoid w *
 {_ : LeftInverse sg_op negate mon_unit &amp;
 RightInverse sg_op negate mon_unit})%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (snd a = snd b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5b"><span class="highlight"><span class="nb">destruct</span> a <span class="kr">as</span> [a&#39; a], b <span class="kr">as</span> [b&#39; b]; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5c"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0
        (LeftInverse sg_op negate mon_unit)
        (RightInverse sg_op negate mon_unit) a) = b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5d"><span class="highlight"><span class="nb">rewrite</span> &lt;- (eissect (equiv_sigma_prod0 _ _) b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0
        (LeftInverse sg_op negate mon_unit)
        (RightInverse sg_op negate mon_unit) a) =
   (equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0
        (LeftInverse sg_op negate mon_unit)
        (RightInverse sg_op negate mon_unit) b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5e"><span class="highlight"><span class="nb">set</span> (a&#39;&#39; := equiv_sigma_prod0 _ _ a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0
  (LeftInverse sg_op negate mon_unit)
  (RightInverse sg_op negate mon_unit) a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span>
     (equiv_sigma_prod0
        (LeftInverse sg_op negate mon_unit)
        (RightInverse sg_op negate mon_unit) b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk5f"><span class="highlight"><span class="nb">set</span> (b&#39;&#39; := equiv_sigma_prod0 _ _ b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">{_ : LeftInverse sg_op negate mon_unit &amp;
RightInverse sg_op negate mon_unit}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0
  (LeftInverse sg_op negate mon_unit)
  (RightInverse sg_op negate mon_unit) a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_sigma_prod0
  (LeftInverse sg_op negate mon_unit)
  (RightInverse sg_op negate mon_unit) b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span> b&#39;&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk60"><span class="highlight"><span class="nb">clearbody</span> a&#39;&#39; b&#39;&#39;; <span class="nb">clear</span> a b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'', b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  ((equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span> a&#39;&#39; =
   (equiv_sigma_prod0
      (LeftInverse sg_op negate mon_unit)
      (RightInverse sg_op negate mon_unit))^-<span class="mi">1</span> b&#39;&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk61"><span class="highlight">srapply (contr_equiv _ (ap (equiv_sigma_prod0 _ _)^-<span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'', b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a&#39;&#39; = b&#39;&#39;)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk62"><span class="highlight">srapply (contr_equiv _ (equiv_path_prod _ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a'', b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(LeftInverse sg_op negate mon_unit * RightInverse sg_op negate mon_unit)%type</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr ((fst a&#39;&#39; = fst b&#39;&#39;) * (snd a&#39;&#39; = snd b&#39;&#39;))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk63"><span class="highlight"><span class="nb">destruct</span> a&#39;&#39; <span class="kr">as</span> [a a&#39;&#39;], b&#39;&#39; <span class="kr">as</span> [b b&#39;&#39;]; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr ((a = b) * (a&#39;&#39; = b&#39;&#39;))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk64"><span class="highlight">srapply contr_prod.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (a = b)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk65" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abstract-algebra-v-chk65"><hr></label><div class="goal-conclusion"><span class="highlight">Contr (a&#39;&#39; = b&#39;&#39;)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk66"><span class="highlight"><span class="kp">all</span>: srapply contr_paths_contr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (LeftInverse sg_op negate mon_unit)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk67" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abstract-algebra-v-chk67"><hr></label><div class="goal-conclusion"><span class="highlight">Contr (RightInverse sg_op negate mon_unit)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abstract-algebra-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="abstract-algebra-v-chk68"><span class="highlight"><span class="kp">all</span>: srapply contr_inhabited_hprop.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsHProp (LeftInverse sg_op negate mon_unit)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abstract-algebra-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">w</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">SgOp w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MonUnit w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Negate w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a', b'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsMonoid w</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">LeftInverse sg_op negate mon_unit</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b''</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">RightInverse sg_op negate mon_unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abstract-algebra-v-chk69"><hr></label><div class="goal-conclusion"><span class="highlight">IsHProp (RightInverse sg_op negate mon_unit)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">all</span>: srapply istrunc_forall.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">extras</span>.</span></span></span></pre>
</div>
</div></body>
</html>
