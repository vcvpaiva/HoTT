<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>LoopSusp.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Basics Types.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Groups.Group.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Pointed.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> WildCat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Truncations.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Homotopy.Suspension.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Homotopy.ClassifyingSpace.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Homotopy.HomotopyGroup.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> pointed_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> ClassifyingSpaceNotation.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** In this file we experiment with defining the free group on [A] to be the fundamental group of the suspension of [A + Unit]. *)</span>

<span class="sd">(** Note that this is NOT the definition of a free group that is used in the library. The definition in use will be exported in the file Algebra.Groups.FreeGroup. This file merely exists to serve as a demonstration that the free group *could* be defined this way.</span>

<span class="sd">This is not a very practical definition because we cannot even show that it is free at the time of writing, and univalence is used in a crucial way which seems overkill for a definition of freegroup. *)</span>


<span class="sd">(** TODO: Perhaps move this to the Pointed directory? *)</span>
<span class="sd">(** The free base point added to a type. This is in fact a functor and left adjoint to the forgetful functor pType to Type. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pointify</span> (<span class="nv">S</span> : <span class="kt">Type</span>) : pType := Build_pType (S + Unit) (inr tt).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** pointify is left adjoint to forgetting the basepoint in the following sense *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk0"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">equiv_pointify_map</span> `{Funext} (A : <span class="kt">Type</span>) (X : pType)
  : (pointify A -&gt;* X) &lt;~&gt; (A -&gt; X).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(pointify A -&gt;* X) &lt;~&gt; (A -&gt; X)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(pointify A -&gt;* X) &lt;~&gt; (A -&gt; X)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk2"><span class="highlight">snrapply equiv_adjointify.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(pointify A -&gt;* X) -&gt; A -&gt; X</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk3"><hr></label><div class="goal-conclusion"><span class="highlight">(A -&gt; X) -&gt; pointify A -&gt;* X</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk4"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?f</span> o <span class="nl">?g</span> == idmap</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk5"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?g</span> o <span class="nl">?f</span> == idmap</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk6"><span class="highlight"><span class="mi">1</span>: <span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">f</span> =&gt; f o inl).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(A -&gt; X) -&gt; pointify A -&gt;* X</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk7"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">f</span> : pointify A -&gt;* X =&gt; f o inl) o <span class="nl">?g</span> == idmap</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk8"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?g</span> o (<span class="kr">fun</span> <span class="nv">f</span> : pointify A -&gt;* X =&gt; f o inl) == idmap</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk9"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(A -&gt; X) -&gt; pointify A -&gt;* X</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chka"><span class="highlight"><span class="nb">intros</span> f.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pointify A -&gt;* X</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chkb"><span class="highlight">snrapply Build_pMap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pointify A -&gt; X</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; X</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chkc"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?f</span> (point (pointify A)) = point X</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chkd"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pointify A -&gt; X</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chke"><span class="highlight"><span class="nb">intros</span> [a|].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">X</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Unit</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chkf"><hr></label><div class="goal-conclusion"><span class="highlight">X</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk10"><span class="highlight"><span class="mi">1</span>: <span class="bp">exact</span> (f a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Unit</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">X</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (point _).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk11"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">X0</span> : pointify A =&gt;
 <span class="kr">match</span> X0 <span class="kr">with</span>
 | inl a =&gt; f a
 | inr _ =&gt; point X
 <span class="kr">end</span>) (point (pointify A)) = point X</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk12"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">f</span> : pointify A -&gt;* X =&gt; f o inl)
o (<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; X =&gt;
   Build_pMap (pointify A) X
     (<span class="kr">fun</span> <span class="nv">X0</span> : pointify A =&gt;
      <span class="kr">match</span> X0 <span class="kr">with</span>
      | inl a =&gt; f a
      | inr _ =&gt; point X
      <span class="kr">end</span>) <span class="mi">1</span>) == idmap</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk13" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk13"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; X =&gt;
 Build_pMap (pointify A) X
   (<span class="kr">fun</span> <span class="nv">X0</span> : pointify A =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; f a
    | inr _ =&gt; point X
    <span class="kr">end</span>) <span class="mi">1</span>) o (<span class="kr">fun</span> <span class="nv">f</span> : pointify A -&gt;* X =&gt; f o inl) ==
idmap</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk14"><span class="highlight"><span class="mi">1</span>: <span class="nb">intro</span> x; <span class="bp">reflexivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">f</span> : A -&gt; X =&gt;
 Build_pMap (pointify A) X
   (<span class="kr">fun</span> <span class="nv">X0</span> : pointify A =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; f a
    | inr _ =&gt; point X
    <span class="kr">end</span>) <span class="mi">1</span>) o (<span class="kr">fun</span> <span class="nv">f</span> : pointify A -&gt;* X =&gt; f o inl) ==
idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk15"><span class="highlight"><span class="nb">intros</span> f.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pointify A -&gt;* X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Build_pMap (pointify A) X
  (<span class="kr">fun</span> <span class="nv">X0</span> : pointify A =&gt;
   <span class="kr">match</span> X0 <span class="kr">with</span>
   | inl a =&gt; f (inl a)
   | inr _ =&gt; point X
   <span class="kr">end</span>) <span class="mi">1</span> = f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk16"><span class="highlight"><span class="nb">cbv</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pointify A -&gt;* X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
  pointed_fun :=
    <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; f (inl a)
    | inr _ =&gt; ispointed_type X
    <span class="kr">end</span>;
  dpoint_eq := <span class="mi">1</span>
|} = f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk17"><span class="highlight">pointed_reduce.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A + Unit -&gt; X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
  pointed_fun :=
    <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; f (inl a)
    | inr _ =&gt; f (inr tt)
    <span class="kr">end</span>;
  dpoint_eq := <span class="mi">1</span>
|} = {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk18"><span class="highlight">rapply equiv_path_pforall.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A + Unit -&gt; X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
  pointed_fun :=
    <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; f (inl a)
    | inr _ =&gt; f (inr tt)
    <span class="kr">end</span>;
  dpoint_eq := <span class="mi">1</span>
|} ==* {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk19"><span class="highlight">snrapply Build_pHomotopy.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A + Unit -&gt; X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
  pointed_fun :=
    <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
    <span class="kr">match</span> X0 <span class="kr">with</span>
    | inl a =&gt; f (inl a)
    | inr _ =&gt; f (inr tt)
    <span class="kr">end</span>;
  dpoint_eq := <span class="mi">1</span>
|} == {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk1a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A + Unit -&gt; X</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk1a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?p</span>
  (point
     {|
       pointed_type := A + Unit;
       ispointed_type := inr tt
     |}) =
dpoint_eq
  {|
    pointed_fun :=
      <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
      <span class="kr">match</span> X0 <span class="kr">with</span>
      | inl a =&gt; f (inl a)
      | inr _ =&gt; f (inr tt)
      <span class="kr">end</span>;
    dpoint_eq := <span class="mi">1</span>
  |} @
(dpoint_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})^</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk1b"><span class="highlight"><span class="mi">1</span>: <span class="bp">by</span> <span class="nb">intros</span> [a|[]].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A + Unit -&gt; X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   <span class="nv">x</span> : {|
         pointed_type := A + Unit;
         ispointed_type := inr tt
       |} =&gt;
 <span class="kr">match</span>
   x <span class="kr">as</span> s
   <span class="kr">return</span>
     ({|
        pointed_fun :=
          <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
          <span class="kr">match</span> X0 <span class="kr">with</span>
          | inl a =&gt; f (inl a)
          | inr _ =&gt; f (inr tt)
          <span class="kr">end</span>;
        dpoint_eq := <span class="mi">1</span>
      |} s = {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |} s)
 <span class="kr">with</span>
 | inl a =&gt; <span class="mi">1</span>%path
 | inr u =&gt;
     <span class="kr">match</span>
       u <span class="kr">as</span> u0
       <span class="kr">return</span>
         ({|
            pointed_fun :=
              <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
              <span class="kr">match</span> X0 <span class="kr">with</span>
              | inl a =&gt; f (inl a)
              | inr _ =&gt; f (inr tt)
              <span class="kr">end</span>;
            dpoint_eq := <span class="mi">1</span>
          |} (inr u0) =
          {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |}
            (inr u0))
     <span class="kr">with</span>
     | tt =&gt; <span class="mi">1</span>%path
     <span class="kr">end</span>
 <span class="kr">end</span>)
  (point
     {|
       pointed_type := A + Unit;
       ispointed_type := inr tt
     |}) =
dpoint_eq
  {|
    pointed_fun :=
      <span class="kr">fun</span> <span class="nv">X0</span> : A + Unit =&gt;
      <span class="kr">match</span> X0 <span class="kr">with</span>
      | inl a =&gt; f (inl a)
      | inr _ =&gt; f (inr tt)
      <span class="kr">end</span>;
    dpoint_eq := <span class="mi">1</span>
  |} @
(dpoint_eq {| pointed_fun := f; dpoint_eq := <span class="mi">1</span> |})^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We can rephrase the universal property of the free group as a certain precomposition being an equivalence. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk1c"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isfreegroupon_isequiv_postcomp</span> `{Funext} (F : Group) (A : <span class="kt">Type</span>) (i : A -&gt; F)
  : (<span class="kr">forall</span> <span class="nv">G</span>, IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)) -&gt; IsFreeGroupOn A F i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">G</span> : Group, IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)) -&gt;
IsFreeGroupOn A F i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk1d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">G</span> : Group, IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)) -&gt;
IsFreeGroupOn A F i</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk1e"><span class="highlight"><span class="nb">intros</span> k G g.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">G</span> : Group,
IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (FactorsThroughFreeGroup A F i G g)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk1f"><span class="highlight"><span class="nb">specialize</span> (k G).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (FactorsThroughFreeGroup A F i G g)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk20"><span class="highlight">snrapply contr_equiv&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kt">Type</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk21"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?A</span> &lt;~&gt; FactorsThroughFreeGroup A F i G g</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk22"><hr></label><div class="goal-conclusion"><span class="highlight">Contr <span class="nl">?A</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk23"><span class="highlight"><span class="mi">1</span>: <span class="bp">exact</span> (hfiber (<span class="kr">fun</span> <span class="nv">f</span> <span class="nv">x</span> =&gt; grp_homo_map F G f (i x)) g).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber
  (<span class="kr">fun</span> (<span class="nv">f</span> : GroupHomomorphism F G) (<span class="nv">x</span> : A) =&gt; f (i x))
  g &lt;~&gt; FactorsThroughFreeGroup A F i G g</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk24"><hr></label><div class="goal-conclusion"><span class="highlight">Contr
  (hfiber
     (<span class="kr">fun</span> (<span class="nv">f</span> : GroupHomomorphism F G) (<span class="nv">x</span> : A) =&gt;
      f (i x)) g)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk25"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber
  (<span class="kr">fun</span> (<span class="nv">f</span> : GroupHomomorphism F G) (<span class="nv">x</span> : A) =&gt; f (i x))
  g &lt;~&gt; FactorsThroughFreeGroup A F i G g</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk26"><span class="highlight">rapply equiv_functor_sigma_id.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : GroupHomomorphism F G,
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; a (i x)) = g &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; a (i x)) == g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk27"><span class="highlight"><span class="nb">intro</span> y; <span class="nb">symmetry</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism F G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; y (i x)) == g &lt;~&gt;
(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; y (i x)) = g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> equiv_path_forall.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk28"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">F</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; F</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">f</span> : F $-&gt; G =&gt; f o i)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  (hfiber
     (<span class="kr">fun</span> (<span class="nv">f</span> : GroupHomomorphism F G) (<span class="nv">x</span> : A) =&gt;
      f (i x)) g)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">AssumeUnivalence</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> `{Univalence}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We define the free group as the 0-truncation of the loop space of the suspension of S + 1. Or in other words the fundamental group of the suspension of S + 1. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">FreeGroup</span> (<span class="nv">S</span> : <span class="kt">Type</span>) : Group
    := Pi1 (psusp (pointify S)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We can directly prove that it satisfies the desired equivalence. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk29"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">equiv_freegroup_rec</span> (<span class="nv">S</span> : <span class="kt">Type</span>) (<span class="nv">G</span> : Group)
    : (FreeGroup S $-&gt; G) &lt;~&gt; (S -&gt; G).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(FreeGroup S $-&gt; G) &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk2a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(FreeGroup S $-&gt; G) &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk2b"><span class="highlight"><span class="nb">unfold</span> FreeGroup.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(Pi1 (psusp (pointify S)) $-&gt; G) &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="sd">(** The first step is to swap the fundemantal group for the fundemantal group of a truncation. This will be important later. *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk2c"><span class="highlight"><span class="nb">etransitivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(Pi1 (psusp (pointify S)) $-&gt; G) &lt;~&gt; <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk2d"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk2e"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(Pi1 (psusp (pointify S)) $-&gt; G) &lt;~&gt; <span class="nl">?Goal</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk2f"><span class="highlight">srapply equiv_precompose_cat_equiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Group</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk30" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk30"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?x</span> $&lt;~&gt; Pi1 (psusp (pointify S))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk31"><span class="highlight"><span class="mi">1</span>: <span class="bp">exact</span> (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Pi1 (pTr <span class="mi">1</span> (psusp (pointify S))) $&lt;~&gt;
Pi1 (psusp (pointify S))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> grp_iso_pi1_Tr.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk32"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(Pi1 (pTr <span class="mi">1</span> (psusp (pointify S))) $-&gt; G) &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="sd">(** Now we use the equivalence of group homomorphisms and pointed maps between their deloopings. *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk33"><span class="highlight"><span class="nb">etransitivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(Pi1 (pTr <span class="mi">1</span> (psusp (pointify S))) $-&gt; G) &lt;~&gt; <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk34" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk34"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk35"><span class="highlight"><span class="mi">1</span>: rapply equiv_grp_homo_pmap_bg.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(B (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))) -&gt;* B G) &lt;~&gt;
(S -&gt; G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="sd">(** Now since we have the classifying space of a fundamental group, we can change it into the original type. This lemma only works since the truncation is 1-truncated. *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk36"><span class="highlight"><span class="nb">etransitivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(B (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))) -&gt;* B G) &lt;~&gt;
<span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk37" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk37"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk38"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(B (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))) -&gt;* B G) &lt;~&gt;
<span class="nl">?Goal</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk39"><span class="highlight">rapply equiv_pequiv_precompose.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal0</span> &lt;~&gt;* B (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk3a"><span class="highlight"><span class="nb">symmetry</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">B (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))) &lt;~&gt;* <span class="nl">?Goal0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk3b"><span class="highlight">nrapply pequiv_pclassifyingspace_pi1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected (Tr <span class="mi">0</span>) (pTr <span class="mi">1</span> (psusp (pointify S)))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk3c"><hr></label><div class="goal-conclusion"><span class="highlight">IsTrunc <span class="mi">1</span> (pTr <span class="mi">1</span> (psusp (pointify S)))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk3d"><span class="highlight"><span class="mi">2</span>: <span class="bp">exact</span> _.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected (Tr <span class="mi">0</span>) (pTr <span class="mi">1</span> (psusp (pointify S)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk3e"><span class="highlight"><span class="nb">apply</span> isconnected_trunc.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected (Tr <span class="mi">0</span>) (psusp (pointify S))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk3f"><span class="highlight">rapply isconnected_susp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected (Tr (-<span class="mi">1</span>)) (pointify S)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk40"><span class="highlight">rapply contr_inhabited_hprop.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Tr (-<span class="mi">1</span>) (pointify S)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> tr; <span class="bp">exact</span> (point _).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk41"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(pTr <span class="mi">1</span> (psusp (pointify S)) -&gt;* B G) &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="sd">(** We can now get rid of the truncation by the universal property of trucation since BG is 1-truncated. *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk42"><span class="highlight"><span class="nb">etransitivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(pTr <span class="mi">1</span> (psusp (pointify S)) -&gt;* B G) &lt;~&gt; <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk43" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk43"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk44"><span class="highlight"><span class="mi">1</span>: rapply equiv_ptr_rec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(psusp (pointify S) -&gt;* B G) &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="sd">(** Applying the loop-susp adjunction *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk45"><span class="highlight"><span class="nb">etransitivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(psusp (pointify S) -&gt;* B G) &lt;~&gt; <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk46" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk46"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk47"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> loop_susp_adjoint.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(pointify S -&gt;* loops (B G)) &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="sd">(** Now we use the pointed equivalence between a group and the loop space of its delooping *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk48"><span class="highlight"><span class="nb">etransitivity</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(pointify S -&gt;* loops (B G)) &lt;~&gt; <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk49" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk49"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk4a"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(pointify S -&gt;* loops (B G)) &lt;~&gt; <span class="nl">?Goal</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk4b"><span class="highlight">rapply equiv_pequiv_postcompose.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">loops (B G) &lt;~&gt;* <span class="nl">?Goal0</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> pequiv_loops_bg_g.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk4c"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(pointify S -&gt;*
 {|
   pointed_type := G;
   ispointed_type := ispointed_group G
 |}) &lt;~&gt; (S -&gt; G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="sd">(** Finally we use the pointify adjunction. *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> equiv_pointify_map.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We can define the inclusion map by using the previous equivalence on the identity group homomorphism. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk4d"><span class="highlight"><span class="kn">Definition</span> <span class="nf">freegroup_incl</span> (<span class="nv">S</span> : <span class="kt">Type</span>) : S -&gt; FreeGroup S.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S -&gt; FreeGroup S</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk4e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">S -&gt; FreeGroup S</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk4f"><span class="highlight">rapply equiv_freegroup_rec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">FreeGroup S $-&gt; FreeGroup S</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> grp_homo_id.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** This in theory would allow us to prove that this definition of a free group is in fact a free group. We however run into trouble. We have to use [isequiv_homotopic&#39;] since we are not using the specific map that the property of being a free group uses. However showing that these two maps are homotopic seems to be nontrivial. Coq struggles a lot working with the extreme amount of data needed to be unfolded here as well. Therefore we leave this instance as aborted. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk50"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isfreegroupon_freegroup</span> (<span class="nv">S</span> : <span class="kt">Type</span>)
    : IsFreeGroupOn S (FreeGroup S) (freegroup_incl S).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsFreeGroupOn S (FreeGroup S) (freegroup_incl S)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk51"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsFreeGroupOn S (FreeGroup S) (freegroup_incl S)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk52"><span class="highlight"><span class="nb">apply</span> isfreegroupon_isequiv_postcomp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">G</span> : Group,
IsEquiv
  (<span class="kr">fun</span> (<span class="nv">f</span> : FreeGroup S $-&gt; G) (<span class="nv">x</span> : S) =&gt;
   f (freegroup_incl S x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk53"><span class="highlight"><span class="nb">intro</span> G.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv
  (<span class="kr">fun</span> (<span class="nv">f</span> : FreeGroup S $-&gt; G) (<span class="nv">x</span> : S) =&gt;
   f (freegroup_incl S x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk54"><span class="highlight">snrapply isequiv_homotopic&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(FreeGroup S $-&gt; G) &lt;~&gt; (S -&gt; G)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="loopsusp-v-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="loopsusp-v-chk55"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?f</span> ==
(<span class="kr">fun</span> (<span class="nv">f</span> : FreeGroup S $-&gt; G) (<span class="nv">x</span> : S) =&gt;
 f (freegroup_incl S x))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk56"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> equiv_freegroup_rec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_freegroup_rec S G ==
(<span class="kr">fun</span> (<span class="nv">f</span> : FreeGroup S $-&gt; G) (<span class="nv">x</span> : S) =&gt;
 f (freegroup_incl S x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk57"><span class="highlight"><span class="nb">intro</span> f.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FreeGroup S $-&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_freegroup_rec S G f =
(<span class="kr">fun</span> <span class="nv">x</span> : S =&gt; f (freegroup_incl S x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk58"><span class="highlight"><span class="nb">unfold</span> equiv_freegroup_rec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FreeGroup S $-&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_compose
  (equiv_compose
     (equiv_compose
        (equiv_compose
           (equiv_compose
              (equiv_compose
                 (equiv_pointify_map S
                    {|
                      pointed_type := G;
                      ispointed_type :=
                        ispointed_group G
                    |})
                 (equiv_pequiv_postcompose
                    pequiv_loops_bg_g))
              (loop_susp_adjoint (pointify S) (B G)))
           equiv_ptr_rec)
        (equiv_pequiv_precompose
           (pequiv_symmetric
              (B (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))))
              (pTr <span class="mi">1</span> (psusp (pointify S)))
              (pequiv_pclassifyingspace_pi1
                 (pTr <span class="mi">1</span> (psusp (pointify S)))))))
     (equiv_grp_homo_pmap_bg
        (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))) G))
  (equiv_precompose_cat_equiv
     (grp_iso_pi1_Tr (psusp (pointify S)))) f =
(<span class="kr">fun</span> <span class="nv">x</span> : S =&gt; f (freegroup_incl S x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk59"><span class="highlight"><span class="nb">unfold</span> transitive_equiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FreeGroup S $-&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_compose
  (equiv_compose
     (equiv_compose
        (equiv_compose
           (equiv_compose
              (equiv_compose
                 (equiv_pointify_map S
                    {|
                      pointed_type := G;
                      ispointed_type :=
                        ispointed_group G
                    |})
                 (equiv_pequiv_postcompose
                    pequiv_loops_bg_g))
              (loop_susp_adjoint (pointify S) (B G)))
           equiv_ptr_rec)
        (equiv_pequiv_precompose
           (pequiv_symmetric
              (B (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))))
              (pTr <span class="mi">1</span> (psusp (pointify S)))
              (pequiv_pclassifyingspace_pi1
                 (pTr <span class="mi">1</span> (psusp (pointify S)))))))
     (equiv_grp_homo_pmap_bg
        (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))) G))
  (equiv_precompose_cat_equiv
     (grp_iso_pi1_Tr (psusp (pointify S)))) f =
(<span class="kr">fun</span> <span class="nv">x</span> : S =&gt; f (freegroup_incl S x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk5a"><span class="highlight"><span class="nb">unfold</span> equiv_compose.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FreeGroup S $-&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
  equiv_fun :=
    <span class="kr">fun</span> <span class="nv">x</span> : Pi1 (psusp (pointify S)) $-&gt; G =&gt;
    {|
      equiv_fun :=
        <span class="kr">fun</span>
          <span class="nv">x0</span> : Pi1 (pTr <span class="mi">1</span> (psusp (pointify S))) $-&gt; G
        =&gt;
        {|
          equiv_fun :=
            <span class="kr">fun</span>
              <span class="nv">x1</span> : B (Pi1 (pTr <span class="mi">1</span> (psusp (...)))) -&gt;*
                   B G =&gt;
            {|
              equiv_fun :=
                <span class="kr">fun</span> <span class="nv">x2</span> : pTr <span class="mi">1</span> (psusp ...) -&gt;* B G =&gt;
                {|
                  equiv_fun := <span class="kr">fun</span> ... =&gt; ... ...;
                  equiv_isequiv := isequiv_compose
                |} (equiv_ptr_rec x2);
              equiv_isequiv := isequiv_compose
            |}
              (equiv_pequiv_precompose
                 (pequiv_symmetric
                    (B (Pi1 (pTr <span class="mi">1</span> ...)))
                    (pTr <span class="mi">1</span> (psusp (pointify S)))
                    (pequiv_pclassifyingspace_pi1
                       (pTr <span class="mi">1</span> (psusp ...)))) x1);
          equiv_isequiv := isequiv_compose
        |}
          (equiv_grp_homo_pmap_bg
             (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))) G x0);
      equiv_isequiv := isequiv_compose
    |}
      (equiv_precompose_cat_equiv
         (grp_iso_pi1_Tr (psusp (pointify S))) x);
  equiv_isequiv := isequiv_compose
|} f = (<span class="kr">fun</span> <span class="nv">x</span> : S =&gt; f (freegroup_incl S x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="loopsusp-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="loopsusp-v-chk5b"><span class="highlight"><span class="nb">unfold</span> equiv_isequiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">S</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">FreeGroup S $-&gt; G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{|
  equiv_fun :=
    <span class="kr">fun</span> <span class="nv">x</span> : Pi1 (psusp (pointify S)) $-&gt; G =&gt;
    {|
      equiv_fun :=
        <span class="kr">fun</span>
          <span class="nv">x0</span> : Pi1 (pTr <span class="mi">1</span> (psusp (pointify S))) $-&gt; G
        =&gt;
        {|
          equiv_fun :=
            <span class="kr">fun</span>
              <span class="nv">x1</span> : B (Pi1 (pTr <span class="mi">1</span> (psusp (...)))) -&gt;*
                   B G =&gt;
            {|
              equiv_fun :=
                <span class="kr">fun</span> <span class="nv">x2</span> : pTr <span class="mi">1</span> (psusp ...) -&gt;* B G =&gt;
                {|
                  equiv_fun := <span class="kr">fun</span> ... =&gt; ... ...;
                  equiv_isequiv := isequiv_compose
                |} (equiv_ptr_rec x2);
              equiv_isequiv := isequiv_compose
            |}
              (equiv_pequiv_precompose
                 (pequiv_symmetric
                    (B (Pi1 (pTr <span class="mi">1</span> ...)))
                    (pTr <span class="mi">1</span> (psusp (pointify S)))
                    (pequiv_pclassifyingspace_pi1
                       (pTr <span class="mi">1</span> (psusp ...)))) x1);
          equiv_isequiv := isequiv_compose
        |}
          (equiv_grp_homo_pmap_bg
             (Pi1 (pTr <span class="mi">1</span> (psusp (pointify S)))) G x0);
      equiv_isequiv := isequiv_compose
    |}
      (equiv_precompose_cat_equiv
         (grp_iso_pi1_Tr (psusp (pointify S))) x);
  equiv_isequiv := isequiv_compose
|} f = (<span class="kr">fun</span> <span class="nv">x</span> : S =&gt; f (freegroup_incl S x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="sd">(** It&#39;s not obvious how this can be finished. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">AssumeUnivalence</span>.</span></span></span></pre>
</div>
</div></body>
</html>
