<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Overture.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* -*- mode: coq; mode: visual-line -*-  *)</span>

<span class="sd">(** * Basic definitions of homotopy type theory, particularly the groupoid structure of identity types. *)</span>
<span class="sd">(** Import the file of reserved notations so we maintain consistent level notations throughout the library *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Export</span> Basics.Notations Basics.Datatypes Basics.Logic.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Declare ML Module</span> <span class="s2">&quot;number_string_notation_plugin&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Keywords for blacklisting from search function *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Add Search Blacklist</span> <span class="s2">&quot;_admitted&quot;</span> <span class="s2">&quot;_subproof&quot;</span> <span class="s2">&quot;Private_&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Create HintDb</span> <span class="nb">rewrite</span> <span class="kn">discriminated</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export] <span class="kn">Hint Variables Opaque</span> : <span class="nb">rewrite</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Create HintDb</span> typeclass_instances <span class="kn">discriminated</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We disable the [deprecated-hint-rewrite-without-locality] warning until we update to coq V8.14.0 *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Set Warnings</span> Append <span class="s2">&quot;-deprecated-hint-rewrite-without-locality&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Type classes *)</span>

<span class="sd">(** This command prevents Coq from trying to guess the values of existential variables while doing typeclass resolution.  If you don&#39;t know what that means, ignore it. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Set Typeclasses Strict Resolution</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** This command prevents Coq from automatically defining the eliminator functions for inductive types.  We will define them ourselves to match the naming scheme of the HoTT Book.  In principle we ought to make this [Global], but unfortunately the tactics [induction] and [elim] assume that the eliminators are named in Coq&#39;s way, e.g. [thing_rect], so making it global could cause unpleasant surprises for people defining new inductive types.  However, when you do define your own inductive types you are encouraged to also do [Local Unset Elimination Schemes] and then use [Scheme] to define [thing_ind], [thing_rec], and (for compatibility with [induction] and [elim]) [thing_rect], as we have done below for [paths], [Empty], [Unit], etc.  We are hoping that this will be fixed eventually; see https://coq.inria.fr/bugs/show_bug.cgi?id=3745.  *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Unset Elimination Schemes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** This command changes Coq&#39;s subterm selection to always use full conversion after finding a subterm whose head/key matches the key of the term we&#39;re looking for.  This applies to [rewrite] and higher-order unification in [apply]/[elim]/[destruct].  Again, if you don&#39;t know what that means, ignore it. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Set Keyed Unification</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** This command makes it so that you don&#39;t have to declare universes explicitly when mentioning them in the type.  (Without this command, if you want to say [Definition foo := Type@{i}.], you must instead say [Definition foo@{i} := Type@{i}.]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Unset Strict Universe Declaration</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** This command makes it so that when we say something like [IsHSet nat] we get [IsHSet@{i} nat] instead of [IsHSet@{Set} nat]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Unset Universe Minimization ToSet</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Force to use bullets in proofs. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Set Default Goal Selector</span> <span class="s2">&quot;!&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Currently Coq doesn&#39;t print equivalences correctly (8.6). This fixes that. See https://github.com/HoTT/HoTT/issues/1000 *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Set Printing Primitive Projection Parameters</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** This tells Coq that when we [Require] a module without [Import]ing it, typeclass instances defined in that module should also not be imported.  In other words, the only effect of [Require] without [Import] is to make qualified names available. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Set</span> Loose <span class="kn">Hint</span> Behavior <span class="s2">&quot;Strict&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Apply using the same opacity information as typeclass proof search. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">class_apply</span> c := <span class="nb">autoapply</span> c <span class="kr">with</span> typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Relation</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := A -&gt; A -&gt; <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Reflexive</span> {<span class="nv">A</span>} (<span class="nv">R</span> : Relation A) :=
  <span class="bp">reflexivity</span> : <span class="kr">forall</span> <span class="nv">x</span> : A, R x x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> <span class="bp">reflexivity</span> {A R} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Symmetric</span> {<span class="nv">A</span>} (<span class="nv">R</span> : Relation A) :=
  <span class="nb">symmetry</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, R x y -&gt; R y x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> <span class="nb">symmetry</span> {A R _ _}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Transitive</span> {<span class="nv">A</span>} (<span class="nv">R</span> : Relation A) :=
  <span class="nb">transitivity</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, R x y -&gt; R y z -&gt; R x z.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> <span class="nb">transitivity</span> {A R _ _ _}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** A [PreOrder] is both Reflexive and Transitive. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">PreOrder</span> {<span class="nv">A</span>} (<span class="nv">R</span> : Relation A) :=
  { PreOrder_Reflexive : Reflexive R | <span class="mi">2</span> ;
    PreOrder_Transitive : Transitive R | <span class="mi">2</span> }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Instance</span> <span class="nf">PreOrder_Reflexive</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Instance</span> <span class="nf">PreOrder_Transitive</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> <span class="bp">reflexivity</span> {A R _} / _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> <span class="nb">symmetry</span> {A R _} / _ _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> <span class="nb">transitivity</span> {A R _} / {_ _ _} _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Above, we have made [reflexivity], [symmetry], and [transitivity] reduce under [cbn]/[simpl] to their underlying instances.  This allows the tactics to build proof terms referencing, e.g., [concat].  We use [change] after the fact to make sure that we didn&#39;t [cbn] away the original form of the relation.</span>

<span class="sd">    If we want to remove the use of [cbn], we can play tricks with [Module Type]s and [Module]s to declare [inverse] directly as an instance of [Symmetric] without changing its type.  Then we can simply [unfold symmetry].  See the comments around the definition of [inverse]. *)</span>

<span class="sd">(** Overwrite [reflexivity] so that we use our version of [Reflexive] rather than having the tactic look for it in the standard library.  We make use of the built-in reflexivity to handle, e.g., single-constructor inductives. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">old_reflexivity</span> := <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;reflexivity&quot;</span> :=
  old_reflexivity
|| (<span class="nb">intros</span>;
  <span class="kr">let</span> <span class="nv">R</span> := <span class="kr">match goal with</span> |- <span class="nl">?R</span> <span class="nl">?x</span> <span class="nl">?y</span> =&gt; <span class="kp">constr</span>:(R) <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">pre_proof_term_head</span> := <span class="kp">constr</span>:(@<span class="bp">reflexivity</span> _ R _) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">proof_term_head</span> := (<span class="kp">eval</span> <span class="nb">cbn</span> <span class="kr">in</span> pre_proof_term_head) <span class="kr">in</span>
  <span class="nb">apply</span> (proof_term_head : <span class="kr">forall</span> <span class="nv">x</span>, R x x)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Even if we weren&#39;t using [cbn], we would have to redefine symmetry, since the built-in Coq version is sometimes too smart for its own good, and will occasionally fail when it should not. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;symmetry&quot;</span> :=
  <span class="kr">let</span> <span class="nv">R</span> := <span class="kr">match goal with</span> |- <span class="nl">?R</span> <span class="nl">?x</span> <span class="nl">?y</span> =&gt; <span class="kp">constr</span>:(R) <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">x</span> := <span class="kr">match goal with</span> |- <span class="nl">?R</span> <span class="nl">?x</span> <span class="nl">?y</span> =&gt; <span class="kp">constr</span>:(x) <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">y</span> := <span class="kr">match goal with</span> |- <span class="nl">?R</span> <span class="nl">?x</span> <span class="nl">?y</span> =&gt; <span class="kp">constr</span>:(y) <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">pre_proof_term_head</span> := <span class="kp">constr</span>:(@<span class="nb">symmetry</span> _ R _) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">proof_term_head</span> := (<span class="kp">eval</span> <span class="nb">cbn</span> <span class="kr">in</span> pre_proof_term_head) <span class="kr">in</span>
  <span class="nb">refine</span> (proof_term_head y x _); <span class="nb">change</span> (R y x).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;etransitivity&quot;</span> open_constr(y) :=
  <span class="kr">let</span> <span class="nv">R</span> := <span class="kr">match goal with</span> |- <span class="nl">?R</span> <span class="nl">?x</span> <span class="nl">?z</span> =&gt; <span class="kp">constr</span>:(R) <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">x</span> := <span class="kr">match goal with</span> |- <span class="nl">?R</span> <span class="nl">?x</span> <span class="nl">?z</span> =&gt; <span class="kp">constr</span>:(x) <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">z</span> := <span class="kr">match goal with</span> |- <span class="nl">?R</span> <span class="nl">?x</span> <span class="nl">?z</span> =&gt; <span class="kp">constr</span>:(z) <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">pre_proof_term_head</span> := <span class="kp">constr</span>:(@<span class="nb">transitivity</span> _ R _) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">proof_term_head</span> := (<span class="kp">eval</span> <span class="nb">cbn</span> <span class="kr">in</span> pre_proof_term_head) <span class="kr">in</span>
  <span class="nb">refine</span> (proof_term_head x y z _ _); [ <span class="nb">change</span> (R x y) | <span class="nb">change</span> (R y z) ].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;etransitivity&quot;</span> := <span class="nb">etransitivity</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We redefine [transitivity] to work without needing to include [Setoid] or be using Leibniz equality, and to give proofs that unfold to [concat]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;transitivity&quot;</span> <span class="kp">constr</span>(x) := <span class="nb">etransitivity</span> x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Basic definitions *)</span>

<span class="sd">(** Define an alias for [Set], which is really [Type‚ÇÄ]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">Type0</span> := <span class="kt">Set</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Define [Type‚ÇÅ] (really, [Type_i] for any [i &gt; 0]) so that we can enforce having universes that are not [Set].  In trunk, universes will not be unified with [Set] in most places, so we want to never use [Set] at all. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Type1</span>@{i} := <span class="kn">Eval</span> <span class="nb">hnf</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">gt</span> := (<span class="kt">Set</span> : <span class="kt">Type</span>@{i}) <span class="kr">in</span> <span class="kt">Type</span>@{i}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> Type1 / .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Identity Coercion</span> <span class="nf">unfold_Type1</span> : Type1 &gt;-&gt; <span class="kt">Sortclass</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We also define &quot;the next couple of universes&quot;, which are actually an arbitrary universe with another one or two strictly below it.  Note when giving universe annotations to these that their universe parameters appear in order of *decreasing* size. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Type2</span>@{i j} := <span class="kn">Eval</span> <span class="nb">hnf</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">gt</span> := (Type1@{j} : <span class="kt">Type</span>@{i}) <span class="kr">in</span> <span class="kt">Type</span>@{i}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> Type2 / .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Identity Coercion</span> <span class="nf">unfold_Type2</span> : Type2 &gt;-&gt; <span class="kt">Sortclass</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Type3</span>@{i j k} := <span class="kn">Eval</span> <span class="nb">hnf</span> <span class="kr">in</span> <span class="kr">let</span> <span class="nv">gt</span> := (Type2@{j k} : <span class="kt">Type</span>@{i}) <span class="kr">in</span> <span class="kt">Type</span>@{i}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> Type3 / .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Identity Coercion</span> <span class="nf">unfold_Type3</span> : Type3 &gt;-&gt; <span class="kt">Sortclass</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Along the same lines, here is a universe with an extra universe parameter that&#39;s less than or equal to it in size.  The [gt] isn&#39;t necessary to force the larger universe to be bigger than [Set] (since we refer to the smaller universe by [Type1] which is already bigger than [Set]), but we include it anyway to make the universe parameters occur again in (now non-strictly) decreasing order. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Type2le</span>@{i j} :=
  <span class="kn">Eval</span> <span class="nb">hnf</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">gt</span> := (<span class="kt">Set</span> : <span class="kt">Type</span>@{i}) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">ge</span> := ((<span class="kr">fun</span> <span class="nv">x</span> =&gt; x) : Type1@{j} -&gt; <span class="kt">Type</span>@{i}) <span class="kr">in</span>
  <span class="kt">Type</span>@{i}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> Type2le / .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Identity Coercion</span> <span class="nf">unfold_Type2le</span> : Type2le &gt;-&gt; <span class="kt">Sortclass</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Type3le</span>@{i j k} :=
  <span class="kn">Eval</span> <span class="nb">hnf</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">gt</span> := (<span class="kt">Set</span> : <span class="kt">Type</span>@{i}) <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">ge</span> := ((<span class="kr">fun</span> <span class="nv">x</span> =&gt; x) : Type2le@{j k} -&gt; <span class="kt">Type</span>@{i}) <span class="kr">in</span>
  <span class="kt">Type</span>@{i}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> Type3le / .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Identity Coercion</span> <span class="nf">unfold_Type3le</span> : Type3le &gt;-&gt; <span class="kt">Sortclass</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

<span class="sd">(** We make the identity map a notation so we do not have to unfold it,</span>
<span class="sd">    or complicate matters with its type. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">idmap</span> := (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** *** Constant functions *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">const</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">b</span> : B) := <span class="kr">fun</span> <span class="nv">x</span> : A =&gt; b.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Sigma types *)</span>

<span class="sd">(** [(sig A P)], or more suggestively [{x:A &amp; (P x)}] is a Sigma-type. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">sig</span> {<span class="nv">A</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) := exist {
  proj1 : A ;
  proj2 : P proj1 ;
}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">sig_rect</span> := <span class="kn">Induction for</span> sig <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">sig_ind</span> := <span class="kn">Induction for</span> sig <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">sig_rec</span> := <span class="kn">Minimality for</span> sig <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> sig_ind {_ _}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We make the parameters maximally inserted so that we can pass around [pr1] as a function and have it actually mean &quot;first projection&quot; in, e.g., [ap]. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> exist {A}%type P%type _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> proj1 {A P} _ / .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> proj2 {A P} _ / .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> sig (A P)%type.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;{ x | P }&quot;</span> := (sig (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P)) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;{ x : A | P }&quot;</span> := (sig (A := A) (<span class="kr">fun</span> <span class="nv">x</span> =&gt; P)) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;&#39;exists&#39; x .. y , p&quot;</span> := (sig (<span class="kr">fun</span> <span class="nv">x</span> =&gt; .. (sig (<span class="kr">fun</span> <span class="nv">y</span> =&gt; p)) ..)) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;{ x : A  &amp; P }&quot;</span> := (sig (<span class="kr">fun</span> <span class="nv">x</span>:A =&gt; P)) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** This let&#39;s us pattern match sigma types in let expressions *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Add Printing Let</span> sig.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export] <span class="kn">Hint Resolve</span> exist : core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We define notation for dependent pairs because it is too annoying to write and see [exist P x y] all the time.  However, we put it in its own scope, because sometimes it is necessary to give the particular dependent type, so we&#39;d like to be able to turn off this notation selectively. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x ; y )&quot;</span> := (exist _ x y) : fibration_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;( x ; .. ; y ; z )&quot;</span> := (exist _ x .. (exist _ y z) ..) : fibration_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight"><span class="sd">(** We bind [fibration_scope] with [sig] so that we are automatically in [fibration_scope] when we are passing an argument of type [sig]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Bind Scope</span> fibration_scope <span class="kr">with</span> sig.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">pr1</span> := proj1.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">pr2</span> := proj2.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The following notation is very convenient, although it unfortunately clashes with Proof General&#39;s &quot;electric period&quot;.  We have added [format] specifiers in Notations.v so that it will display without an extra space, as [x.1] rather than as [x .1]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x .1&quot;</span> := (pr1 x) : fibration_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x .2&quot;</span> := (pr2 x) : fibration_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">uncurry</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B -&gt; C) (<span class="nv">p</span> : A * B) : C := f (fst p) (snd p).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Composition of functions. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">compose</span> := (<span class="kr">fun</span> <span class="nv">g</span> <span class="nv">f</span> <span class="nv">x</span> =&gt; g (f x)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We put the following notation in a scope because leaving it unscoped causes it to override identical notations in other scopes.  It&#39;s convenient to use the same notation for, e.g., function composition, morphism composition in a category, and functor composition, and let Coq automatically infer which one we mean by scopes.  We can&#39;t do this if this notation isn&#39;t scoped.  Unfortunately, Coq doesn&#39;t have a built-in [function_scope] like [type_scope]; [type_scope] is automatically opened wherever Coq is expecting a [Sort], and it would be nice if [function_scope] were automatically opened whenever Coq expects a thing of type [forall _, _] or [_ -&gt; _].  To work around this, we open [function_scope] globally. *)</span>

<span class="sd">(** We allow writing [(f o g)%function] to force [function_scope] over, e.g., [morphism_scope]. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;g &#39;o&#39; f&quot;</span> := (compose g%function f%function) : function_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** This definition helps guide typeclass inference. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : B -&gt; C) (<span class="nv">f</span> : A -&gt; B) : A -&gt; C := compose g f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Composition of logical equivalences *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">iff_compose</span> : Transitive iff | <span class="mi">1</span>
  := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">f</span> <span class="nv">g</span> =&gt; (fst g o fst f , snd f o snd g).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> iff_compose {A B C} f g : <span class="nb">rename</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** While we&#39;re at it, inverses of logical equivalences *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">iff_inverse</span> : Symmetric iff | <span class="mi">1</span>
  := <span class="kr">fun</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">f</span> =&gt; (snd f , fst f).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> iff_inverse {A B} f : <span class="nb">rename</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** And reflexivity of them *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">iff_reflexive</span> : Reflexive iff | <span class="mi">1</span>
  := <span class="kr">fun</span> <span class="nv">A</span> =&gt; (idmap , idmap).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Dependent composition of functions. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">composeD</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">b</span>, C b) (<span class="nv">f</span> : A -&gt; B) := <span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (f x).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> composeD {A B C}%type_scope (g f)%function_scope x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export] <span class="kn">Hint Unfold</span> composeD : core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;g &#39;oD&#39; f&quot;</span> := (composeD g f) : function_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** The groupoid structure of identity types. *)</span>

<span class="sd">(** The results in this file are used everywhere else, so we need to be extra careful about how we define and prove things.  We prefer hand-written terms, or at least tactics that allow us to retain clear control over the proof-term produced. *)</span>

<span class="sd">(** We define our own identity type, rather than using the one in the Coq standard library, so as to have more control over transitivity, symmetry and inverse.  It seems impossible to change these for the standard eq/identity type (or its Type-valued version) because it breaks various other standard things.  Merely changing notations also doesn&#39;t seem to quite work. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Cumulative</span> <span class="kn">Inductive</span> <span class="nf">paths</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">a</span> : A) : A -&gt; <span class="kt">Type</span> :=
  idpath : paths a a.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> idpath {A a} , [A] a.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">paths_ind</span> := <span class="kn">Induction for</span> paths <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> paths_ind [A] a P f y p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">paths_rec</span> := <span class="kn">Minimality for</span> paths <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> paths_rec [A] a P f y p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> idpath <span class="kr">as</span> core.identity.refl.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* See comment above about the tactic [induction]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">paths_rect</span> := paths_ind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> paths_rect <span class="kr">as</span> core.identity.ind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x = y :&gt; A&quot;</span> := (@paths A x y) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x = y&quot;</span> := (x = y :&gt;_) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Ensure [internal_paths_rew] and [internal_paths_rew_r] are defined outside sections, so they are not unnecessarily polymorphic. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">paths_rew</span> <span class="nv">A</span> <span class="nv">a</span> <span class="nv">y</span> <span class="nv">P</span> (<span class="nv">X</span> : P a) (<span class="nv">H</span> : a = y :&gt; A) : P y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk2"><span class="highlight"><span class="nb">rewrite</span> &lt;- H.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P a</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> X.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk3"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">paths_rew_r</span> <span class="nv">A</span> <span class="nv">a</span> <span class="nv">y</span> <span class="nv">P</span> (<span class="nv">X</span> : P y) (<span class="nv">H</span> : a = y :&gt; A) : P a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P a</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk5"><span class="highlight"><span class="nb">rewrite</span> -&gt; H.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">a = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> X.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> paths <span class="kr">as</span> core.identity.type.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">reflexive_paths</span> {<span class="nv">A</span>} : Reflexive (@paths A) | <span class="mi">0</span> := @idpath A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> reflexive_paths / .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Our identity type is the Paulin-Mohring style.  We derive the Martin-Lof eliminator. *)</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk6"><span class="highlight"><span class="kn">Definition</span> <span class="nf">paths_ind&#39;</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : <span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A), (a = b) -&gt; <span class="kt">Type</span>)
  : (<span class="kr">forall</span> (<span class="nv">a</span> : A), P a a idpath) -&gt; <span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : a = b), P a b p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, a = b -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">a</span> : A, P a a idpath) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : a = b), P a b p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, a = b -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">a</span> : A, P a a idpath) -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : A) (<span class="nv">p</span> : a = b), P a b p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk8"><span class="highlight"><span class="nb">intros</span> H ? ? [].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : A, a = b -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : A, P a a idpath</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P a a idpath</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> H.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** And here&#39;s the &quot;right-sided&quot; Paulin-Mohring eliminator. *)</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk9"><span class="highlight"><span class="kn">Definition</span> <span class="nf">paths_ind_r</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">a</span> : A)
           (<span class="nv">P</span> : <span class="kr">forall</span> <span class="nv">b</span> : A, b = a -&gt; <span class="kt">Type</span>) (<span class="nv">u</span> : P a idpath)
  : <span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">p</span> : y = a), P y p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : A, b = a -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P a idpath</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">p</span> : y = a), P y p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chka"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : A, b = a -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P a idpath</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">y</span> : A) (<span class="nv">p</span> : y = a), P y p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chkb"><span class="highlight"><span class="nb">intros</span> y p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : A, b = a -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P a idpath</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">y = a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P y p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chkc"><span class="highlight"><span class="nb">destruct</span> p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : A, b = y -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">u</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P y idpath</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P y idpath</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> u.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We declare a scope in which we shall place path notations. This way they can be turned on and off by the user. *)</span>

<span class="sd">(** We bind [path_scope] to [paths] so that when we are constructing arguments to things like [concat], we automatically are in [path_scope]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Bind Scope</span> path_scope <span class="kr">with</span> paths.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The inverse of a path. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">inverse</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) : y = x
  := <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; idpath <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> inverse <span class="kr">as</span> core.identity.sym.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Declaring this as [simpl nomatch] prevents the tactic [simpl] from expanding it out into [match] statements.  We only want [inverse] to simplify when applied to an identity path. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> inverse {A x y} p : <span class="nb">simpl</span> nomatch.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">symmetric_paths</span> {<span class="nv">A</span>} : Symmetric (@paths A) | <span class="mi">0</span> := @inverse A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> symmetric_paths / .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** This allows [rewrite] to both in left-to-right and right-to left directions. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">paths_rect_r</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">x</span> : A) (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">p</span> : P x) (<span class="nv">y</span> : A) (<span class="nv">e</span> : paths y x) : P y :=
  paths_rect A x (<span class="kr">fun</span> <span class="nv">y</span> <span class="nv">e</span> =&gt; P y) p y (inverse e).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** If we wanted to not have the constant [symmetric_paths] floating around, and wanted to resolve [inverse] directly, instead, we could play this trick, discovered by Georges Gonthier to fool Coq&#39;s restriction on [Identity Coercion]s:</span>

<span class="sd">&lt;&lt;</span>
<span class="sd">Module Export inverse.</span>
<span class="sd">  Definition inverse {A : Type} {x y : A} (p : x = y) : y = x</span>
<span class="sd">    := match p with idpath =&gt; idpath end.</span>
<span class="sd">End inverse.</span>

<span class="sd">Module Type inverseT.</span>
<span class="sd">  Parameter inverse : forall {A}, Symmetric (@paths A).</span>
<span class="sd">End inverseT.</span>

<span class="sd">Module inverseSymmetric (inverse : inverseT).</span>
<span class="sd">  Global Existing Instance inverse.inverse.</span>
<span class="sd">End inverseSymmetric.</span>

<span class="sd">Module Export symmetric_paths := inverseSymmetric inverse.</span>
<span class="sd">&gt;&gt; *)</span>


<span class="sd">(** We define equality concatenation by destructing on both its arguments, so that it only computes when both arguments are [idpath].  This makes proofs more robust and symmetrical.  Compare with the definition of [identity_trans].  *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">concat</span> {<span class="nv">A</span> : <span class="kt">Type</span>} {<span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">q</span> : y = z) : x = z :=
  <span class="kr">match</span> p, q <span class="kr">with</span> idpath, idpath =&gt; idpath <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** See above for the meaning of [simpl nomatch]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> concat {A x y z} p q : <span class="nb">simpl</span> nomatch.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">transitive_paths</span> {<span class="nv">A</span>} : Transitive (@paths A) | <span class="mi">0</span> := @concat A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> transitive_paths / .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> concat <span class="kr">as</span> core.identity.trans.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Note that you can use the Coq tactics [reflexivity], [transitivity], [etransitivity], and [symmetry] when working with paths; we&#39;ve redefined them above to use typeclasses and to unfold the instances so you get proof terms with [concat] and [inverse]. *)</span>

<span class="sd">(** The identity path. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;1&quot;</span> := idpath : path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The composition of two paths. *)</span>
<span class="sd">(** We put [p] and [q] in [path_scope] explcitly.  This is a partial work-around for https://coq.inria.fr/bugs/show_bug.cgi?id=3990, which is that implicitly bound scopes don&#39;t nest well. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;p @ q&quot;</span> := (concat p%path q%path) : path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The inverse of a path. *)</span>
<span class="sd">(** See above about explicitly placing [p] in [path_scope]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;p ^&quot;</span> := (inverse p%path) : path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** An alternative notation which puts each path on its own line, via the [format] specification in Notations.v.  Useful as a temporary device during proofs of equalities between very long composites; to turn it on inside a section, say [Open Scope long_path_scope]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;p @&#39; q&quot;</span> := (concat p q) : long_path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

<span class="sd">(** An important instance of [paths_ind] is that given any dependent type, one can _transport_ elements of instances of the type along equalities in the base.</span>

<span class="sd">   [transport P p u] transports [u : P x] to [P y] along [p : x = y]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">transport</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y) (<span class="nv">u</span> : P x) : P y :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; u <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** See above for the meaning of [simpl nomatch]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> transport {A}%type_scope P%function_scope {x y} p%path_scope u : <span class="nb">simpl</span> nomatch.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Transport is very common so it is worth introducing a parsing notation for it.  However, we do not use the notation for output because it hides the fibration, and so makes it very hard to read involved transport expression.*)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;p # x&quot;</span> := (transport _ p x) (<span class="kn">only parsing</span>) : path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Having defined transport, we can use it to talk about what a homotopy theorist might see as &quot;paths in a fibration over paths in the base&quot;; and what a type theorist might see as &quot;heterogeneous eqality in a dependent type&quot;.</span>

<span class="sd">We will first see this appearing in the type of [apD]. *)</span>

<span class="sd">(** Functions act on paths: if [f : A -&gt; B] and [p : x = y] is a path in [A], then [ap f p : f x = f y].</span>

<span class="sd">   We typically pronounce [ap] as a single syllable, short for &quot;application&quot;; but it may also be considered as an acronym, &quot;action on paths&quot;. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ap</span> {<span class="nv">A</span> <span class="nv">B</span>:<span class="kt">Type</span>} (<span class="nv">f</span>:A -&gt; B) {<span class="nv">x</span> <span class="nv">y</span>:A} (<span class="nv">p</span>:x = y) : f x = f y
  := <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; idpath <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> ap {A B}%type_scope f%function_scope {x y} p%path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> ap <span class="kr">as</span> core.identity.<span class="nb">congr</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We introduce the convention that [apKN] denotes the application of a K-path between functions to an N-path between elements, where a 0-path is simply a function or an element. Thus, [ap] is a shorthand for [ap01]. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">ap01</span> := ap (<span class="kn">only parsing</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pointwise_paths</span> <span class="nv">A</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span>, P x)
  := <span class="kr">forall</span> <span class="nv">x</span>, f x = g x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">pointwise_paths_concat</span> {<span class="nv">A</span>} {<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> : <span class="kr">forall</span> <span class="nv">x</span>, P x}
  : pointwise_paths A P f g -&gt; pointwise_paths A P g h
    -&gt; pointwise_paths A P f h := <span class="kr">fun</span> <span class="nv">p</span> <span class="nv">q</span> <span class="nv">x</span> =&gt; p x @ q x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chkd"><span class="highlight"><span class="kn">Instance</span> <span class="nf">reflexive_pointwise_paths</span> <span class="nv">A</span> <span class="nv">P</span>
  : Reflexive (pointwise_paths A P).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Reflexive (pointwise_paths A P)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chke"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Reflexive (pointwise_paths A P)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> ? ?; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chkf"><span class="highlight"><span class="kn">Instance</span> <span class="nf">transitive_pointwise_paths</span> <span class="nv">A</span> <span class="nv">P</span>
  : Transitive (pointwise_paths A P).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Transitive (pointwise_paths A P)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk10"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Transitive (pointwise_paths A P)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk11"><span class="highlight"><span class="nb">intros</span> f g h.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g, h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">pointwise_paths A P f g -&gt;
pointwise_paths A P g h -&gt; pointwise_paths A P f h</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> pointwise_paths_concat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk12"><span class="highlight"><span class="kn">Instance</span> <span class="nf">symmetric_pointwise_paths</span> <span class="nv">A</span> <span class="nv">P</span>
  : Symmetric (pointwise_paths A P).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Symmetric (pointwise_paths A P)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk13"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Symmetric (pointwise_paths A P)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> ? ? p ?; <span class="nb">symmetry</span>; <span class="nb">apply</span> p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> pointwise_paths {A}%type_scope {P} (f g)%function_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> reflexive_pointwise_paths /.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> transitive_pointwise_paths /.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> symmetric_pointwise_paths /.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Unfold</span> pointwise_paths : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;f == g&quot;</span> := (pointwise_paths f g) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">apD10</span> {<span class="nv">A</span>} {<span class="nv">B</span>:A-&gt;<span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : <span class="kr">forall</span> <span class="nv">x</span>, B x} (<span class="nv">h</span>:f=g)
  : f == g
  := <span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">match</span> h <span class="kr">with</span> idpath =&gt; <span class="mi">1</span> <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> apD10 {A%type_scope B} {f g}%function_scope h%path_scope _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ap10</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">f</span> <span class="nv">g</span>:A-&gt;B} (<span class="nv">h</span>:f=g) : f == g
  := apD10 h.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> ap10 {A B}%type_scope {f g}%function_scope h%path_scope _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** For the benefit of readers of the HoTT Book: *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">happly</span> := ap10 (<span class="kn">only parsing</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk14"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ap11</span> {<span class="nv">A</span> <span class="nv">B</span>} {<span class="nv">f</span> <span class="nv">g</span>:A-&gt;B} (<span class="nv">h</span>:f=g) {<span class="nv">x</span> <span class="nv">y</span>:A} (<span class="nv">p</span>:x=y) : f x = g y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f = g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f x = g y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="overture-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="overture-v-chk15"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f = g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f x = g y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">case</span> h, p; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> ap11 {A B}%type_scope {f g}%function_scope h%path_scope {x y} p%path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** See above for the meaning of [simpl nomatch]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> ap {A B} f {x y} p : <span class="nb">simpl</span> nomatch.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Similarly, dependent functions act on paths; but the type is a bit more subtle. If [f : forall a:A, B a] and [p : x = y] is a path in [A], then [apD f p] should somehow be a path between [f x : B x] and [f y : B y]. Since these live in different types, we use transport along [p] to make them comparable: [apD f p : p # f x = f y].</span>

<span class="sd">  The type [p # f x = f y] can profitably be considered as a heterogeneous or dependent equality type, of &quot;paths from [f x] to [f y] over [p]&quot;. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">apD</span> {<span class="nv">A</span>:<span class="kt">Type</span>} {<span class="nv">B</span>:A-&gt;<span class="kt">Type</span>} (<span class="nv">f</span>:<span class="kr">forall</span> <span class="nv">a</span>:A, B a) {<span class="nv">x</span> <span class="nv">y</span>:A} (<span class="nv">p</span>:x=y):
  p # (f x) = f y
  :=
  <span class="kr">match</span> p <span class="kr">with</span> idpath =&gt; idpath <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** See above for the meaning of [simpl nomatch]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> apD {A%type_scope B} f%function_scope {x y} p%path_scope : <span class="nb">simpl</span> nomatch.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Equivalences *)</span>

<span class="sd">(** Homotopy equivalences are a central concept in homotopy type theory. Before we define equivalences, let us consider when two types [A] and [B] should be considered &quot;the same&quot;.</span>

<span class="sd">   The first option is to require existence of [f : A -&gt; B] and [g : B -&gt; A] which are inverses of each other, up to homotopy.  Homotopically speaking, we should also require a certain condition on these homotopies, which is one of the triangle identities for adjunctions in category theory.  Thus, we call this notion an *adjoint equivalence*.</span>

<span class="sd">  The other triangle identity is provable from the first one, along with all the higher coherences, so it is reasonable to only assume one of them.  Moreover, as we will see, if we have maps which are inverses up to homotopy, it is always possible to make the triangle identity hold by modifying one of the homotopies.</span>

<span class="sd">   The second option is to use Vladimir Voevodsky&#39;s definition of an equivalence as a map whose homotopy fibers are contractible.  We call this notion a *homotopy bijection*.</span>

<span class="sd">   An interesting third option was suggested by Andr√© Joyal: a map [f] which has separate left and right homotopy inverses.  We call this notion a *homotopy isomorphism*.</span>

<span class="sd">   While the second option was the one used originally, and it is the most concise one, it makes more sense to use the first one in a formalized development, since it exposes most directly equivalence as a structure.  In particular, it is easier to extract directly from it the data of a homotopy inverse to [f], which is what we care about having most in practice.  Thus, adjoint equivalences are what we will refer to merely as *equivalences*. *)</span>

<span class="sd">(** Naming convention: we use [equiv] and [Equiv] systematically to denote types of equivalences, and [isequiv] and [IsEquiv] systematically to denote the assertion that a given map is an equivalence. *)</span>

<span class="sd">(** A typeclass that includes the data making [f] into an adjoint equivalence. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Cumulative</span> <span class="kn">Class</span> <span class="nf">IsEquiv</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) := {
  equiv_inv : B -&gt; A ;
  eisretr : f o equiv_inv == idmap ;
  eissect : equiv_inv o f == idmap ;
  eisadj : <span class="kr">forall</span> <span class="nv">x</span> : A, eisretr (f x) = ap f (eissect x) ;
}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> eisretr {A B}%type_scope f%function_scope {_} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> eissect {A B}%type_scope f%function_scope {_} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> eisadj {A B}%type_scope f%function_scope {_} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> IsEquiv {A B}%type_scope f%function_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We mark [eisadj] as Opaque to deter Coq from unfolding it when simplifying. Since proofs of [eisadj] typically have larger proofs than the rest of the equivalence data, we gain some speed up as a result. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Opaque</span> eisadj.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** A record that includes all the data of an adjoint equivalence. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Cumulative</span> <span class="kn">Record</span> <span class="nf">Equiv</span> <span class="nv">A</span> <span class="nv">B</span> := {
  equiv_fun : A -&gt; B ;
  equiv_isequiv : IsEquiv equiv_fun
}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Coercion</span> <span class="nf">equiv_fun</span> : Equiv &gt;-&gt; <span class="kt">Funclass</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Instance</span> <span class="nf">equiv_isequiv</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> equiv_fun {A B} _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> equiv_isequiv {A B} _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Bind Scope</span> equiv_scope <span class="kr">with</span> Equiv.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;A &lt;~&gt; B&quot;</span> := (Equiv A B) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** A notation for the inverse of an equivalence.  We can apply this to a function as long as there is a typeclass instance asserting it to be an equivalence.  We can also apply it to an element of [A &lt;~&gt; B], since there is an implicit coercion to [A -&gt; B] and also an existing instance of [IsEquiv]. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;f ^-1&quot;</span> := (@equiv_inv _ _ f _) : function_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Applying paths between equivalences like functions *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ap10_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} {<span class="nv">f</span> <span class="nv">g</span> : A &lt;~&gt; B} (<span class="nv">h</span> : f = g) : f == g
  := ap10 (ap equiv_fun h).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Contractibility and truncation levels *)</span>

<span class="sd">(** Truncation measures how complicated a type is.  In this library, a witness that a type is n-truncated is formalized by the [IsTrunc n] typeclass.  In many cases, the typeclass machinery of Coq can automatically infer a witness for a type being n-truncated.  Because [IsTrunc n A] itself has no computational content (that is, all witnesses of n-truncation of a type are provably equal), it does not matter much which witness Coq infers.  Therefore, the primary concerns in making use of the typeclass machinery are coverage (how many goals can be automatically solved) and speed (how long does it take to solve a goal, and how long does it take to error on a goal we cannot automatically solve).  Careful use of typeclass instances and priorities, which determine the order of typeclass resolution, can be used to effectively increase both the coverage and the speed in cases where the goal is solvable.  Unfortunately, typeclass resolution tends to spin for a while before failing unless you&#39;re very, very, very careful.  We currently aim to achieve moderate coverage and fast speed in solvable cases.  How long it takes to fail typeclass resolution is not currently considered, though it would be nice someday to be even more careful about things.</span>

<span class="sd">In order to achieve moderate coverage and speedy resolution, we currently follow the following principles.  They set up a kind of directed flow of information, intended to prevent cycles and potentially infinite chains, which are often the ways that typeclass resolution gets stuck.</span>

<span class="sd">- We prefer to reason about [IsTrunc (S n) A] rather than [IsTrunc n (@paths A a b)].  Whenever we see a statement (or goal) about truncation of paths, we try to turn it into a statement (or goal) about truncation of a (non-[paths]) type.  We do not allow typeclass resolution to go in the reverse direction from [IsTrunc (S n) A] to [forall a b : A, IsTrunc n (a = b)].</span>

<span class="sd">- We prefer to reason about syntactically smaller types.  That is, typeclass instances should turn goals of type [IsTrunc n (forall a : A, P a)] into goals of type [forall a : A, IsTrunc n (P a)]; and goals of type [IsTrunc n (A * B)] into the pair of goals of type [IsTrunc n A] and [IsTrunc n B]; rather than the other way around.  Ideally, we would add similar rules to transform hypotheses in the cases where we can do so.  This rule is not always the one we want, but it seems to heuristically capture the shape of most cases that we want the typeclass machinery to automatically infer.  That is, we often want to infer [IsTrunc n (A * B)] from [IsTrunc n A] and [IsTrunc n B], but we (probably) don&#39;t often need to do other simple things with [IsTrunc n (A * B)] which are broken by that reduction.</span>
<span class="sd">*)</span>

<span class="sd">(** *** Contractibility *)</span>

<span class="sd">(** A space [A] is contractible if there is a point [x : A] and a (pointwise) homotopy connecting the identity on [A] to the constant map at [x].  Thus an element of [contr A] is a pair whose first component is a point [x] and the second component is a pointwise retraction of [A] to [x]. *)</span>

<span class="sd">(** We use the [Contr_internal] record so as not to pollute typeclass search; we only do truncation typeclass search on the [IsTrunc] datatype, usually.  We will define a notation [Contr] which is equivalent to [Contr_internal], but picked up by typeclass search.  However, we must make [Contr_internal] a class so that we pick up typeclasses on [center] and [contr].  However, the only typeclass rule we register is the one that turns it into a [Contr]/[IsTrunc].  Unfortunately, this means that declaring an instance like [Instance contr_foo : Contr foo := { center := bar }.] will fail with mismatched instances/contexts.  Instead, we must iota expand such definitions to get around Coq&#39;s deficiencies, and write [Instance contr_foo : Contr foo := let x := {| center := bar |} in x.] *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Contr_internal</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := Build_Contr {
  center : A ;
  contr : (<span class="kr">forall</span> <span class="nv">y</span> : A, center = y)
}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> center A {_}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** *** Truncation levels *)</span>

<span class="sd">(** Truncation measures how complicated a type is in terms of higher path spaces. The (-2)-truncated types are the contractible ones, whose homotopy is completely trivial. The (n+1)-truncated types are those whose path spaces are n-truncated.</span>

<span class="sd">   Thus, (-1)-truncated means &quot;the space of paths between any two points is contactible&quot;. Such a space is necessarily a sub-singleton: any two points are connected by a path which is unique up to homotopy. In other words, (-1)-truncated spaces are truth values (we call them &quot;propositions&quot;).</span>

<span class="sd">   Next, 0-truncated means &quot;the space of paths between any two points is a sub-singleton&quot;. Thus, two points might not have any paths between them, or they have a unique path. Such a space may have many points but it is discrete in the sense that all paths are trivial. We call such spaces &quot;sets&quot;.</span>
<span class="sd">*)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">trunc_index</span> : <span class="kt">Type</span> :=
| minus_two : trunc_index
| trunc_S : trunc_index -&gt; trunc_index.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">trunc_index_ind</span> := <span class="kn">Induction for</span> trunc_index <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">trunc_index_rec</span> := <span class="kn">Minimality for</span> trunc_index <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* See comment above about the tactic [induction]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">trunc_index_rect</span> := trunc_index_ind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We will use [Notation] for [trunc_index]es, so define a scope for them here. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Bind Scope</span> trunc_scope <span class="kr">with</span> trunc_index.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> trunc_S _%trunc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Include the basic numerals, so we don&#39;t need to go through the coercion from [nat], and so that we get the right binding with [trunc_scope]. *)</span>
<span class="sd">(** Note that putting the negative numbers at level 0 allows us to override the [- _] notation for negative numbers. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;n .+1&quot;</span> := (trunc_S n) : trunc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;n .+2&quot;</span> := (n.+<span class="mi">1</span>.+<span class="mi">1</span>)%trunc : trunc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;n .+3&quot;</span> := (n.+<span class="mi">1</span>.+<span class="mi">2</span>)%trunc : trunc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;n .+4&quot;</span> := (n.+<span class="mi">1</span>.+<span class="mi">3</span>)%trunc : trunc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;n .+5&quot;</span> := (n.+<span class="mi">1</span>.+<span class="mi">4</span>)%trunc : trunc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> trunc_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Further notation for truncation levels is introducted in Trunc.v. *)</span>

<span class="sd">(** n-truncatedness is defined by recursion on [n].  We could simply define [IsTrunc] as a fixpoint and an [Existing Class], but we want to also declare [IsTrunc] to be [simpl nomatch], so that when we say [simpl] or [cbn], [IsTrunc n.+1 A] doesn&#39;t get unfolded to [forall x y:A, IsTrunc n (x = y)].  But we also want to be able to use this equality, e.g. by proving [IsTrunc n.+1 A] starting with [intros x y], and if [IsTrunc] is a fixpoint declared as [simpl nomatch] then that doesn&#39;t work, because [intros] uses [hnf] to expose a [forall] and [hnf] respects [simpl nomatch] on fixpoints.  But we can make it work if we define the fixpoint separately as [IsTrunc_internal] and then take the class [IsTrunc] to be a definitional wrapper around it, since [hnf] is willing to unfold non-fixpoints even if they are defined as [simpl never].  This behavior of [hnf] is arguably questionable (see https://github.com/coq/coq/issues/11619), but it is useful for us here. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">IsTrunc_internal</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">A</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  <span class="kr">match</span> n <span class="kr">with</span>
    | minus_two =&gt; Contr_internal A
    | n&#39;.+<span class="mi">1</span> =&gt; <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A), IsTrunc_internal n&#39; (x = y)
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> IsTrunc_internal n A : <span class="nb">simpl</span> nomatch.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsTrunc</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">A</span> : <span class="kt">Type</span>) : <span class="kt">Type</span> :=
  Trunc_is_trunc : IsTrunc_internal n A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We use the principle that we should always be doing typeclass resolution on truncation of non-equality types.  We try to change the hypotheses and goals so that they never mention something like [IsTrunc n (_ = _)] and instead say [IsTrunc (S n) _].  If you&#39;re evil enough that some of your paths [a = b] are n-truncated, but others are not, then you&#39;ll have to either reason manually or add some (local) hints with higher priority than the hint below, or generalize your equality type so that it&#39;s not a path anymore. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Typeclasses Opaque</span> IsTrunc. <span class="c">(* don&#39;t auto-unfold [IsTrunc] in typeclass search *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> IsTrunc : <span class="nb">simpl</span> never. <span class="c">(* don&#39;t auto-unfold [IsTrunc] with [simpl] *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">istrunc_paths</span> (<span class="nv">A</span> : <span class="kt">Type</span>) <span class="nv">n</span> `{H : IsTrunc n.+<span class="mi">1</span> A} (x y : A)
: IsTrunc n (x = y)
  := H x y. <span class="c">(* but do fold [IsTrunc] *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Class</span> <span class="nf">IsTrunc_internal</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (IsTrunc_internal _ _) =&gt; <span class="kp">progress</span> <span class="nb">change</span> IsTrunc_internal <span class="kr">with</span> IsTrunc <span class="kr">in</span> * : typeclass_instances. <span class="c">(* Also fold [IsTrunc_internal] *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (IsTrunc _ _) =&gt; <span class="kp">progress</span> <span class="nb">change</span> IsTrunc_internal <span class="kr">with</span> IsTrunc <span class="kr">in</span> * : typeclass_instances. <span class="c">(* Also fold [IsTrunc_internal] *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Picking up the [forall x y, IsTrunc n (x = y)] instances in the hypotheses is much tricker.  We could do something evil where we declare an empty typeclass like [IsTruncSimplification] and use the typeclass as a proxy for allowing typeclass machinery to factor nested [forall]s into the [IsTrunc] via backward reasoning on the type of the hypothesis... but, that&#39;s rather complicated, so we instead explicitly list out a few common cases.  It should be clear how to extend the pattern. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">10</span> =&gt;
<span class="kp">progress</span> <span class="kr">match goal with</span>
           | [ H : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : <span class="nl">?T</span>, IsTrunc <span class="nl">?n</span> (x = y) |- _ ]
             =&gt; <span class="nb">change</span> (IsTrunc n.+<span class="mi">1</span> T) <span class="kr">in</span> H
           | [ H : <span class="kr">forall</span> (<span class="nv">a</span> : <span class="nl">?A</span>) (<span class="nv">x</span> <span class="nv">y</span> : @<span class="nl">?T</span> a), IsTrunc <span class="nl">?n</span> (x = y) |- _ ]
             =&gt; <span class="nb">change</span> (<span class="kr">forall</span> <span class="nv">a</span> : A, IsTrunc n.+<span class="mi">1</span> (T a)) <span class="kr">in</span> H; <span class="nb">cbv</span> beta <span class="kr">in</span> H
           | [ H : <span class="kr">forall</span> (<span class="nv">a</span> : <span class="nl">?A</span>) (<span class="nv">b</span> : @<span class="nl">?B</span> a) (<span class="nv">x</span> <span class="nv">y</span> : @<span class="nl">?T</span> a b), IsTrunc <span class="nl">?n</span> (x = y) |- _ ]
             =&gt; <span class="nb">change</span> (<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a), IsTrunc n.+<span class="mi">1</span> (T a b)) <span class="kr">in</span> H; <span class="nb">cbv</span> beta <span class="kr">in</span> H
           | [ H : <span class="kr">forall</span> (<span class="nv">a</span> : <span class="nl">?A</span>) (<span class="nv">b</span> : @<span class="nl">?B</span> a) (<span class="nv">c</span> : @<span class="nl">?C</span> a b) (<span class="nv">x</span> <span class="nv">y</span> : @<span class="nl">?T</span> a b c), IsTrunc <span class="nl">?n</span> (x = y) |- _ ]
             =&gt; <span class="nb">change</span> (<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a) (<span class="nv">c</span> : C a b), IsTrunc n.+<span class="mi">1</span> (T a b c)) <span class="kr">in</span> H; <span class="nb">cbv</span> beta <span class="kr">in</span> H
           | [ H : <span class="kr">forall</span> (<span class="nv">a</span> : <span class="nl">?A</span>) (<span class="nv">b</span> : @<span class="nl">?B</span> a) (<span class="nv">c</span> : @<span class="nl">?C</span> a b) (<span class="nv">d</span> : @<span class="nl">?D</span> a b c) (<span class="nv">x</span> <span class="nv">y</span> : @<span class="nl">?T</span> a b c d), IsTrunc <span class="nl">?n</span> (x = y) |- _ ]
             =&gt; <span class="nb">change</span> (<span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">b</span> : B a) (<span class="nv">c</span> : C a b) (<span class="nv">d</span> : D a b c), IsTrunc n.+<span class="mi">1</span> (T a b c d)) <span class="kr">in</span> H; <span class="nb">cbv</span> beta <span class="kr">in</span> H
         <span class="kr">end</span> : core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">Contr</span> := (IsTrunc minus_two).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">IsHProp</span> := (IsTrunc minus_two.+<span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">IsHSet</span> := (IsTrunc minus_two.+<span class="mi">2</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">0</span> =&gt; <span class="kp">progress</span> <span class="nb">change</span> Contr_internal <span class="kr">with</span> Contr <span class="kr">in</span> * : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** *** Simple induction *)</span>

<span class="sd">(** The following tactic is designed to be more or less interchangeable with [induction n as [ | n&#39; IH ]] whenever [n] is a [nat] or a [trunc_index].  The difference is that it produces proof terms involving [match] and [fix] explicitly rather than [nat_ind] or [trunc_index_ind], and therefore does not introduce higher universe parameters. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">simple_induction</span> n n&#39; IH :=
  <span class="nb">generalize dependent</span> n;
  <span class="kr">fix</span> IH <span class="mi">1</span>;
  <span class="nb">intros</span> [| n&#39;];
  [ <span class="nb">clear</span> IH | <span class="nb">specialize</span> (IH n&#39;) ].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** *** Truncated relations  *)</span>

<span class="sd">(** Hprop-valued relations.  Making this a [Notation] rather than a [Definition] enables typeclass resolution to pick it up easily.  We include the base type [A] in the notation since otherwise e.g. [forall (x y : A) (z : B x y), IsHProp (C x y z)] will get displayed as [forall (x : A), is_mere_relation (C x)].  *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">is_mere_relation</span> A R := (<span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A), IsHProp (R x y)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** *** Function extensionality *)</span>

<span class="sd">(** The function extensionality axiom is formulated as a class. To use it in a theorem, just assume it with [`{Funext}], and then you can use [path_forall], defined below.  If you need function extensionality for a whole development, you can assume it for an entire Section with [Context `{Funext}].  *)</span>
<span class="sd">(** We use a dummy class and an axiom to get universe polymorphism of [Funext] while still tracking its uses.  Coq&#39;s universe polymorphism is parametric; in all definitions, all universes are quantified over before any other variables.  It&#39;s impossible to state a theorem like [(forall i : Level, P i) -&gt; Q] (e.g., &quot;if [C] has all limits of all sizes, then [C] is a preorder&quot; isn&#39;t statable).*  By making [isequiv_apD10] an [Axiom] rather than a per-theorem hypothesis, we can use it at multiple incompatible universe levels.  By only allowing use of the axiom when we have a [Funext] in the context, we can still track what theorems depend on it (because their type will mention [Funext]).</span>

<span class="sd">    By giving [Funext] a field who&#39;s type is an axiom, we guarantee that we cannot construct a fresh instance of [Funext] without [admit]; there&#39;s no term of type [dummy_funext_type] floating around.  If we did not give [Funext] and fields, then we could accidentally manifest a [Funext] using, e.g., [constructor], and then we wouldn&#39;t have a tag on the theorem that did this.</span>

<span class="sd">    As [Funext] is never actually used productively, we toss it in [Type0] and make it [Monomorphic] so it doesn&#39;t add more universes.</span>

<span class="sd">    * That&#39;s not technically true; it might be possible to get non-parametric universe polymorphism using [Module]s and ([Module]) Functors; we can use functors to quantify over a [Module Type] which requires a polymorphic proof of a given hypothesis, and then use that hypothesis polymorphically in any theorem we prove in our new [Module] Functor.  But that is far beyond the scope of this file. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Monomorphic</span> <span class="kn">Axiom</span> <span class="nv">Funext</span> : Type0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Class</span> <span class="nf">Funext</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Axiom</span> <span class="nv">isequiv_apD10</span> : <span class="kr">forall</span> `{Funext} (A : <span class="kt">Type</span>) (P : A -&gt; <span class="kt">Type</span>) f g, IsEquiv (@apD10 A P f g).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Instance</span> <span class="nf">isequiv_apD10</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">path_forall</span> `{Funext} {A : <span class="kt">Type</span>} {P : A -&gt; <span class="kt">Type</span>} (f g : <span class="kr">forall</span> <span class="nv">x</span> : A, P x) :
  f == g -&gt; f = g
  :=
  (@apD10 A P f g)^-<span class="mi">1</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> path_forall {_ A%type_scope P} (f g)%function_scope _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** *** Tactics *)</span>

<span class="sd">(** We declare some more [Hint Resolve] hints, now in the &quot;hint database&quot; [path_hints].  In general various hints (resolve, rewrite, unfold hints) can be grouped into &quot;databases&quot;. This is necessary as sometimes different kinds of hints cannot be mixed, for example because they would cause a combinatorial explosion or rewriting cycles.</span>

<span class="sd">   A specific [Hint Resolve] database [db] can be used with [auto with db].</span>

<span class="sd">   The hints in [path_hints] are designed to push concatenation *outwards*, eliminate identities and inverses, and associate to the left as far as  possible. *)</span>

<span class="sd">(** TODO: think more carefully about this.  Perhaps associating to the right would be more convenient? *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export] <span class="kn">Hint Resolve</span> idpath inverse : path_hints.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export] <span class="kn">Hint Resolve</span> idpath : core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">path_via</span> mid :=
  <span class="nb">apply</span> @concat <span class="kr">with</span> (y := mid); <span class="nb">auto with</span> path_hints.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Natural numbers *)</span>

<span class="sd">(** Unfortunately due to a bug in coq #10766 we the induction tactic fails to work properly. We therefore have to use the autogenerated induction schemes and define the ones we want to use ourselves. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Set Elimination Schemes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(**  Natural numbers. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">nat</span> : <span class="kt">Type</span> :=
| O : nat
| S : nat -&gt; nat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Unset Elimination Schemes</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** These schemes are therefore defined in Spaces.Nat *)</span>
<span class="c">(*</span>
<span class="c">Scheme nat_ind := Induction for nat Sort Type.</span>
<span class="c">Scheme nat_rect := Induction for nat Sort Type.</span>
<span class="c">Scheme nat_rec := Minimality for nat Sort Type.</span>
<span class="c"> *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Declare Scope</span> nat_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Delimit Scope</span> nat_scope <span class="kr">with</span> nat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Bind Scope</span> nat_scope <span class="kr">with</span> nat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> S _%nat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We put [Empty] here, instead of in [Empty.v], because [Ltac done] uses it. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">Empty</span> : Type0 := .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> Empty <span class="kr">as</span> core.<span class="kt">False</span>.type.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">Empty_ind</span> := <span class="kn">Induction for</span> Empty <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">Empty_rec</span> := <span class="kn">Minimality for</span> Empty <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Empty_rect</span> := Empty_ind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">not</span> (<span class="nv">A</span>:<span class="kt">Type</span>) : <span class="kt">Type</span> := A -&gt; Empty.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;~ x&quot;</span> := (not x) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;~~ x&quot;</span> := (~ ~x) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Unfold</span> not: core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &lt;&gt; y  :&gt;  T&quot;</span> := (not (x = y :&gt; T)) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;x &lt;&gt; y&quot;</span> := (x &lt;&gt; y :&gt; _) : type_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">symmetric_neq</span> {<span class="nv">A</span>} {<span class="nv">x</span> <span class="nv">y</span> : A} : x &lt;&gt; y -&gt; y &lt;&gt; x
  := <span class="kr">fun</span> <span class="nv">np</span> <span class="nv">p</span> =&gt; np (p^).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">complement</span> {<span class="nv">A</span>} (<span class="nv">R</span> : Relation A) : Relation A :=
  <span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> =&gt; ~ (R x y).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Typeclasses Opaque</span> complement.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Irreflexive</span> {<span class="nv">A</span>} (<span class="nv">R</span> : Relation A) :=
  irreflexivity : Reflexive (complement R).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">Asymmetric</span> {<span class="nv">A</span>} (<span class="nv">R</span> : Relation A) :=
  asymmetry : <span class="kr">forall</span> {<span class="nv">x</span> <span class="nv">y</span>}, R x y -&gt; (complement R y x : <span class="kt">Type</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Likewise, we put [Unit] here, instead of in [Unit.v], because [Trunc] uses it. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">Unit</span> : Type0 := tt : Unit.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">Unit_ind</span> := <span class="kn">Induction for</span> Unit <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Scheme</span> <span class="nf">Unit_rec</span> := <span class="kn">Minimality for</span> Unit <span class="kn">Sort</span> <span class="kt">Type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Unit_rect</span> := Unit_ind.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** A [Unit] goal should be resolved by [auto] and [trivial]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Resolve</span> tt : core.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> Unit <span class="kr">as</span> core.IDProp.type.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> Unit <span class="kr">as</span> core.<span class="kt">True</span>.type.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> tt <span class="kr">as</span> core.IDProp.idProp.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Register</span> tt <span class="kr">as</span> core.<span class="kt">True</span>.I.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** *** Pointed types *)</span>

<span class="sd">(** A space is pointed if that space has a point. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsPointed</span> (<span class="nv">A</span> : <span class="kt">Type</span>) := point : A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Typeclasses Transparent</span> IsPointed.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> point A {_}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Cumulative</span> <span class="kn">Record</span> <span class="nf">pType</span> :=
  { pointed_type : <span class="kt">Type</span> ;
    ispointed_type : IsPointed pointed_type }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Coercion</span> <span class="nf">pointed_type</span> : pType &gt;-&gt; <span class="kt">Sortclass</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Instance</span> <span class="nf">ispointed_type</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** *** Homotopy fibers *)</span>

<span class="sd">(** Homotopy fibers are homotopical inverse images of points.  *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">y</span> : B) := { x : A &amp; f x = y }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> hfiber {A B}%type_scope f%function_scope y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** *** More tactics *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">easy</span> :=
  <span class="kr">let rec</span> <span class="nv">use_hyp</span> <span class="nv">H</span> :=
    <span class="kr">match</span> <span class="kp">type of</span> H <span class="kr">with</span>
    | _ =&gt; <span class="kp">try</span> <span class="kp">solve</span> [<span class="nb">inversion</span> H]
    <span class="kr">end</span>
  <span class="kr">with</span> do_intro := <span class="kr">let</span> <span class="nv">H</span> := <span class="kp">fresh</span> <span class="kr">in</span> <span class="nb">intro</span> H; use_hyp H
  <span class="kr">with</span> destruct_hyp H := <span class="nb">case</span> H; <span class="nb">clear</span> H; do_intro; do_intro <span class="kr">in</span>
  <span class="kr">let rec</span> <span class="nv">use_hyps</span> :=
    <span class="kr">match goal with</span>
    | H : _ |- _ =&gt; <span class="kp">solve</span> [<span class="nb">inversion</span> H]
    | _ =&gt; <span class="kp">idtac</span>
    <span class="kr">end</span> <span class="kr">in</span>
  <span class="kr">let rec</span> <span class="nv">do_atom</span> :=
    <span class="kp">solve</span> [<span class="bp">reflexivity</span> | <span class="nb">symmetry</span>; <span class="nb">trivial</span>] ||
    <span class="bp">contradiction</span> ||
    (<span class="nb">split</span>; do_atom)
  <span class="kr">with</span> do_ccl := <span class="nb">trivial</span>; <span class="kp">repeat</span> do_intro; do_atom <span class="kr">in</span>
  (use_hyps; do_ccl) || <span class="kp">fail</span> <span class="s2">&quot;Cannot solve this goal&quot;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;now&quot;</span> tactic(t) := t; <span class="bp">easy</span>.</span></span></span></pre>
</div>
</div></body>
</html>
