<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Abelianization.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Basics Types Cubical WildCat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Truncations.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> HIT.Coeq.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Algebra.Groups.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Algebra.AbGroups.AbelianGroup.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** In this file we define what it means for a group homomorphism G -&gt; H into an abelian group H to be an abelianization. We then construct an example of an abelianization. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> mc_mult_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> wc_iso_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Definition of Abelianization.</span>

<span class="sd">  A &quot;unit&quot; homomorphism [eta : G -&gt; G_ab], with [G_ab] abelian, is considered an abelianization if and only if for all homomorphisms [G -&gt; A], where [A] is abelian, there exists a unique [g : G_ab -&gt; A] such that [h == g o eta X].   We express this in funext-free form by saying that precomposition with [eta] in the wild 1-category [Group] induces an equivalence of hom 0-groupoids.</span>

<span class="sd">  Unfortunately, if [eta : GroupHomomorphism G G_ab] and we write [cat_precomp A eta] then Coq is unable to guess that the relevant 1-category is [Group].  Even writing [cat_precomp (A := Group) A eta] isn&#39;t good enough, I guess because the typeclass inference that finds the instance [is01cat_group] doesn&#39;t happen until after the type of [eta] would have to be resolved to a [Hom] in some wild category.  However, with the following auxiliary definition we can force the typeclass inference to happen first.  (It would be worth thinking about whether the design of the wild categories library could be improved to avoid this.)  *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">group_precomp</span> {<span class="nv">a</span> <span class="nv">b</span>} := @cat_precomp Group _ _ a b.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Class</span> <span class="nf">IsAbelianization</span> {<span class="nv">G</span> : Group} (<span class="nv">G_ab</span> : AbGroup)
      (<span class="nv">eta</span> : GroupHomomorphism G G_ab)
  := isequiv0gpd_isabel : <span class="kr">forall</span> (<span class="nv">A</span> : AbGroup),
      IsEquiv0Gpd (group_precomp A eta).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Existing Instance</span> <span class="nf">isequiv0gpd_isabel</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Here we define abelianization as a HIT. Specifically as a set-coequalizer of the following two maps: (a, b, c) |-&gt; a (b c) and (a, b, c) |-&gt; a (c b).</span>

<span class="sd">From this we can show that Abel G is an abelian group.</span>

<span class="sd">In fact this models the following HIT:</span>

<span class="sd">HIT Abel (G : Group) := </span>
<span class="sd"> | ab : G -&gt; Abel G</span>
<span class="sd"> | ab_comm : forall x y z, ab (x * (y * z)) = ab (x * (z * y)).</span>

<span class="sd">We also derive ab and ab_comm from our coequalizer definition, and even prove the induction and computation rules for this HIT.</span>

<span class="sd">This HIT was suggested by Dan Christensen.</span>
<span class="sd">*)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Abel</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** Let G be a group. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">G</span> : Group).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We locally define a map uncurry2 that lets us uncurry A * B * C -&gt; D twice. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk0"><span class="highlight"><span class="kn">Definition</span> <span class="nf">uncurry2</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>}
    : (A -&gt; B -&gt; C -&gt; D) -&gt; A * B * C -&gt; D.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(A -&gt; B -&gt; C -&gt; D) -&gt; A * B * C -&gt; D</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(A -&gt; B -&gt; C -&gt; D) -&gt; A * B * C -&gt; D</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2"><span class="highlight"><span class="nb">intros</span> f [[a b] c].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B -&gt; C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">D</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">apply</span> f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The type Abel is defined to be the set coequalizer of the following maps G^3 -&gt; G. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Abel</span>
    := Tr <span class="mi">0</span> (Coeq
      (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c)))
      (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We have a natural map from G to Abel G. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ab</span> : G -&gt; Abel.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">G -&gt; Abel</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">G -&gt; Abel</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5"><span class="highlight"><span class="nb">intro</span> g.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Abel</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> tr, coeq, g.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** This map satisfies the condition ab_comm. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ab_comm</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span>
    : ab (a * (b * c)) = ab (a * (c * b)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * (b * c)) = ab (a * (c * b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * (b * c)) = ab (a * (c * b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8"><span class="highlight"><span class="nb">apply</span> (ap tr).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a, b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">coeq (a * (b * c)) = coeq (a * (c * b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (cglue (a, b, c)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** It is clear that Abel is a set. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">istrunc_abel</span> : IsHSet Abel := _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We can derive the induction principle from the ones for truncation and the coequalizer. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Abel_ind</span> (<span class="nv">P</span> : Abel -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHSet (P x)} 
    (a : <span class="kr">forall</span> <span class="nv">x</span>, P (ab x)) (c : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, DPath P (ab_comm x y z)
      (a (x * (y * z))) (a (x * (z * y))))
    : <span class="kr">forall</span> (<span class="nv">x</span> : Abel), P x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, P x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, P x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb"><span class="highlight">srapply Trunc_ind.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span>
<span class="nv">a</span> : Coeq (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c)))
      (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b))),
P (tr a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkc"><span class="highlight">srapply Coeq_ind.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : G,
(<span class="kr">fun</span>
   <span class="nv">w</span> : Coeq
         (uncurry2 (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a0 * (b * c)))
         (uncurry2 (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a0 * (c * b)))
 =&gt; P (tr w)) (coeq a)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chkd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chkd"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : G * G * G,
transport
  (<span class="kr">fun</span>
     <span class="nv">w</span> : Coeq
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (b0 * c)))
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (c * b0)))
   =&gt; P (tr w)) (cglue b)
  (<span class="nl">?coeq&#39;</span>
     (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (b0 * c)) b)) =
<span class="nl">?coeq&#39;</span> (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (c * b0)) b)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chke"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : G * G * G,
transport
  (<span class="kr">fun</span>
     <span class="nv">w</span> : Coeq
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (b0 * c)))
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (c * b0)))
   =&gt; P (tr w)) (cglue b)
  (a (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (b0 * c)) b)) =
a (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b0</span> <span class="nv">c</span> : G =&gt; a * (c * b0)) b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkf"><span class="highlight"><span class="nb">intros</span> [[x y] z].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span>
     <span class="nv">w</span> : Coeq
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c)))
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)))
   =&gt; P (tr w)) (cglue (x, y, z))
  (a
     (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c))
        (x, y, z))) =
a (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)) (x, y, z))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk10"><span class="highlight"><span class="nb">refine</span> (transport_compose _ _ _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport P (ap tr (cglue (x, y, z)))
  (a
     (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c))
        (x, y, z))) =
a (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)) (x, y, z))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk11"><span class="highlight">srapply dp_path_transport^-<span class="mi">1</span>%equiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">DPath P (ap tr (cglue (x, y, z)))
  (a
     (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c))
        (x, y, z)))
  (a
     (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b))
        (x, y, z)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> c.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** The computation rule can also be proven. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk12"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Abel_ind_beta_ab_comm</span> (<span class="nv">P</span> : Abel -&gt; <span class="kt">Type</span>)
    `{<span class="kr">forall</span> <span class="nv">x</span>, IsHSet (P x)}(a : <span class="kr">forall</span> <span class="nv">x</span>, P (ab x))
    (c : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, DPath P (ab_comm x y z)
      (a (x * (y * z))) (a (x * (z * y))))
    (x y z : G) : dp_apD (Abel_ind P a c) (ab_comm x y z) = c x y z.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">dp_apD (Abel_ind P a c) (ab_comm x y z) = c x y z</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk13"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">dp_apD (Abel_ind P a c) (ab_comm x y z) = c x y z</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk14"><span class="highlight"><span class="nb">apply</span> dp_apD_path_transport.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">apD (Abel_ind P a c) (ab_comm x y z) =
dp_path_transport^-<span class="mi">1</span> (c x y z)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk15"><span class="highlight"><span class="nb">refine</span> (apD_compose&#39; tr _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(transport_compose P tr (cglue (x, y, z))
   (Abel_ind P a c (tr (coeq (x * (y * z))))))^ @
apD
  (<span class="kr">fun</span>
     <span class="nv">x</span> : Coeq
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c)))
           (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (c * b)))
   =&gt; Abel_ind P a c (tr x)) (cglue (x, y, z)) =
dp_path_transport^-<span class="mi">1</span> (c x y z)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk16"><span class="highlight"><span class="nb">refine</span> (ap _ (Coeq_ind_beta_cglue _ _ _ (x, y, z)) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHSet (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(transport_compose P tr (cglue (x, y, z))
   (Abel_ind P a c (tr (coeq (x * (y * z))))))^ @
(transport_compose P tr (cglue (x, y, z))
   (a
      (uncurry2 (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> : G =&gt; a * (b * c))
         (x, y, z))) @
 (dp_path_transport^-<span class="mi">1</span>)%equiv (c x y z)) =
dp_path_transport^-<span class="mi">1</span> (c x y z)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> concat_V_pp.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We also have a recursion princple. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk17"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Abel_rec</span> (<span class="nv">P</span> : <span class="kt">Type</span>) `{IsHSet P} (a : G -&gt; P)
    (c : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span>, a (x * (y * z)) = a (x * (z * y)))
    : Abel -&gt; P.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G -&gt; P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
a (x * (y * z)) = a (x * (z * y))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Abel -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk18"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G -&gt; P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
a (x * (y * z)) = a (x * (z * y))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Abel -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk19"><span class="highlight"><span class="nb">apply</span> (Abel_ind _ a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHSet0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHSet P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G -&gt; P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
a (x * (y * z)) = a (x * (z * y))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath (<span class="kr">fun</span> <span class="nv">_</span> : Abel =&gt; P) (ab_comm x y z)
  (a (x * (y * z))) (a (x * (z * y)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span>; <span class="nb">apply</span> dp_const, c.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** Here is a simpler version of Abel_ind when our target is an HProp. This lets us discard all the higher paths. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1a"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Abel_ind_hprop</span> (<span class="nv">P</span> : Abel -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, IsHProp (P x)} 
    (a : <span class="kr">forall</span> <span class="nv">x</span>, P (ab x)) : <span class="kr">forall</span> (<span class="nv">x</span> : Abel), P x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHProp (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, P x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHProp (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, P x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1c"><span class="highlight">srapply (Abel_ind _ a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHProp (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
DPath P (ab_comm x y z) (a (x * (y * z)))
  (a (x * (z * y)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1d"><span class="highlight"><span class="nb">intros</span>; <span class="nb">apply</span> dp_path_transport.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel, IsHProp (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : G, P (ab x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport P (ab_comm x y z) (a (x * (y * z))) =
a (x * (z * y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> path_ishprop.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** And its recursion version. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1e"><span class="highlight"><span class="kn">Definition</span> <span class="nf">Abel_rec_hprop</span> (<span class="nv">P</span> : <span class="kt">Type</span>) `{IsHProp P}
    (a : G -&gt; P) : Abel -&gt; P.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHProp0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHProp P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G -&gt; P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Abel -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk1f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHProp0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHProp P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G -&gt; P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Abel -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk20"><span class="highlight"><span class="nb">apply</span> (Abel_rec _ a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IsHProp0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsHProp P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G -&gt; P</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G, a (x * (y * z)) = a (x * (z * y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span>; <span class="nb">apply</span> path_ishprop.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Abel</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The [IsHProp] argument of [Abel_ind_hprop] can usually be found by typeclass resolution, but [srapply] is slow, so we use this tactic instead. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">Abel_ind_hprop</span> x := snrapply Abel_ind_hprop; [<span class="bp">exact</span> _ | <span class="nb">intro</span> x].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We make sure that G is implicit in the arguments of ab and ab_comm. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> ab {_}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> ab_comm {_}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Now we can show that Abel G is in fact an abelian group. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">AbelGroup</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">G</span> : Group).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** Firstly we derive the operation on Abel G. This is defined as follows:</span>
<span class="sd">        ab x + ab y := ab (x y)</span>
<span class="sd">      But we need to also check that it preserves ab_comm in the appropriate way. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk21"><span class="highlight"><span class="kn">Instance</span> <span class="nf">abel_sgop</span> : SgOp (Abel G).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">SgOp (Abel G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk22"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">SgOp (Abel G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk23"><span class="highlight"><span class="nb">intro</span> a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Abel G -&gt; Abel G</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk24"><span class="highlight">srapply Abel_rec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">G -&gt; Abel G</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk25" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chk25"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G, <span class="nl">?a</span> (x * (y * z)) = <span class="nl">?a</span> (x * (z * y))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk26"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">G -&gt; Abel G</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk27"><span class="highlight"><span class="nb">intro</span> b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Abel G</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk28"><span class="highlight"><span class="nb">revert</span> a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Abel G -&gt; Abel G</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk29"><span class="highlight">srapply Abel_rec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">G -&gt; Abel G</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chk2a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G, <span class="nl">?a</span> (x * (y * z)) = <span class="nl">?a</span> (x * (z * y))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2b"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">G -&gt; Abel G</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2c"><span class="highlight"><span class="nb">intro</span> a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Abel G</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (ab (a * b)).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2d"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
(<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; ab (a * b)) (x * (y * z)) =
(<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; ab (a * b)) (x * (z * y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2e"><span class="highlight"><span class="nb">intros</span> a c d; <span class="nb">hnf</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, a, c, d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * (c * d) * b) = ab (a * (d * c) * b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">      <span class="c">(* The pattern seems to be to alternate associativity and ab_comm. *)</span>
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk2f"><span class="highlight"><span class="nb">refine</span> (ap _ (associativity _ _ _)^ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, a, c, d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * (c * d * b)) = ab (a * (d * c) * b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk30"><span class="highlight"><span class="nb">refine</span> (ab_comm _ _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, a, c, d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * (b * (c * d))) = ab (a * (d * c) * b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk31"><span class="highlight"><span class="nb">refine</span> (ap _ (associativity _ _ _) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, a, c, d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * b * (c * d)) = ab (a * (d * c) * b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk32"><span class="highlight"><span class="nb">refine</span> (ab_comm _ _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, a, c, d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * b * (d * c)) = ab (a * (d * c) * b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk33"><span class="highlight"><span class="nb">refine</span> (ap _ (associativity _ _ _)^ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, a, c, d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * (b * (d * c))) = ab (a * (d * c) * b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk34"><span class="highlight"><span class="nb">refine</span> (ab_comm _ _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, a, c, d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * (d * c * b)) = ab (a * (d * c) * b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (ap _ (associativity _ _ _)).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk35"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; ab (a * b))
   (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap ab (associativity a (c * d) b)^ @
    (ab_comm a (c * d) b @
     (ap ab (associativity a b (c * d)) @
      (ab_comm (a * b) c d @
       (ap ab (associativity a b (d * c))^ @
        (ab_comm a b (d * c) @
         ap ab (associativity a (d * c) b))))))) a)
  (x * (y * z)) =
(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; ab (a * b))
   (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap ab (associativity a (c * d) b)^ @
    (ab_comm a (c * d) b @
     (ap ab (associativity a b (c * d)) @
      (ab_comm (a * b) c d @
       (ap ab (associativity a b (d * c))^ @
        (ab_comm a b (d * c) @
         ap ab (associativity a (d * c) b))))))) a)
  (x * (z * y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk36"><span class="highlight"><span class="nb">intros</span> b c d.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; ab (a * b))
   (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap ab (associativity a (c * d) b)^ @
    (ab_comm a (c * d) b @
     (ap ab (associativity a b (c * d)) @
      (ab_comm (a * b) c d @
       (ap ab (associativity a b (d * c))^ @
        (ab_comm a b (d * c) @
         ap ab (associativity a (d * c) b))))))) a)
  (b * (c * d)) =
(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a</span> : G =&gt; ab (a * b))
   (<span class="kr">fun</span> <span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap ab (associativity a (c * d) b)^ @
    (ab_comm a (c * d) b @
     (ap ab (associativity a b (c * d)) @
      (ab_comm (a * b) c d @
       (ap ab (associativity a b (d * c))^ @
        (ab_comm a b (d * c) @
         ap ab (associativity a (d * c) b))))))) a)
  (b * (d * c))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk37"><span class="highlight"><span class="nb">revert</span> a.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, c, d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : Abel G,
(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; ab (a0 * b))
   (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap ab (associativity a0 (c * d) b)^ @
    (ab_comm a0 (c * d) b @
     (ap ab (associativity a0 b (c * d)) @
      (ab_comm (a0 * b) c d @
       (ap ab (associativity a0 b (d * c))^ @
        (ab_comm a0 b (d * c) @
         ap ab (associativity a0 (d * c) b))))))) a)
  (b * (c * d)) =
(<span class="kr">fun</span> <span class="nv">b</span> : G =&gt;
 Abel_rec G (Abel G) (<span class="kr">fun</span> <span class="nv">a0</span> : G =&gt; ab (a0 * b))
   (<span class="kr">fun</span> <span class="nv">a0</span> <span class="nv">c</span> <span class="nv">d</span> : G =&gt;
    ap ab (associativity a0 (c * d) b)^ @
    (ab_comm a0 (c * d) b @
     (ap ab (associativity a0 b (c * d)) @
      (ab_comm (a0 * b) c d @
       (ap ab (associativity a0 b (d * c))^ @
        (ab_comm a0 b (d * c) @
         ap ab (associativity a0 (d * c) b))))))) a)
  (b * (d * c))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk38"><span class="highlight">Abel_ind_hprop a; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, c, d, a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * (b * (c * d))) = ab (a * (b * (d * c)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk39"><span class="highlight"><span class="nb">refine</span> (ap _ (associativity _ _ _) @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, c, d, a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * b * (c * d)) = ab (a * (b * (d * c)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3a"><span class="highlight"><span class="nb">refine</span> (ab_comm _ _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b, c, d, a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (a * b * (d * c)) = ab (a * (b * (d * c)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (ap _ (associativity _ _ _)^).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We can now easily show that this operation is associative by associativity in G and the fact that being associative is a proposition. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3b"><span class="highlight"><span class="kn">Instance</span> <span class="nf">abel_sgop_associative</span> : Associative abel_sgop.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Associative abel_sgop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3c"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Associative abel_sgop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3d"><span class="highlight"><span class="nb">intros</span> x y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : Abel G,
abel_sgop x (abel_sgop y z) =
abel_sgop (abel_sgop x y) z</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3e"><span class="highlight">Abel_ind_hprop z; <span class="nb">revert</span> y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Abel G,
(<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt;
 abel_sgop x (abel_sgop y x0) =
 abel_sgop (abel_sgop x y) x0) (ab z)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk3f"><span class="highlight">Abel_ind_hprop y; <span class="nb">revert</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel G,
(<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt;
 (<span class="kr">fun</span> <span class="nv">x1</span> : Abel G =&gt;
  abel_sgop x (abel_sgop x0 x1) =
  abel_sgop (abel_sgop x x0) x1) (ab z)) (ab y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk40"><span class="highlight">Abel_ind_hprop x; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z, y, x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (x * (y * z)) = ab (x * y * z)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ap, associativity.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** From this we know that Abel G is a semigroup. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">abel_issemigroup</span> : IsSemiGroup (Abel G) := {}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We define the unit as ab of the unit of G *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">abel_mon_unit</span> : MonUnit (Abel G) := ab mon_unit.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** By using Abel_ind_hprop we can prove the left and right identity laws. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk41"><span class="highlight"><span class="kn">Instance</span> <span class="nf">abel_leftidentity</span> : LeftIdentity abel_sgop abel_mon_unit.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">LeftIdentity abel_sgop abel_mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk42"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">LeftIdentity abel_sgop abel_mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk43"><span class="highlight">Abel_ind_hprop x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt; abel_sgop abel_mon_unit x = x)
  (ab x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">cbn</span>; <span class="nb">apply</span> ap, left_identity.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk44"><span class="highlight"><span class="kn">Instance</span> <span class="nf">abel_rightidentity</span> : RightIdentity abel_sgop abel_mon_unit.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">RightIdentity abel_sgop abel_mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk45"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">RightIdentity abel_sgop abel_mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk46"><span class="highlight">Abel_ind_hprop x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt; abel_sgop x abel_mon_unit = x)
  (ab x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">cbn</span>; <span class="nb">apply</span> ap, right_identity.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** Hence Abel G is a monoid *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">ismonoid_abel</span> : IsMonoid (Abel G) := {}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We can also prove that the operation is commutative! This will come in handy later. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk47"><span class="highlight"><span class="kn">Instance</span> <span class="nf">abel_commutative</span> : Commutative abel_sgop.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Commutative abel_sgop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk48"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Commutative abel_sgop</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk49"><span class="highlight"><span class="nb">intro</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : Abel G, abel_sgop x y = abel_sgop y x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4a"><span class="highlight">Abel_ind_hprop y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Abel G</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt; abel_sgop x x0 = abel_sgop x0 x)
  (ab y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4b"><span class="highlight"><span class="nb">revert</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : Abel G,
(<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt; abel_sgop x x0 = abel_sgop x0 x)
  (ab y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4c"><span class="highlight">Abel_ind_hprop x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt;
 (<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt; abel_sgop x x0 = abel_sgop x0 x)
   (ab y)) (ab x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4d"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (x * y) = ab (y * x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4e"><span class="highlight"><span class="nb">refine</span> ((ap ab (left_identity _))^ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (mon_unit * (x * y)) = ab (y * x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk4f"><span class="highlight"><span class="nb">refine</span> (_ @ (ap ab (left_identity _))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (mon_unit * (x * y)) = ab (mon_unit * (y * x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ab_comm.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** Now we can define the negation. This is just</span>
<span class="sd">        - (ab g) := (ab (g^-1))</span>
<span class="sd">      However when checking that it respects ab_comm we have to show the following:</span>
<span class="sd">        ab (- z * - y * - x) = ab (- y * - z * - x)</span>
<span class="sd">      there is no obvious way to do this, but we note that ab (x * y) is exactly the definition of ab x + ab y! Hence by commutativity we can show this. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk50"><span class="highlight"><span class="kn">Instance</span> <span class="nf">abel_negate</span> : Negate (Abel G).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Negate (Abel G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk51"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Negate (Abel G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk52"><span class="highlight">srapply Abel_rec.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">G -&gt; Abel G</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chk53"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G, <span class="nl">?a</span> (x * (y * z)) = <span class="nl">?a</span> (x * (z * y))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk54"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">G -&gt; Abel G</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk55"><span class="highlight"><span class="nb">intro</span> g.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Abel G</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (ab (-g)).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk56"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G,
(<span class="kr">fun</span> <span class="nv">g</span> : G =&gt; ab (- g)) (x * (y * z)) =
(<span class="kr">fun</span> <span class="nv">g</span> : G =&gt; ab (- g)) (x * (z * y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk57"><span class="highlight"><span class="nb">intros</span> x y z; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (- (x * (y * z))) = ab (- (x * (z * y)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk58"><span class="highlight"><span class="nb">rewrite</span> <span class="nl">?negate_sg_op</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (- z * - y * - x) = ab (- y * - z * - x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk59"><span class="highlight"><span class="nb">change</span> (ab(- z) * ab(- y) * ab (- x) = ab (- y) * ab (- z) * ab(- x)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab (- z) * ab (- y) * ab (- x) =
ab (- y) * ab (- z) * ab (- x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> (commutativity (ab (-z)) (ab (-y))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** Again by Abel_ind_hprop and the corresponding laws for G we can prove the left and right inverse laws. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5a"><span class="highlight"><span class="kn">Instance</span> <span class="nf">abel_leftinverse</span> : LeftInverse abel_sgop abel_negate abel_mon_unit.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">LeftInverse abel_sgop abel_negate abel_mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">LeftInverse abel_sgop abel_negate abel_mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5c"><span class="highlight">Abel_ind_hprop x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt;
 abel_sgop (abel_negate x) x = abel_mon_unit) (ab x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">cbn</span>; <span class="nb">apply</span> ap; <span class="nb">apply</span> left_inverse.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5d"><span class="highlight"><span class="kn">Instance</span> <span class="nf">abel_rightinverse</span> : RightInverse abel_sgop abel_negate abel_mon_unit.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">RightInverse abel_sgop abel_negate abel_mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">RightInverse abel_sgop abel_negate abel_mon_unit</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk5f"><span class="highlight">Abel_ind_hprop x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt;
 abel_sgop x (abel_negate x) = abel_mon_unit) (ab x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">cbn</span>; <span class="nb">apply</span> ap; <span class="nb">apply</span> right_inverse.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** Thus Abel G is a group *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isgroup_abel</span> : IsGroup (Abel G) := {}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** And since the operation is commutative, an abelian group. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isabgroup_abel</span> : IsAbGroup (Abel G) := {}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** By definition, the map ab is also a group homomorphism. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk60"><span class="highlight"><span class="kn">Instance</span> <span class="nf">issemigrouppreserving_ab</span> : IsSemiGroupPreserving ab.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsSemiGroupPreserving ab</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk61"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsSemiGroupPreserving ab</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">unfold</span> IsSemiGroupPreserving.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">AbelGroup</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We can easily prove that ab is a surjection. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk62"><span class="highlight"><span class="kn">Instance</span> <span class="nf">issurj_ab</span> {<span class="nv">G</span> : Group} : IsSurjection (@ab G).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>)) ab</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk63"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>)) ab</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk64"><span class="highlight"><span class="nb">apply</span> BuildIsSurjection.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : Abel G, merely (hfiber ab b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk65"><span class="highlight">Abel_ind_hprop x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt;
 trunctype_type (merely (hfiber ab x))) (ab x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk66"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Trunc (-<span class="mi">1</span>) (hfiber ab (ab x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk67"><span class="highlight"><span class="nb">apply</span> tr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber ab (ab x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk68"><span class="highlight"><span class="kr">exists</span> <span class="nv">x</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ab x = ab x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Now we finally check that our definition of abelianization satisfies the universal property of being an abelianization. *)</span>

<span class="sd">(** We define abel to be the abelianization of a group. This is a map from Group to AbGroup. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk69"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abel</span> : Group -&gt; AbGroup.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Group -&gt; AbGroup</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Group -&gt; AbGroup</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6b"><span class="highlight"><span class="nb">intro</span> G.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">AbGroup</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6c"><span class="highlight">snrapply Build_AbGroup.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Group</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk6d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chk6d"><hr></label><div class="goal-conclusion"><span class="highlight">Commutative group_sgop</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6e"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Group</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply (Build_Group (Abel G)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk6f"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Commutative group_sgop</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The unit of this map is the map ab which typeclasses can pick up to be a homomorphism. We write it out explicitly here. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk70"><span class="highlight"><span class="kn">Definition</span> <span class="nf">abel_unit</span> (<span class="nv">X</span> : Group)
  : GroupHomomorphism X (abel X).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">GroupHomomorphism X (abel X)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk71"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">GroupHomomorphism X (abel X)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk72"><span class="highlight">snrapply @Build_GroupHomomorphism.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">X -&gt; abel X</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk73" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chk73"><hr></label><div class="goal-conclusion"><span class="highlight">IsSemiGroupPreserving <span class="nl">?f</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk74"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">X -&gt; abel X</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> ab.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk75"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsSemiGroupPreserving ab</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Finally we can prove that our construction abel is an abelianization. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk76"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isabelianization_abel</span> {<span class="nv">G</span> : Group}
  : IsAbelianization (abel G) (abel_unit G).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsAbelianization (abel G) (abel_unit G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk77"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsAbelianization (abel G) (abel_unit G)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk78"><span class="highlight"><span class="nb">intros</span> A.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv0Gpd (group_precomp A (abel_unit G))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk79"><span class="highlight"><span class="nb">constructor</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">SplEssSurj (group_precomp A (abel_unit G))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk7a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chk7a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : abel G $-&gt; A,
group_precomp A (abel_unit G) x $==
group_precomp A (abel_unit G) y -&gt; x $== y</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7b"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">SplEssSurj (group_precomp A (abel_unit G))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7c"><span class="highlight"><span class="nb">intros</span> h.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{a : abel G $-&gt; A &amp;
group_precomp A (abel_unit G) a $== h}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7d"><span class="highlight">srefine (_;_).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abel G $-&gt; A</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk7e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chk7e"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">a</span> : abel G $-&gt; A =&gt;
 group_precomp A (abel_unit G) a $== h) <span class="nl">?proj1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk7f"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abel G $-&gt; A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk80"><span class="highlight">snrapply @Build_GroupHomomorphism.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abel G -&gt; A</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk81" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chk81"><hr></label><div class="goal-conclusion"><span class="highlight">IsSemiGroupPreserving <span class="nl">?f</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk82"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">abel G -&gt; A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk83"><span class="highlight">srapply (Abel_rec _ _ h).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G, h (x * (y * z)) = h (x * (z * y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk84"><span class="highlight"><span class="nb">intros</span> x y z.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">h (x * (y * z)) = h (x * (z * y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk85"><span class="highlight"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _ @ (grp_homo_op _ _ _)^).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">h x * h (y * z) = h x * h (z * y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk86"><span class="highlight"><span class="nb">apply</span> (ap (_ *.)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">h (y * z) = h (z * y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk87"><span class="highlight"><span class="nb">refine</span> (grp_homo_op _ _ _ @ _ @ (grp_homo_op _ _ _)^).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">h y * h z = h z * h y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> commutativity.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk88"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsSemiGroupPreserving
  (Abel_rec G A h
     (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
      (grp_homo_op h x (y * z) @
       ap (sg_op (h x))
         ((grp_homo_op h y z @
           commutativity (h y) (h z)) @
          (grp_homo_op h z y)^)) @
      (grp_homo_op h x (z * y))^))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk89"><span class="highlight"><span class="nb">intros</span> y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abel G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y0</span> : abel G,
Abel_rec G A h
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
   (grp_homo_op h x (y * z) @
    ap (sg_op (h x))
      ((grp_homo_op h y z @ commutativity (h y) (h z)) @
       (grp_homo_op h z y)^)) @
   (grp_homo_op h x (z * y))^) (y * y0) =
Abel_rec G A h
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
   (grp_homo_op h x (y * z) @
    ap (sg_op (h x))
      ((grp_homo_op h y z @ commutativity (h y) (h z)) @
       (grp_homo_op h z y)^)) @
   (grp_homo_op h x (z * y))^) y *
Abel_rec G A h
  (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
   (grp_homo_op h x (y * z) @
    ap (sg_op (h x))
      ((grp_homo_op h y z @ commutativity (h y) (h z)) @
       (grp_homo_op h z y)^)) @
   (grp_homo_op h x (z * y))^) y0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8a"><span class="highlight">Abel_ind_hprop x; <span class="nb">revert</span> y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : abel G,
(<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt;
 Abel_rec G A h
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">z</span> : G =&gt;
    (grp_homo_op h x0 (y0 * z) @
     ap (sg_op (h x0))
       ((grp_homo_op h y0 z @
         commutativity (h y0) (h z)) @
        (grp_homo_op h z y0)^)) @
    (grp_homo_op h x0 (z * y0))^) (y * x) =
 Abel_rec G A h
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">z</span> : G =&gt;
    (grp_homo_op h x0 (y0 * z) @
     ap (sg_op (h x0))
       ((grp_homo_op h y0 z @
         commutativity (h y0) (h z)) @
        (grp_homo_op h z y0)^)) @
    (grp_homo_op h x0 (z * y0))^) y *
 Abel_rec G A h
   (<span class="kr">fun</span> <span class="nv">x0</span> <span class="nv">y0</span> <span class="nv">z</span> : G =&gt;
    (grp_homo_op h x0 (y0 * z) @
     ap (sg_op (h x0))
       ((grp_homo_op h y0 z @
         commutativity (h y0) (h z)) @
        (grp_homo_op h z y0)^)) @
    (grp_homo_op h x0 (z * y0))^) x) (ab x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8b"><span class="highlight">Abel_ind_hprop y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x0</span> : Abel G =&gt;
 (<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt;
  Abel_rec G A h
    (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
     (grp_homo_op h x1 (y * z) @
      ap (sg_op (h x1))
        ((grp_homo_op h y z @
          commutativity (h y) (h z)) @
         (grp_homo_op h z y)^)) @
     (grp_homo_op h x1 (z * y))^) (x0 * x) =
  Abel_rec G A h
    (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
     (grp_homo_op h x1 (y * z) @
      ap (sg_op (h x1))
        ((grp_homo_op h y z @
          commutativity (h y) (h z)) @
         (grp_homo_op h z y)^)) @
     (grp_homo_op h x1 (z * y))^) x0 *
  Abel_rec G A h
    (<span class="kr">fun</span> <span class="nv">x1</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
     (grp_homo_op h x1 (y * z) @
      ap (sg_op (h x1))
        ((grp_homo_op h y z @
          commutativity (h y) (h z)) @
         (grp_homo_op h z y)^)) @
     (grp_homo_op h x1 (z * y))^) x) (ab x)) (ab y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> grp_homo_op.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8c"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">a</span> : abel G $-&gt; A =&gt;
 group_precomp A (abel_unit G) a $== h)
  (Build_GroupHomomorphism
     (Abel_rec G A h
        (<span class="kr">fun</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> : G =&gt;
         (grp_homo_op h x (y * z) @
          ap (sg_op (h x))
            ((grp_homo_op h y z @
              commutativity (h y) (h z)) @
             (grp_homo_op h z y)^)) @
         (grp_homo_op h x (z * y))^)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8d"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G $-&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; h x) == h</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8e"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : abel G $-&gt; A,
group_precomp A (abel_unit G) x $==
group_precomp A (abel_unit G) y -&gt; x $== y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk8f"><span class="highlight"><span class="nb">intros</span> g h p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g, h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abel G $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A (abel_unit G) g $==
group_precomp A (abel_unit G) h</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">g $== h</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk90"><span class="highlight">Abel_ind_hprop x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g, h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abel G $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A (abel_unit G) g $==
group_precomp A (abel_unit G) h</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : Abel G =&gt; g x = h x) (ab x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (p x).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk91"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">groupiso_isabelianization</span> {<span class="nv">G</span> : Group}
  (<span class="nv">A</span> <span class="nv">B</span> : AbGroup)
  (<span class="nv">eta1</span> : GroupHomomorphism G A)
  (<span class="nv">eta2</span> : GroupHomomorphism G B)
  {<span class="nv">isab1</span> : IsAbelianization A eta1}
  {<span class="nv">isab2</span> : IsAbelianization B eta2}
  : A ‚âÖ B.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A ‚âÖ B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk92"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A ‚âÖ B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk93"><span class="highlight"><span class="nb">destruct</span> (esssurj (group_precomp B eta1) eta2) <span class="kr">as</span> [a ac].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp B eta1 a $== eta2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A ‚âÖ B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk94"><span class="highlight"><span class="nb">destruct</span> (esssurj (group_precomp A eta2) eta1) <span class="kr">as</span> [b bc].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp B eta1 a $== eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A eta2 b $== eta1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A ‚âÖ B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk95"><span class="highlight">srapply (Build_GroupIsomorphism _ _ a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp B eta1 a $== eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A eta2 b $== eta1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk96"><span class="highlight">srapply (isequiv_adjointify _ b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp B eta1 a $== eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A eta2 b $== eta1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a o b == idmap</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chk97" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp B eta1 a $== eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A eta2 b $== eta1</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chk97"><hr></label><div class="goal-conclusion"><span class="highlight">b o a == idmap</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk98"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp B eta1 a $== eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A eta2 b $== eta1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a o b == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk99"><span class="highlight"><span class="nb">refine</span> (essinj0 (group_precomp B eta2)
                    (x := a $o b) (y := Id (A := Group) B) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp B eta1 a $== eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A eta2 b $== eta1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">group_precomp B eta2 (a $o b) $==
group_precomp B eta2 (Id B)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9a"><span class="highlight"><span class="nb">intros</span> x; <span class="nb">cbn</span> <span class="kr">in</span> *.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; a (eta1 x)) == eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism B A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; b (eta2 x)) == eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a (b (eta2 x)) = eta2 x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9b"><span class="highlight"><span class="nb">refine</span> (_ @ ac x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; a (eta1 x)) == eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism B A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; b (eta2 x)) == eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">a (b (eta2 x)) = a (eta1 x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ap, bc.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9c"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp B eta1 a $== eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A eta2 b $== eta1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b o a == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9d"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp B eta1 a $== eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A eta2 b $== eta1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b o a == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9e"><span class="highlight"><span class="nb">refine</span> (essinj0 (group_precomp A eta1)
                    (x := b $o a) (y := Id (A := Group) A) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A $-&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp B eta1 a $== eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B $-&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">group_precomp A eta2 b $== eta1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">group_precomp A eta1 (b $o a) $==
group_precomp A eta1 (Id A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chk9f"><span class="highlight"><span class="nb">intros</span> x; <span class="nb">cbn</span> <span class="kr">in</span> *.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; a (eta1 x)) == eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism B A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; b (eta2 x)) == eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b (a (eta1 x)) = eta1 x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka0"><span class="highlight"><span class="nb">refine</span> (_ @ bc x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; a (eta1 x)) == eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism B A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : G =&gt; b (eta2 x)) == eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b (a (eta1 x)) = b (eta2 x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ap, ac.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">}</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka1"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">homotopic_isabelianization</span> {<span class="nv">G</span> : Group} (<span class="nv">A</span> <span class="nv">B</span> : AbGroup)
  (<span class="nv">eta1</span> : GroupHomomorphism G A) (<span class="nv">eta2</span> : GroupHomomorphism G B)
  {<span class="nv">isab1</span> : IsAbelianization A eta1} {<span class="nv">isab2</span> : IsAbelianization B eta2}
  : eta2 == grp_homo_compose (groupiso_isabelianization A B eta1 eta2) eta1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eta2 ==
grp_homo_compose
  (groupiso_isabelianization A B eta1 eta2) eta1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eta2 ==
grp_homo_compose
  (groupiso_isabelianization A B eta1 eta2) eta1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka3"><span class="highlight"><span class="nb">intros</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta1</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta2</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">G</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eta2 x =
grp_homo_compose
  (groupiso_isabelianization A B eta1 eta2) eta1 x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (((esssurj (group_precomp B eta1) eta2).<span class="mi">2</span> x)^).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Hence any abelianization is surjective. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka4"><span class="highlight"><span class="kn">Instance</span> <span class="nf">issurj_isabelianization</span> {<span class="nv">G</span> : Group}
  (<span class="nv">A</span> : AbGroup) (<span class="nv">eta</span> : GroupHomomorphism G A)
  : IsAbelianization A eta -&gt; IsSurjection eta.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsAbelianization A eta -&gt; IsConnMap (Tr (-<span class="mi">1</span>)) eta</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka5"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsAbelianization A eta -&gt; IsConnMap (Tr (-<span class="mi">1</span>)) eta</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka6"><span class="highlight"><span class="nb">intros</span> k.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>)) eta</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka7"><span class="highlight"><span class="nb">pose</span> (homotopic_isabelianization A (abel G) eta (abel_unit G)) <span class="kr">as</span> p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">G</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Group</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism G A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization A eta</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">homotopic_isabelianization A (abel G) eta
  (abel_unit G)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">abel_unit G ==
grp_homo_compose
  (groupiso_isabelianization A (abel G) eta
     (abel_unit G)) eta</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap (Tr (-<span class="mi">1</span>)) eta</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (@cancelR_isequiv_conn_map _ _ _ _ _ _ _
    (conn_map_homotopic _ _ _ p _)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka8"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isabelianization_identity</span> (<span class="nv">A</span> : AbGroup) : IsAbelianization A grp_homo_id.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsAbelianization A grp_homo_id</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chka9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsAbelianization A grp_homo_id</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkaa"><span class="highlight"><span class="nb">intros</span> B.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv0Gpd (group_precomp B grp_homo_id)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkab"><span class="highlight"><span class="nb">constructor</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">SplEssSurj (group_precomp B grp_homo_id)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chkac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chkac"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A $-&gt; B,
group_precomp B grp_homo_id x $==
group_precomp B grp_homo_id y -&gt; x $== y</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkad"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">SplEssSurj (group_precomp B grp_homo_id)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> h; <span class="bp">exact</span> (h ; <span class="kr">fun</span> <span class="nv">_</span> =&gt; idpath).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkae"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A $-&gt; B,
group_precomp B grp_homo_id x $==
group_precomp B grp_homo_id y -&gt; x $== y</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> g h p; <span class="bp">exact</span> p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkaf"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_abgroup_abelianization</span>
  (<span class="nv">A</span> <span class="nv">B</span> : AbGroup) (<span class="nv">eta</span> : GroupHomomorphism A B) {<span class="nv">isab</span> : IsAbelianization B eta}
  : IsEquiv eta.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv eta</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb0"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv eta</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb1"><span class="highlight">srapply isequiv_homotopic.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A -&gt; B</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="abelianization-v-chkb2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chkb2"><hr></label><div class="goal-conclusion"><span class="highlight">IsEquiv <span class="nl">?f</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="abelianization-v-chkb3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="abelianization-v-chkb3"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?f</span> == eta</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb4"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A -&gt; B</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">srapply (groupiso_isabelianization A B grp_homo_id eta).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb5"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv
  (groupiso_isabelianization A B grp_homo_id eta)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="abelianization-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="abelianization-v-chkb6"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">AbGroup</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eta</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">GroupHomomorphism A B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAbelianization B eta</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">groupiso_isabelianization A B grp_homo_id eta == eta</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">symmetry</span>; <span class="nb">apply</span> homotopic_isabelianization.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span></span></pre>
</div>
</div></body>
</html>
