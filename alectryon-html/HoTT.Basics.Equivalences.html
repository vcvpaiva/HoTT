<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Equivalences.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* -*- mode: coq; mode: visual-line -*- *)</span>
<span class="sd">(** * Equivalences *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span>
  Basics.Overture
  Basics.PathGroupoids
  Basics.Notations
  Basics.Contractible
  Basics.Tactics.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We now give many ways to construct equivalences.  In each case, we define an instance of the typeclass [IsEquiv] named [isequiv_X], followed by an element of the record type [Equiv] named [equiv_X].</span>

<span class="sd">   Whenever we need to assume, as a hypothesis, that a certain function is an equivalence, we do it by assuming separately a function and a proof of [IsEquiv].  This is more general than assuming an inhabitant of [Equiv], since the latter has an implicit coercion and an existing instance to give us the former automatically.  Moreover, implicit generalization makes it easy to assume a function and a proof of [IsEquiv]. *)</span>

<span class="sd">(** A word on naming: some of the lemmas about equivalences are analogues of those for paths in PathGroupoids.  We name them in an analogous way but adding [_equiv] in an appropriate place, e.g. instead of [moveR_M] we have [moveR_equiv_M].  *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Generalizable Variables</span> <span class="nf">A</span> B C f g.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The identity map is an equivalence. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_idmap</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : IsEquiv idmap | <span class="mi">0</span> :=
  Build_IsEquiv A A idmap idmap (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_idmap</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : A &lt;~&gt; A := Build_Equiv A A idmap _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> equiv_idmap {A} , A.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;1&quot;</span> := equiv_idmap : equiv_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">reflexive_equiv</span> : Reflexive Equiv | <span class="mi">0</span> := @equiv_idmap.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> reflexive_equiv /.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The composition of equivalences is an equivalence. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_compose</span> `{IsEquiv A B f} `{IsEquiv B C g}
  : IsEquiv (compose g f) | <span class="mi">1000</span>
  := Build_IsEquiv A C (compose g f)
    (compose f^-<span class="mi">1</span> g^-<span class="mi">1</span>)
    (<span class="kr">fun</span> <span class="nv">c</span> =&gt; ap g (eisretr f (g^-<span class="mi">1</span> c)) @ eisretr g c)
    (<span class="kr">fun</span> <span class="nv">a</span> =&gt; ap (f^-<span class="mi">1</span>) (eissect g (f a)) @ eissect f a)
    (<span class="kr">fun</span> <span class="nv">a</span> =&gt;
      (whiskerL _ (eisadj g (f a))) @
      (ap_pp g _ _)^ @
      ap02 g
      ( (concat_A1p (eisretr f) (eissect g (f a)))^ @
        (ap_compose f^-<span class="mi">1</span> f _ @@ eisadj f a) @
        (ap_pp f _ _)^
      ) @
      (ap_compose f g _)^
    ).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* An alias of [isequiv_compose], with some arguments explicit; often convenient when type class search fails. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isequiv_compose&#39;</span>
  {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">_</span> : IsEquiv f)
  {<span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : B -&gt; C) (<span class="nv">_</span> : IsEquiv g)
  : IsEquiv (g o f)
  := isequiv_compose.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : B -&gt; C) (<span class="nv">f</span> : A -&gt; B)
  `{IsEquiv B C g} `{IsEquiv A B f}
  : A &lt;~&gt; C
  := Build_Equiv A C (compose g f) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_compose&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">g</span> : B &lt;~&gt; C) (<span class="nv">f</span> : A &lt;~&gt; B)
  : A &lt;~&gt; C
  := equiv_compose g f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">iff_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B)
  : A &lt;-&gt; B := (equiv_fun f, f^-<span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** We put [g] and [f] in [equiv_scope] explcitly.  This is a partial work-around for https://coq.inria.fr/bugs/show_bug.cgi?id=3990, which is that implicitly bound scopes don&#39;t nest well. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;g &#39;oE&#39; f&quot;</span> := (equiv_compose&#39; g%equiv f%equiv) : equiv_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* The TypeClass [Transitive] has a different order of parameters than [equiv_compose].  Thus in declaring the instance we have to switch the order of arguments. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">transitive_equiv</span> : Transitive Equiv | <span class="mi">0</span> :=
  <span class="kr">fun</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">_</span> <span class="nv">f</span> <span class="nv">g</span> =&gt; equiv_compose g f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> transitive_equiv /.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">change_apply_equiv_compose</span> :=
  <span class="kr">match goal with</span>
  | [ |- <span class="kp">context</span> [ equiv_fun (<span class="nl">?f</span> oE <span class="nl">?g</span>) <span class="nl">?x</span> ] ] =&gt;
    <span class="nb">change</span> ((f oE g) x) <span class="kr">with</span> (f (g x))
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Anything homotopic to an equivalence is an equivalence. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">IsEquivHomotopic</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">g</span> : A -&gt; B}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> `{IsEquiv A B f}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Hypothesis</span> <span class="nv">h</span> : f == g.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Let</span> <span class="nf">sect</span> := (<span class="kr">fun</span> <span class="nv">b</span>:B =&gt; (h (f^-<span class="mi">1</span> b))^ @ eisretr f b).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Let</span> <span class="nf">retr</span> := (<span class="kr">fun</span> <span class="nv">a</span>:A =&gt; (ap f^-<span class="mi">1</span> (h a))^ @ eissect f a).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* We prove the triangle identity with rewrite tactics.  Since we lose control over the proof term that way, we make the result opaque with &quot;Qed&quot;. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk0"><span class="highlight"><span class="kn">Let</span> <span class="nf">adj</span> (<span class="nv">a</span> : A) : sect (g a) = ap g (retr a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sect</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (h (f^-<span class="mi">1</span> b))^ @ eisretr f b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : B, g (f^-<span class="mi">1</span> b) = b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">retr</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (ap f^-<span class="mi">1</span> (h a))^ @ eissect f a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : A, f^-<span class="mi">1</span> (g a) = a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sect (g a) = ap g (retr a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sect</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (h (f^-<span class="mi">1</span> b))^ @ eisretr f b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : B, g (f^-<span class="mi">1</span> b) = b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">retr</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (ap f^-<span class="mi">1</span> (h a))^ @ eissect f a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : A, f^-<span class="mi">1</span> (g a) = a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">sect (g a) = ap g (retr a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk2"><span class="highlight"><span class="nb">unfold</span> sect, retr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sect</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (h (f^-<span class="mi">1</span> b))^ @ eisretr f b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : B, g (f^-<span class="mi">1</span> b) = b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">retr</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (ap f^-<span class="mi">1</span> (h a))^ @ eissect f a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : A, f^-<span class="mi">1</span> (g a) = a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(h (f^-<span class="mi">1</span> (g a)))^ @ eisretr f (g a) =
ap g ((ap f^-<span class="mi">1</span> (h a))^ @ eissect f a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk3"><span class="highlight"><span class="nb">rewrite</span> ap_pp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sect</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (h (f^-<span class="mi">1</span> b))^ @ eisretr f b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : B, g (f^-<span class="mi">1</span> b) = b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">retr</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (ap f^-<span class="mi">1</span> (h a))^ @ eissect f a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : A, f^-<span class="mi">1</span> (g a) = a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(h (f^-<span class="mi">1</span> (g a)))^ @ eisretr f (g a) =
ap g (ap f^-<span class="mi">1</span> (h a))^ @ ap g (eissect f a)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk4"><span class="highlight"><span class="nb">apply</span> moveR_Vp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sect</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (h (f^-<span class="mi">1</span> b))^ @ eisretr f b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : B, g (f^-<span class="mi">1</span> b) = b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">retr</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (ap f^-<span class="mi">1</span> (h a))^ @ eissect f a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : A, f^-<span class="mi">1</span> (g a) = a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eisretr f (g a) =
h (f^-<span class="mi">1</span> (g a)) @
(ap g (ap f^-<span class="mi">1</span> (h a))^ @ ap g (eissect f a))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk5"><span class="highlight"><span class="nb">rewrite</span> concat_p_pp, &lt;- concat_Ap, concat_pp_p, &lt;- concat_Ap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sect</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (h (f^-<span class="mi">1</span> b))^ @ eisretr f b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : B, g (f^-<span class="mi">1</span> b) = b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">retr</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (ap f^-<span class="mi">1</span> (h a))^ @ eissect f a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : A, f^-<span class="mi">1</span> (g a) = a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eisretr f (g a) =
ap f (ap f^-<span class="mi">1</span> (h a))^ @ (ap f (eissect f a) @ h a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk6"><span class="highlight"><span class="nb">rewrite</span> ap_V; <span class="nb">apply</span> moveL_Vp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sect</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (h (f^-<span class="mi">1</span> b))^ @ eisretr f b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : B, g (f^-<span class="mi">1</span> b) = b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">retr</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (ap f^-<span class="mi">1</span> (h a))^ @ eissect f a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : A, f^-<span class="mi">1</span> (g a) = a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap f (ap f^-<span class="mi">1</span> (h a)) @ eisretr f (g a) =
ap f (eissect f a) @ h a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk7"><span class="highlight"><span class="nb">rewrite</span> &lt;- ap_compose; <span class="nb">rewrite</span> (concat_A1p (eisretr f) (h a)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">sect</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">b</span> : B =&gt; (h (f^-<span class="mi">1</span> b))^ @ eisretr f b</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : B, g (f^-<span class="mi">1</span> b) = b</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">retr</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (ap f^-<span class="mi">1</span> (h a))^ @ eissect f a</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : A, f^-<span class="mi">1</span> (g a) = a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eisretr f (f a) @ h a = ap f (eissect f a) @ h a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> whiskerR, eisadj.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* This should not be an instance; it can cause the unifier to spin forever searching for functions to be homotopic to. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isequiv_homotopic</span> : IsEquiv g
    := Build_IsEquiv _ _ g (f ^-<span class="mi">1</span>) sect retr adj.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_homotopic</span> : A &lt;~&gt; B
    := Build_Equiv _ _ g isequiv_homotopic.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">IsEquivHomotopic</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isequiv_homotopic&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A &lt;~&gt; B) {<span class="nv">g</span> : A -&gt; B} (<span class="nv">h</span> : f == g)
  : IsEquiv g
  := isequiv_homotopic f h.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Transporting is an equivalence. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">EquivTransport</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) {<span class="nv">x</span> <span class="nv">y</span> : A} (<span class="nv">p</span> : x = y).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_transport</span> : IsEquiv (transport P p) | <span class="mi">0</span>
    := Build_IsEquiv (P x) (P y) (transport P p) (transport P p^)
    (transport_pV P p) (transport_Vp P p) (transport_pVp P p).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_transport</span> : P x &lt;~&gt; P y
    := Build_Equiv _ _ (transport P p) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">EquivTransport</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** In all the above cases, we were able to directly construct all the structure of an equivalence.  However, as is evident, sometimes it is quite difficult to prove the adjoint law.</span>

<span class="sd">   The following adjointification theorem allows us to be lazy about this if we wish.  It says that if we have all the data of an (adjoint) equivalence except the triangle identity, then we can always obtain the triangle identity by modifying the datum [equiv_is_section] (or [equiv_is_retraction]).  The proof is the same as the standard categorical argument that any equivalence can be improved to an adjoint equivalence.</span>

<span class="sd">   As a stylistic matter, we try to avoid using adjointification in the library whenever possible, to preserve the homotopies specified by the user.  *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Adjointify</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : B -&gt; A).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">isretr</span> : f o g == idmap) (<span class="nv">issect</span> : g o f == idmap).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="c">(* This is the modified [eissect]. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Let</span> <span class="nf">issect&#39;</span> := <span class="kr">fun</span> <span class="nv">x</span> =&gt;
    ap g (ap f (issect x)^)  @  ap g (isretr (f x))  @  issect x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk8"><span class="highlight"><span class="kn">Definition</span> <span class="nf">is_adjoint&#39;</span> (<span class="nv">a</span> : A) : isretr (f a) = ap f (issect&#39; a).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isretr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f o g == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o f == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
(ap g (ap f (issect x)^) @
 ap g (isretr (f x))) @ 
issect x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, g (f x) = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">isretr (f a) = ap f (issect&#39; a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isretr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f o g == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o f == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
(ap g (ap f (issect x)^) @
 ap g (isretr (f x))) @ 
issect x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, g (f x) = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">isretr (f a) = ap f (issect&#39; a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chka"><span class="highlight"><span class="nb">unfold</span> issect&#39;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isretr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f o g == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o f == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
(ap g (ap f (issect x)^) @
 ap g (isretr (f x))) @ 
issect x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, g (f x) = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">isretr (f a) =
ap f
  ((ap g (ap f (issect a)^) @ ap g (isretr (f a))) @
   issect a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chkb"><span class="highlight"><span class="nb">apply</span> moveR_M1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isretr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f o g == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o f == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
(ap g (ap f (issect x)^) @
 ap g (isretr (f x))) @ 
issect x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, g (f x) = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> =
(isretr (f a))^ @
ap f
  ((ap g (ap f (issect a)^) @ ap g (isretr (f a))) @
   issect a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chkc"><span class="highlight"><span class="kp">repeat</span> <span class="nb">rewrite</span> ap_pp, concat_p_pp; <span class="nb">rewrite</span> &lt;- ap_compose.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isretr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f o g == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o f == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
(ap g (ap f (issect x)^) @
 ap g (isretr (f x))) @ 
issect x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, g (f x) = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> =
(((isretr (f a))^ @
  ap (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) (ap f (issect a)^)) @
 ap f (ap g (isretr (f a)))) @ ap f (issect a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chkd"><span class="highlight"><span class="nb">rewrite</span> (concat_pA1 (<span class="kr">fun</span> <span class="nv">b</span> =&gt; (isretr b)^) (ap f (issect a)^)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isretr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f o g == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o f == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
(ap g (ap f (issect x)^) @
 ap g (isretr (f x))) @ 
issect x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, g (f x) = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> =
((ap f (issect a)^ @ (isretr (f (g (f a))))^) @
 ap f (ap g (isretr (f a)))) @ ap f (issect a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chke"><span class="highlight"><span class="kp">repeat</span> <span class="nb">rewrite</span> concat_pp_p; <span class="nb">rewrite</span> ap_V; <span class="nb">apply</span> moveL_Vp; <span class="nb">rewrite</span> concat_p1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isretr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f o g == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o f == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
(ap g (ap f (issect x)^) @
 ap g (isretr (f x))) @ 
issect x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, g (f x) = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap f (issect a) =
(isretr (f (g (f a))))^ @
(ap f (ap g (isretr (f a))) @ ap f (issect a))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chkf"><span class="highlight"><span class="nb">rewrite</span> concat_p_pp, &lt;- ap_compose.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isretr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f o g == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o f == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
(ap g (ap f (issect x)^) @
 ap g (isretr (f x))) @ 
issect x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, g (f x) = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap f (issect a) =
((isretr (f (g (f a))))^ @
 ap (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (g x)) (isretr (f a))) @
ap f (issect a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk10"><span class="highlight"><span class="nb">rewrite</span> (concat_pA1 (<span class="kr">fun</span> <span class="nv">b</span> =&gt; (isretr b)^) (isretr (f a))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">isretr</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f o g == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o f == idmap</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">issect'</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
(ap g (ap f (issect x)^) @
 ap g (isretr (f x))) @ 
issect x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, g (f x) = x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap f (issect a) =
(isretr (f a) @ (isretr (f a))^) @ ap f (issect a)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> concat_pV, concat_1p; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** We don&#39;t make this a typeclass instance, because we want to control when we are applying it. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isequiv_adjointify</span> : IsEquiv f
    := Build_IsEquiv A B f g isretr issect&#39; is_adjoint&#39;.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_adjointify</span> : A &lt;~&gt; B
    := Build_Equiv A B f isequiv_adjointify.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Adjointify</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> isequiv_adjointify {A B}%type_scope (f g)%function_scope isretr issect.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> equiv_adjointify {A B}%type_scope (f g)%function_scope isretr issect.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** An involution is an endomap that is its own inverse. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isequiv_involution</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X) (<span class="nv">isinvol</span> : f o f == idmap)
: IsEquiv f
  := isequiv_adjointify f f isinvol isinvol.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_involution</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : X -&gt; X) (<span class="nv">isinvol</span> : f o f == idmap)
: X &lt;~&gt; X
  := equiv_adjointify f f isinvol isinvol.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Several lemmas useful for rewriting. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">moveR_equiv_M</span> `{IsEquiv A B f} (x : A) (y : B) (p : x = f^-<span class="mi">1</span> y)
  : (f x = y)
  := ap f p @ eisretr f y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">moveR_equiv_M&#39;</span> `(f : A &lt;~&gt; B) (x : A) (y : B) (p : x = f^-<span class="mi">1</span> y)
  : (f x = y)
  := moveR_equiv_M x y p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">moveL_equiv_M</span> `{IsEquiv A B f} (x : A) (y : B) (p : f^-<span class="mi">1</span> y = x)
  : (y = f x)
  := (eisretr f y)^ @ ap f p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">moveL_equiv_M&#39;</span> `(f : A &lt;~&gt; B) (x : A) (y : B) (p : f^-<span class="mi">1</span> y = x)
  : (y = f x)
  := moveL_equiv_M x y p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">moveR_equiv_V</span> `{IsEquiv A B f} (x : B) (y : A) (p : x = f y)
  : (f^-<span class="mi">1</span> x = y)
  := ap (f^-<span class="mi">1</span>) p @ eissect f y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">moveR_equiv_V&#39;</span> `(f : A &lt;~&gt; B) (x : B) (y : A) (p : x = f y)
  : (f^-<span class="mi">1</span> x = y)
  := moveR_equiv_V x y p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">moveL_equiv_V</span> `{IsEquiv A B f} (x : B) (y : A) (p : f y = x)
  : (y = f^-<span class="mi">1</span> x)
  := (eissect f y)^ @ ap (f^-<span class="mi">1</span>) p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">moveL_equiv_V&#39;</span> `(f : A &lt;~&gt; B) (x : B) (y : A) (p : f y = x)
  : (y = f^-<span class="mi">1</span> x)
  := moveL_equiv_V x y p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Equivalence preserves contractibility (which of course is trivial under univalence). *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk11"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">contr_equiv</span> <span class="nv">A</span> {<span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) `{IsEquiv A B f} `{Contr A}
  : Contr B.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Contr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk12"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Contr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk13"><span class="highlight"><span class="kr">exists</span> (<span class="nv">f</span> (center A)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Contr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : B, f (center A) = y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk14"><span class="highlight"><span class="nb">intro</span> y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Contr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f (center A) = y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk15"><span class="highlight"><span class="nb">apply</span> moveR_equiv_M.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Contr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">center A = f^-<span class="mi">1</span> y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> contr.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">contr_equiv&#39;</span> <span class="nv">A</span> {<span class="nv">B</span>} `(f : A &lt;~&gt; B) `{Contr A}
  : Contr B
  := contr_equiv A f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Any two contractible types are equivalent. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_contr_contr</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>}
       `{Contr A} `{Contr B} (f : A -&gt; B)
  : IsEquiv f
  := Build_IsEquiv _ _ f (<span class="kr">fun</span> <span class="nv">_</span> =&gt; (center A))
                  (<span class="kr">fun</span> <span class="nv">x</span> =&gt; path_contr _ _)
                  (<span class="kr">fun</span> <span class="nv">x</span> =&gt; path_contr _ _)
                  (<span class="kr">fun</span> <span class="nv">x</span> =&gt; path_contr _ _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk16"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">equiv_contr_contr</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} `{Contr A} `{Contr B}
  : (A &lt;~&gt; B).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Contr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Contr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A &lt;~&gt; B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk17"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Contr0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Contr1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A &lt;~&gt; B</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> equiv_adjointify <span class="kr">with</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; center B) (<span class="kr">fun</span> <span class="nv">_</span> =&gt; center A);
  <span class="nb">intros</span> ?; <span class="nb">apply</span> contr.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The projection from the sum of a family of contractible types is an equivalence. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk18"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_pr1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, Contr (P x)}
  : IsEquiv (@pr1 A P).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv pr1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk19"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv pr1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk1a"><span class="highlight"><span class="nb">apply</span> (Build_IsEquiv
           _ _ (@pr1 A P)
           (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (x ; center (P x)))
           (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="mi">1</span>)
           (<span class="kr">fun</span> <span class="nv">xy</span> =&gt; <span class="kr">match</span> xy <span class="kr">with</span>
                      | exist x y =&gt; ap (exist _ x) (contr _)
                      <span class="kr">end</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : _ &amp; P x},
<span class="mi">1</span> =
ap pr1
  (<span class="kr">let</span> <span class="nv">xy</span> := x <span class="kr">in</span>
   <span class="kr">let</span> <span class="nv">x0</span> := xy.<span class="mi">1</span> <span class="kr">in</span>
   <span class="kr">let</span> <span class="nv">y</span> := xy.<span class="mi">2</span> <span class="kr">in</span> ap (exist P x0) (contr y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk1b"><span class="highlight"><span class="nb">intros</span> [x y].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> =
ap pr1
  (<span class="kr">let</span> <span class="nv">xy</span> := (x; y) <span class="kr">in</span>
   <span class="kr">let</span> <span class="nv">x</span> := xy.<span class="mi">1</span> <span class="kr">in</span>
   <span class="kr">let</span> <span class="nv">y</span> := xy.<span class="mi">2</span> <span class="kr">in</span> ap (exist P x) (contr y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk1c"><span class="highlight"><span class="nb">rewrite</span> &lt;- ap_compose.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, Contr (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> = ap (<span class="kr">fun</span> <span class="nv">x0</span> : P x =&gt; (x; x0).<span class="mi">1</span>) (contr y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">symmetry</span>; <span class="nb">apply</span> ap_const.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_pr1</span> {<span class="nv">A</span> : <span class="kt">Type</span>} (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, Contr (P x)}
  : { x : A &amp; P x } &lt;~&gt; A
  := Build_Equiv _ _ (@pr1 A P) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

<span class="sd">(** Assuming function extensionality, composing with an equivalence is itself an equivalence *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_precompose</span> `{Funext} {A B C : <span class="kt">Type</span>}
  (f : A -&gt; B) `{IsEquiv A B f}
  : IsEquiv (<span class="kr">fun</span> (<span class="nv">g</span>:B-&gt;C) =&gt; g o f) | <span class="mi">1000</span>
  := isequiv_adjointify (<span class="kr">fun</span> (<span class="nv">g</span>:B-&gt;C) =&gt; g o f)
    (<span class="kr">fun</span> <span class="nv">h</span> =&gt; h o f^-<span class="mi">1</span>)
    (<span class="kr">fun</span> <span class="nv">h</span> =&gt; path_forall _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ap h (eissect f x)))
    (<span class="kr">fun</span> <span class="nv">g</span> =&gt; path_forall _ _ (<span class="kr">fun</span> <span class="nv">y</span> =&gt; ap g (eisretr f y))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_precompose</span> `{Funext} {A B C : <span class="kt">Type</span>}
  (f : A -&gt; B) `{IsEquiv A B f}
  : (B -&gt; C) &lt;~&gt; (A -&gt; C)
  := Build_Equiv _ _ (<span class="kr">fun</span> (<span class="nv">g</span>:B-&gt;C) =&gt; g o f) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_precompose&#39;</span> `{Funext} {A B C : <span class="kt">Type</span>} (f : A &lt;~&gt; B)
  : (B -&gt; C) &lt;~&gt; (A -&gt; C)
  := Build_Equiv _ _ (<span class="kr">fun</span> (<span class="nv">g</span>:B-&gt;C) =&gt; g o f) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_postcompose</span> `{Funext} {A B C : <span class="kt">Type</span>}
  (f : B -&gt; C) `{IsEquiv B C f}
  : IsEquiv (<span class="kr">fun</span> (<span class="nv">g</span>:A-&gt;B) =&gt; f o g) | <span class="mi">1000</span>
  := isequiv_adjointify (<span class="kr">fun</span> (<span class="nv">g</span>:A-&gt;B) =&gt; f o g)
    (<span class="kr">fun</span> <span class="nv">h</span> =&gt; f^-<span class="mi">1</span> o h)
    (<span class="kr">fun</span> <span class="nv">h</span> =&gt; path_forall _ _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; eisretr f (h x)))
    (<span class="kr">fun</span> <span class="nv">g</span> =&gt; path_forall _ _ (<span class="kr">fun</span> <span class="nv">y</span> =&gt; eissect f (g y))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_postcompose</span> `{Funext} {A B C : <span class="kt">Type</span>}
  (f : B -&gt; C) `{IsEquiv B C f}
  : (A -&gt; B) &lt;~&gt; (A -&gt; C)
  := Build_Equiv _ _ (<span class="kr">fun</span> (<span class="nv">g</span>:A-&gt;B) =&gt; f o g) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_postcompose&#39;</span> `{Funext} {A B C : <span class="kt">Type</span>} (f : B &lt;~&gt; C)
  : (A -&gt; B) &lt;~&gt; (A -&gt; C)
  := Build_Equiv _ _ (<span class="kr">fun</span> (<span class="nv">g</span>:A-&gt;B) =&gt; f o g) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Conversely, if pre- or post-composing with a function is always an equivalence, then that function is also an equivalence.  It&#39;s convenient to know that we only need to assume the equivalence when the other type is the domain or the codomain. *)</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk1d"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isequiv_isequiv_precompose</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
  (<span class="nv">precomp</span> := (<span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f))
  (<span class="nv">Aeq</span> : IsEquiv (precomp A)) (<span class="nv">Beq</span> : IsEquiv (precomp B))
  : IsEquiv f.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk1e"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk1f"><span class="highlight"><span class="nb">assert</span> (H : <span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>)
                     (<span class="nv">Ceq</span> : IsEquiv (precomp C)) (<span class="nv">Deq</span> : IsEquiv (precomp D))
                     (<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
                k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) (<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k ((precomp C)^-<span class="mi">1</span> h x)) =
(precomp D)^-<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; k (h x))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk20"><hr></label><div class="goal-conclusion"><span class="highlight">IsEquiv f</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk21"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) (<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k ((precomp C)^-<span class="mi">1</span> h x)) =
(precomp D)^-<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; k (h x))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk22"><span class="highlight"><span class="nb">intros</span> C D ? ? k h.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ceq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp C)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Deq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp D)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k ((precomp C)^-<span class="mi">1</span> h x)) =
(precomp D)^-<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; k (h x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk23"><span class="highlight"><span class="nb">transitivity</span> ((precomp D)^-<span class="mi">1</span> (k o (precomp C ((precomp C)^-<span class="mi">1</span> h)))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ceq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp C)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Deq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp D)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k ((precomp C)^-<span class="mi">1</span> h x)) =
(precomp D)^-<span class="mi">1</span> (k o precomp C ((precomp C)^-<span class="mi">1</span> h))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ceq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp C)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Deq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp D)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk24"><hr></label><div class="goal-conclusion"><span class="highlight">(precomp D)^-<span class="mi">1</span> (k o precomp C ((precomp C)^-<span class="mi">1</span> h)) =
(precomp D)^-<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; k (h x))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk25"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ceq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp C)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Deq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp D)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k ((precomp C)^-<span class="mi">1</span> h x)) =
(precomp D)^-<span class="mi">1</span> (k o precomp C ((precomp C)^-<span class="mi">1</span> h))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk26"><span class="highlight"><span class="nb">transitivity</span> ((precomp D)^-<span class="mi">1</span> (precomp D (k o ((precomp C)^-<span class="mi">1</span> h)))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ceq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp C)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Deq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp D)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k ((precomp C)^-<span class="mi">1</span> h x)) =
(precomp D)^-<span class="mi">1</span> (precomp D (k o (precomp C)^-<span class="mi">1</span> h))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk27" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ceq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp C)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Deq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp D)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk27"><hr></label><div class="goal-conclusion"><span class="highlight">(precomp D)^-<span class="mi">1</span> (precomp D (k o (precomp C)^-<span class="mi">1</span> h)) =
(precomp D)^-<span class="mi">1</span> (k o precomp C ((precomp C)^-<span class="mi">1</span> h))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk28"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ceq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp C)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Deq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp D)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; k ((precomp C)^-<span class="mi">1</span> h x)) =
(precomp D)^-<span class="mi">1</span> (precomp D (k o (precomp C)^-<span class="mi">1</span> h))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> (eissect (precomp D) _); <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk29"><span class="highlight">+</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ceq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp C)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Deq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp D)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(precomp D)^-<span class="mi">1</span> (precomp D (k o (precomp C)^-<span class="mi">1</span> h)) =
(precomp D)^-<span class="mi">1</span> (k o precomp C ((precomp C)^-<span class="mi">1</span> h))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk2a"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ceq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp C)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Deq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp D)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(precomp D)^-<span class="mi">1</span> (k o precomp C ((precomp C)^-<span class="mi">1</span> h)) =
(precomp D)^-<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; k (h x))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> (eisretr (precomp C) h); <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk2b"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk2c"><span class="highlight"><span class="nb">refine</span> (isequiv_adjointify f ((precomp A)^-<span class="mi">1</span> idmap) _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f ((precomp A)^-<span class="mi">1</span> idmap x)) == idmap</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk2d"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (precomp A)^-<span class="mi">1</span> idmap (f x)) == idmap</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk2e"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f ((precomp A)^-<span class="mi">1</span> idmap x)) == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk2f"><span class="highlight"><span class="nb">intros</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f ((precomp A)^-<span class="mi">1</span> idmap x) = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk30"><span class="highlight"><span class="nb">change</span> ((f o (precomp A)^-<span class="mi">1</span> idmap) x = idmap x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(f o (precomp A)^-<span class="mi">1</span> idmap) x = idmap x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk31"><span class="highlight"><span class="nb">apply</span> ap10.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f ((precomp A)^-<span class="mi">1</span> idmap x)) = idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk32"><span class="highlight"><span class="nb">rewrite</span> (H A B Aeq Beq).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(precomp B)^-<span class="mi">1</span> (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; f x) = idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk33"><span class="highlight"><span class="nb">change</span> ((precomp B)^-<span class="mi">1</span> (precomp B idmap) = idmap).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(precomp B)^-<span class="mi">1</span> (precomp B idmap) = idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> eissect.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk34"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (precomp A)^-<span class="mi">1</span> idmap (f x)) == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk35"><span class="highlight"><span class="nb">intros</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(precomp A)^-<span class="mi">1</span> idmap (f x) = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk36"><span class="highlight"><span class="nb">change</span> ((precomp A ((precomp A)^-<span class="mi">1</span> idmap)) x = idmap x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">precomp</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> (<span class="nv">C</span> : <span class="kt">Type</span>) (<span class="nv">h</span> : B -&gt; C) =&gt; h o f</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">C</span> : <span class="kt">Type</span>, (B -&gt; C) -&gt; A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Aeq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Beq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (precomp B)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">Ceq</span> : IsEquiv (precomp C))
(<span class="nv">Deq</span> : IsEquiv (precomp D)) 
(<span class="nv">k</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C),
k o (precomp C)^-<span class="mi">1</span> h = (precomp D)^-<span class="mi">1</span> (k o h)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">precomp A ((precomp A)^-<span class="mi">1</span> idmap) x = idmap x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ap10, eisretr.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(*</span>
<span class="c">Definition isequiv_isequiv_postcompose {A B : Type} (f : A -&gt; B)</span>
<span class="c">  (postcomp := (fun (C : Type) (h : C -&gt; A) =&gt; f o h))</span>
<span class="c">  (feq : forall C:Type, IsEquiv (postcomp C))</span>
<span class="c">  : IsEquiv f.</span>
<span class="c">(* TODO *)</span>
<span class="c">*)</span>

<span class="sd">(** Equivalences between path spaces *)</span>

<span class="sd">(** If [f] is an equivalence, then so is [ap f].  We are lazy and use [adjointify]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_ap</span> `{IsEquiv A B f} (x y : A)
  : IsEquiv (@ap A B f x y) | <span class="mi">1000</span>
  := isequiv_adjointify (ap f)
  (<span class="kr">fun</span> <span class="nv">q</span> =&gt; (eissect f x)^  @  ap f^-<span class="mi">1</span> q  @  eissect f y)
  (<span class="kr">fun</span> <span class="nv">q</span> =&gt;
    ap_pp f _ _
    @ whiskerR (ap_pp f _ _) _
    @ ((ap_V f _ @ inverse2 (eisadj f _)^)
      @@ (ap_compose f^-<span class="mi">1</span> f _)^
      @@ (eisadj f _)^)
    @ concat_pA1_p (eisretr f) _ _
    @ whiskerR (concat_Vp _) _
    @ concat_1p _)
  (<span class="kr">fun</span> <span class="nv">p</span> =&gt;
    whiskerR (whiskerL _ (ap_compose f f^-<span class="mi">1</span> _)^) _
    @ concat_pA1_p (eissect f) _ _
    @ whiskerR (concat_Vp _) _
    @ concat_1p _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_ap</span> `(f : A -&gt; B) `{IsEquiv A B f} (x y : A)
  : (x = y) &lt;~&gt; (f x = f y)
  := Build_Equiv _ _ (ap f) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Global Arguments</span> equiv_ap (A B)%type_scope f%function_scope _ _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_ap&#39;</span> `(f : A &lt;~&gt; B) (x y : A)
  : (x = y) &lt;~&gt; (f x = f y)
  := equiv_ap f x y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* TODO: Is this really necessary? *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_inj</span> `(f : A -&gt; B) `{IsEquiv A B f} {x y : A}
  : (f x = f y) -&gt; (x = y)
  := (ap f)^-<span class="mi">1</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The inverse of an equivalence is an equivalence. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk37"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_inverse</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">feq</span> : IsEquiv f}
  : IsEquiv f^-<span class="mi">1</span> | <span class="mi">10000</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv f^-<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk38"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv f^-<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk39"><span class="highlight"><span class="nb">refine</span> (Build_IsEquiv B A f^-<span class="mi">1</span> f (eissect f) (eisretr f) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : B,
eissect f (f^-<span class="mi">1</span> x) = ap f^-<span class="mi">1</span> (eisretr f x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk3a"><span class="highlight"><span class="nb">intro</span> b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">eissect f (f^-<span class="mi">1</span> b) = ap f^-<span class="mi">1</span> (eisretr f b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk3b"><span class="highlight"><span class="nb">apply</span> (equiv_inj (ap f)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap f (eissect f (f^-<span class="mi">1</span> b)) =
ap f (ap f^-<span class="mi">1</span> (eisretr f b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight"><span class="c">(* We will prove the equality as a composite of four paths, working right to left.</span>
<span class="c">  The LHS remains [ap f (eissect f (f^-1 b))] throughout the process.</span>
<span class="c">  Both sides of the equation are paths of type [f (f^-1 (f (f^-1 b))) = f (f^-1 b)]. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk3c"><span class="highlight"><span class="nb">refine</span> (_ @ _ @ _ @ _); <span class="nb">revgoals</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> = ap f (ap f^-<span class="mi">1</span> (eisretr f b))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk3d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk3d"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal0</span> = <span class="nl">?Goal</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk3e"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal1</span> = <span class="nl">?Goal0</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk3f"><hr></label><div class="goal-conclusion"><span class="highlight">ap f (eissect f (f^-<span class="mi">1</span> b)) = <span class="nl">?Goal1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk40"><span class="highlight"><span class="mi">1</span>: <span class="nb">apply</span> ap_compose.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> = ap (<span class="kr">fun</span> <span class="nv">x</span> : B =&gt; f (f^-<span class="mi">1</span> x)) (eisretr f b)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk41" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk41"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal0</span> = <span class="nl">?Goal</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk42"><hr></label><div class="goal-conclusion"><span class="highlight">ap f (eissect f (f^-<span class="mi">1</span> b)) = <span class="nl">?Goal0</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk43"><span class="highlight"><span class="mi">1</span>: <span class="nb">symmetry</span>; <span class="nb">apply</span> (ap_homotopic_id (eisretr f)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> =
(eisretr f (f (f^-<span class="mi">1</span> b)) @ eisretr f b) @
(eisretr f b)^</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk44" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk44"><hr></label><div class="goal-conclusion"><span class="highlight">ap f (eissect f (f^-<span class="mi">1</span> b)) = <span class="nl">?Goal</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk45"><span class="highlight"><span class="mi">1</span>: <span class="nb">symmetry</span>; <span class="nb">apply</span> concat_pp_V.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">feq</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap f (eissect f (f^-<span class="mi">1</span> b)) = eisretr f (f (f^-<span class="mi">1</span> b))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="mi">1</span>: <span class="nb">symmetry</span>; <span class="nb">apply</span> eisadj.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** If the goal is [IsEquiv _^-1], then use [isequiv_inverse]; otherwise, don&#39;t pretend worry about if the goal is an evar and we want to add a [^-1]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">#[export]
<span class="kn">Hint Extern</span> <span class="mi">0</span> (IsEquiv _^-<span class="mi">1</span>) =&gt; <span class="nb">apply</span> @isequiv_inverse : typeclass_instances.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** [Equiv A B] is a symmetric relation. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk46"><span class="highlight"><span class="kn">Theorem</span> <span class="nf">equiv_inverse</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} : (A &lt;~&gt; B) -&gt; (B &lt;~&gt; A).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A &lt;~&gt; B -&gt; B &lt;~&gt; A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk47"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A &lt;~&gt; B -&gt; B &lt;~&gt; A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk48"><span class="highlight"><span class="nb">intro</span> e.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">B &lt;~&gt; A</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk49"><span class="highlight"><span class="kr">exists</span> (<span class="nv">e</span>^-<span class="mi">1</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv e^-<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> isequiv_inverse.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;e ^-1&quot;</span> := (@equiv_inverse _ _ e) : equiv_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">symmetric_equiv</span> : Symmetric Equiv | <span class="mi">0</span> := @equiv_inverse.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> symmetric_equiv /.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Inversion respects composition *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk4a"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_inverse_compose</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A &lt;~&gt; B) (<span class="nv">g</span> : B &lt;~&gt; C)
  : (g oE f)^-<span class="mi">1</span> == f^-<span class="mi">1</span> oE g^-<span class="mi">1</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B &lt;~&gt; C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(g oE f)^-<span class="mi">1</span> == f^-<span class="mi">1</span> oE g^-<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk4b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B &lt;~&gt; C</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(g oE f)^-<span class="mi">1</span> == f^-<span class="mi">1</span> oE g^-<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Inversion respects homotopies *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk4c"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_inverse_homotopy</span> {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> <span class="nv">g</span> : A &lt;~&gt; B) (<span class="nv">p</span> : f == g)
  : g^-<span class="mi">1</span> == f^-<span class="mi">1</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">g^-<span class="mi">1</span> == f^-<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk4d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">g^-<span class="mi">1</span> == f^-<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk4e"><span class="highlight"><span class="nb">intros</span> x; <span class="nb">refine</span> (_ @ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">g^-<span class="mi">1</span> x = <span class="nl">?Goal0</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk4f"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal0</span> = <span class="nl">?Goal</span></span></div></blockquote><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk50"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> = f^-<span class="mi">1</span> x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk51"><span class="highlight"><span class="mi">1</span>:<span class="nb">symmetry</span>; <span class="nb">apply</span> (eissect f).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f^-<span class="mi">1</span> (f (g^-<span class="mi">1</span> x)) = <span class="nl">?Goal</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk52"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span> = f^-<span class="mi">1</span> x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk53"><span class="highlight"><span class="mi">1</span>:<span class="nb">apply</span> ap, p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A &lt;~&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">f^-<span class="mi">1</span> (g (g^-<span class="mi">1</span> x)) = f^-<span class="mi">1</span> x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ap, eisretr.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_ap_inv</span> `(f : A -&gt; B) `{IsEquiv A B f} (x y : B)
  : (f^-<span class="mi">1</span> x = f^-<span class="mi">1</span> y) &lt;~&gt; (x = y)
  := (@equiv_ap B A f^-<span class="mi">1</span> _ x y)^-<span class="mi">1</span>%equiv.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_ap_inv&#39;</span> `(f : A &lt;~&gt; B) (x y : B)
  : (f^-<span class="mi">1</span> x = f^-<span class="mi">1</span> y) &lt;~&gt; (x = y)
  := (equiv_ap&#39; f^-<span class="mi">1</span>%equiv x y)^-<span class="mi">1</span>%equiv.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** If [g \o f] and [f] are equivalences, so is [g].  This is not an Instance because it would require Coq to guess [f]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cancelR_isequiv</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">g</span> : B -&gt; C}
  `{IsEquiv A B f} `{IsEquiv A C (g o f)}
  : IsEquiv g
  := isequiv_homotopic (compose (compose g f) f^-<span class="mi">1</span>)
       (<span class="kr">fun</span> <span class="nv">b</span> =&gt; ap g (eisretr f b)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cancelR_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A -&gt; B) {<span class="nv">g</span> : B -&gt; C}
  `{IsEquiv A B f} `{IsEquiv A C (g o f)}
  : B &lt;~&gt; C
  := Build_Equiv B C g (cancelR_isequiv f).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** If [g \o f] and [g] are equivalences, so is [f]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cancelL_isequiv</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">g</span> : B -&gt; C) {<span class="nv">f</span> : A -&gt; B}
  `{IsEquiv B C g} `{IsEquiv A C (g o f)}
  : IsEquiv f
  := isequiv_homotopic (compose g^-<span class="mi">1</span> (compose g f))
       (<span class="kr">fun</span> <span class="nv">a</span> =&gt; eissect g (f a)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cancelL_equiv</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">g</span> : B -&gt; C) {<span class="nv">f</span> : A -&gt; B}
  `{IsEquiv B C g} `{IsEquiv A C (g o f)}
  : A &lt;~&gt; B
  := Build_Equiv _ _ f (cancelL_isequiv g).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Combining these with [isequiv_compose], we see that equivalences can be transported across commutative squares. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk54"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isequiv_commsq</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D)
           (<span class="nv">p</span> : k o f == g o h)
           `{IsEquiv _ _ f} `{IsEquiv _ _ h} `{IsEquiv _ _ k}
: IsEquiv g.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">k o f == g o h</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv h</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk55"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">k o f == g o h</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv h</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv g</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk56"><span class="highlight"><span class="nb">refine</span> (@cancelR_isequiv _ _ _ h g _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">k o f == g o h</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv h</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; g (h x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (isequiv_homotopic _ p).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk57"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isequiv_commsq&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
           (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D)
           (<span class="nv">p</span> : g o h == k o f)
           `{IsEquiv _ _ g} `{IsEquiv _ _ h} `{IsEquiv _ _ k}
: IsEquiv f.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o h == k o f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv h</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk58"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o h == k o f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv h</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk59"><span class="highlight"><span class="nb">refine</span> (@cancelL_isequiv _ _ _ k f _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B, C, D</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">k</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; D</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g o h == k o f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv h</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H1</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv k</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; k (f x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (isequiv_homotopic _ p).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Based homotopy spaces *)</span>

</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk5a"><span class="highlight"><span class="kn">Instance</span> <span class="nf">contr_basedhomotopy</span> `{Funext}
       {A:<span class="kt">Type</span>} {B : A -&gt; <span class="kt">Type</span>} (f : <span class="kr">forall</span> <span class="nv">x</span>, B x)
: Contr {g : <span class="kr">forall</span> <span class="nv">x</span>, B x &amp; f == g }.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr {g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk5b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr {g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk5c"><span class="highlight"><span class="nb">refine</span> (contr_equiv&#39; { g : <span class="kr">forall</span> <span class="nv">x</span>, B x &amp; f = g } _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f = g} &lt;~&gt;
{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk5d"><span class="highlight">srapply equiv_adjointify; <span class="nb">intros</span> [g h].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f = g</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk5e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk5e"><hr></label><div class="goal-conclusion"><span class="highlight">{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f = g}</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk5f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk5f"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span>@{g:=<span class="nl">?Goal0</span>.<span class="mi">1</span>; h:=<span class="nl">?Goal0</span>.<span class="mi">2</span>} = (g; h)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk60" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f = g</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk60"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal0</span>@{g:=<span class="nl">?Goal</span>.<span class="mi">1</span>; h:=<span class="nl">?Goal</span>.<span class="mi">2</span>} = (g; h)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk61"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f = g</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f == g}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (g; apD10 h).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk62"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; f = g}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (g; path_forall _ _ h).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk63"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f == g</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((g; path_forall f g h).<span class="mi">1</span>;
apD10 (g; path_forall f g h).<span class="mi">2</span>) = (g; h)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ap, eisretr.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk64"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f = g</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((g; apD10 h).<span class="mi">1</span>;
path_forall f (g; apD10 h).<span class="mi">1</span> (g; apD10 h).<span class="mi">2</span>) = (g; h)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ap, eissect.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk65"><span class="highlight"><span class="kn">Instance</span> <span class="nf">contr_basedhomotopy&#39;</span> `{Funext}
       {A:<span class="kt">Type</span>} {B : A -&gt; <span class="kt">Type</span>} (f : <span class="kr">forall</span> <span class="nv">x</span>, B x)
: Contr {g : <span class="kr">forall</span> <span class="nv">x</span>, B x &amp; g == f }.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr {g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; g == f}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk66"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr {g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; g == f}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk67"><span class="highlight"><span class="nb">refine</span> (contr_equiv&#39; { g : <span class="kr">forall</span> <span class="nv">x</span>, B x &amp; g = f } _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; g = f} &lt;~&gt;
{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; g == f}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk68"><span class="highlight">srapply equiv_adjointify; <span class="nb">intros</span> [g h].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g = f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; g == f}</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk69" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g == f</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk69"><hr></label><div class="goal-conclusion"><span class="highlight">{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; g = f}</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk6a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g == f</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk6a"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal</span>@{g:=<span class="nl">?Goal0</span>.<span class="mi">1</span>; h:=<span class="nl">?Goal0</span>.<span class="mi">2</span>} = (g; h)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="equivalences-v-chk6b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g = f</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="equivalences-v-chk6b"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="nl">?Goal0</span>@{g:=<span class="nl">?Goal</span>.<span class="mi">1</span>; h:=<span class="nl">?Goal</span>.<span class="mi">2</span>} = (g; h)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk6c"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g = f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; g == f}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (g; apD10 h).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk6d"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g == f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{g : <span class="kr">forall</span> <span class="nv">x</span> : A, B x &amp; g = f}</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (g; path_forall _ _ h).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk6e"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g == f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((g; path_forall g f h).<span class="mi">1</span>;
apD10 (g; path_forall g f h).<span class="mi">2</span>) = (g; h)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ap, eisretr.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk6f"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f, g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, B x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g = f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((g; apD10 h).<span class="mi">1</span>;
path_forall (g; apD10 h).<span class="mi">1</span> f (g; apD10 h).<span class="mi">2</span>) = (g; h)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ap, eissect.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

<span class="sd">(** The function [equiv_ind] says that given an equivalence [f : A &lt;~&gt; B], and a hypothesis from [B], one may always assume that the hypothesis is in the image of [e].</span>

<span class="sd">In fibrational terms, if we have a fibration over [B] which has a section once pulled back along an equivalence [f : A &lt;~&gt; B], then it has a section over all of [B].  *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_ind</span> `{IsEquiv A B f} (P : B -&gt; <span class="kt">Type</span>)
  : (<span class="kr">forall</span> <span class="nv">x</span>:A, P (f x)) -&gt; <span class="kr">forall</span> <span class="nv">y</span>:B, P y
  := <span class="kr">fun</span> <span class="nv">g</span> <span class="nv">y</span> =&gt; transport P (eisretr f y) (g (f^-<span class="mi">1</span> y)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Arguments</span> equiv_ind {A B} f {_} P _ _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk70"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_ind_comp</span> `{IsEquiv A B f} (P : B -&gt; <span class="kt">Type</span>)
  (df : <span class="kr">forall</span> <span class="nv">x</span>:A, P (f x)) (x : A)
  : equiv_ind f P df (f x) = df x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">df</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_ind f P df (f x) = df x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk71"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">df</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_ind f P df (f x) = df x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk72"><span class="highlight"><span class="nb">unfold</span> equiv_ind.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">df</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport P (eisretr f (f x)) (df (f^-<span class="mi">1</span> (f x))) = df x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk73"><span class="highlight"><span class="nb">rewrite</span> eisadj.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">df</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport P (ap f (eissect f x)) (df (f^-<span class="mi">1</span> (f x))) =
df x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="equivalences-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="equivalences-v-chk74"><span class="highlight"><span class="nb">rewrite</span> &lt;- transport_compose.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">df</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, P (f x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; P (f x)) (eissect f x)
  (df (f^-<span class="mi">1</span> (f x))) = df x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (apD df (eissect f x)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Using [equiv_ind], we define a handy little tactic which introduces a variable and simultaneously substitutes it along an equivalence. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">equiv_intro</span> E x :=
  <span class="kr">match goal with</span>
    | |- <span class="kr">forall</span> <span class="nv">y</span>, @<span class="nl">?Q</span> y =&gt;
      <span class="nb">refine</span> (equiv_ind E Q _); <span class="nb">intros</span> x
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The same, but for several variables. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equiv_intros&quot;</span> <span class="kp">constr</span>(E) <span class="kn">ident</span>(x)
  := equiv_intro E x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equiv_intros&quot;</span> <span class="kp">constr</span>(E) <span class="kn">ident</span>(x) <span class="kn">ident</span>(y)
  := equiv_intro E x; equiv_intro E y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Tactic Notation</span> <span class="s2">&quot;equiv_intros&quot;</span> <span class="kp">constr</span>(E) <span class="kn">ident</span>(x) <span class="kn">ident</span>(y) <span class="kn">ident</span>(z)
  := equiv_intro E x; equiv_intro E y; equiv_intro E z.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** [equiv_composeR&#39;], a flipped version of [equiv_compose&#39;], is (like [concatR]) most often useful partially applied, to give the ‚Äúfirst half‚Äù of an equivalence one is constructing and leave the rest as a subgoal. One could similarly define [equiv_composeR] as a flip of [equiv_compose], but it doesn‚Äôt seem so useful since it doesn‚Äôt leave the remaining equivalence as a subgoal. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_composeR&#39;</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>} (<span class="nv">f</span> : A &lt;~&gt; B) (<span class="nv">g</span> : B &lt;~&gt; C)
  := equiv_compose&#39; g f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Shouldn&#39;t this become transitivity mid ? *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">equiv_via</span> mid :=
  <span class="nb">apply</span> @equiv_composeR&#39; <span class="kr">with</span> (B := mid).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** It&#39;s often convenient when constructing a chain of equivalences to use [equiv_compose&#39;], etc.  But when we treat an [Equiv] object constructed in that way as a function, via the coercion [equiv_fun], Coq sometimes needs a little help to realize that the result is the same as ordinary composition.  This tactic provides that help. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">ev_equiv</span> :=
  <span class="kp">repeat</span> <span class="kr">match goal with</span>
           | [ |- <span class="kp">context</span>[equiv_fun (equiv_compose&#39; <span class="nl">?g</span> <span class="nl">?f</span>) <span class="nl">?a</span>] ] =&gt;
             <span class="nb">change</span> ((equiv_compose&#39; g f) a) <span class="kr">with</span> (g (f a))
           | [ |- <span class="kp">context</span>[equiv_fun (equiv_compose <span class="nl">?g</span> <span class="nl">?f</span>) <span class="nl">?a</span>] ] =&gt;
             <span class="nb">change</span> ((equiv_compose g f) a) <span class="kr">with</span> (g (f a))
           | [ |- <span class="kp">context</span>[equiv_fun (equiv_inverse <span class="nl">?f</span>) <span class="nl">?a</span>] ] =&gt;
             <span class="nb">change</span> ((equiv_inverse f) a) <span class="kr">with</span> (f^-<span class="mi">1</span> a)
         <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Building equivalences between nested sigma and record types *)</span>

<span class="sd">(** The following tactic [make_equiv] builds an equivalence between two types built out of arbitrarily nested sigma and record types, not necessarily right-associated, as long as they have all the same underyling components.  This is more general than [issig] in that it doesn&#39;t just prove equivalences between a single record type and a single right-nested tower of sigma types, but less powerful in that it can&#39;t deduce the latter nested tower of sigmas automatically: you have to have both sides of the equivalence known. *)</span>

<span class="c">(* Perform [intros] repeatedly, recursively destructing all possibly-nested record types. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">decomposing_intros</span> :=
  <span class="kr">let</span> <span class="nv">x</span> := <span class="kp">fresh</span> <span class="kr">in</span>
  <span class="nb">intros</span> x; <span class="nb">cbn</span> <span class="kr">in</span> x;
  <span class="kp">try</span> <span class="kr">match</span> <span class="kp">type of</span> x <span class="kr">with</span>
  | <span class="nl">?a</span> = <span class="nl">?b</span> =&gt; <span class="kp">fail</span> <span class="mi">1</span>           <span class="sd">(** Don&#39;t destruct paths *)</span>
  | <span class="kr">forall</span> <span class="nv">y</span>:<span class="nl">?A</span>, <span class="nl">?B</span> =&gt; <span class="kp">fail</span> <span class="mi">1</span>   <span class="sd">(** Don&#39;t apply functions *)</span>
  | _ =&gt; <span class="nb">elim</span> x; <span class="nb">clear</span> x
  <span class="kr">end</span>;
  <span class="kp">try</span> decomposing_intros.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* A multi-success version of [assumption].  That is, like [assumption], but if there are multiple hypotheses that match the type of the goal, then after choosing the first one, if a later tactic fails we can backtrack and choose another one. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">multi_assumption</span> :=
  <span class="kr">multimatch goal with</span>
    <span class="c">(* If we wrote [ H : ?A |- ?A ] here instead, it would prevent Coq from choosing an assumption that would require instantiating evars, which it has to do in the contr_basedpaths case below. *)</span>
    [ H : <span class="nl">?A</span> |- _ ] =&gt; <span class="bp">exact</span> H
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Build an element of a possibly-nested record type out of hypotheses in the context. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">build_record</span> :=
  <span class="nb">cbn</span>; multi_assumption + (<span class="nb">unshelve</span> <span class="nb">econstructor</span>; build_record).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* Construct an equivalence between two possibly-nested record/sigma types that differ only by associativity and permutation of their components.  We could use [Build_Equiv] and directly construct [eisadj] by decomposing to reflexivity as well, but often with large nested types it seems to be faster to adjointify. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">make_equiv</span> :=
  <span class="nb">simple notypeclasses refine</span> (equiv_adjointify _ _ _ _);
    [ decomposing_intros; build_record
    | decomposing_intros; build_record
    | decomposing_intros; <span class="bp">exact</span> idpath
    | decomposing_intros; <span class="bp">exact</span> idpath ].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** In case anyone ever needs it, here&#39;s the version that doesn&#39;t adjointify. It&#39;s not the default, because it can be slow. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">make_equiv_without_adjointification</span> :=
  <span class="nb">simple notypeclasses refine</span> (Build_Equiv _ _ _ _);
    [ decomposing_intros; build_record |
      <span class="nb">simple notypeclasses refine</span> (Build_IsEquiv _ _ _ _ _ _ _);
      [ decomposing_intros; build_record
      | decomposing_intros; <span class="bp">exact</span> idpath
      | decomposing_intros; <span class="bp">exact</span> idpath
      | decomposing_intros; <span class="bp">exact</span> idpath ] ].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Here are some examples of the use of this tactic that you can uncomment and explore. *)</span>

<span class="sd">(**</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">Goal forall (A : Type) (B : A -&gt; Type) (C : forall a:A, B a -&gt; Type) (D : forall (a:A) (b:B a), C a b -&gt; Type),</span>
<span class="sd">     { ab : {a : A &amp; B a } &amp; { c : C ab.1 ab.2 &amp; D ab.1 ab.2 c } }</span>
<span class="sd">     &lt;~&gt; { a : A &amp; { bc : { b : B a &amp; C a b } &amp; D a bc.1 bc.2 } }.</span>
<span class="sd">  intros A B C D.</span>
<span class="sd">  make_equiv.</span>
<span class="sd">  Undo.</span>
<span class="sd">  (** Here&#39;s the eventually successful proof script produced by [make_equiv], extracted from [Info 0 make_equiv] and prettified, so you can step through it and see how the tactic works. *)</span>
<span class="sd">  simple notypeclasses refine (equiv_adjointify _ _ _ _).</span>
<span class="sd">  - (** Here begins [decomposing_intros] *)</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros a; cbn in a.</span>
<span class="sd">    intros b; cbn in b.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros c; cbn in c. </span>
<span class="sd">    intros d; cbn in d.</span>
<span class="sd">    (** Here begins [build_record] *)</span>
<span class="sd">    cbn; unshelve econstructor.</span>
<span class="sd">    { cbn; exact a. }</span>
<span class="sd">    { cbn; unshelve econstructor.</span>
<span class="sd">      { cbn; unshelve econstructor.</span>
<span class="sd">        { cbn; exact b. }</span>
<span class="sd">        { cbn; exact c. } }</span>
<span class="sd">      { cbn; exact d. } }</span>
<span class="sd">  - intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros a; cbn in a.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x. </span>
<span class="sd">    intros b; cbn in b.</span>
<span class="sd">    intros c; cbn in c.</span>
<span class="sd">    intros d; cbn in d.</span>
<span class="sd">    cbn; unshelve econstructor.</span>
<span class="sd">    { cbn; unshelve econstructor.</span>
<span class="sd">      { cbn; exact a. }</span>
<span class="sd">      { cbn; exact b. } }</span>
<span class="sd">    { cbn; unshelve econstructor.</span>
<span class="sd">      { cbn; exact c. }</span>
<span class="sd">      { cbn; exact d. } }</span>
<span class="sd">  - intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros a; cbn in a.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x. </span>
<span class="sd">    intros b; cbn in b.</span>
<span class="sd">    intros c; cbn in c.</span>
<span class="sd">    intros d; cbn in d.</span>
<span class="sd">    cbn; exact idpath.</span>
<span class="sd">  - intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros a; cbn in a.</span>
<span class="sd">    intros b; cbn in b.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros c; cbn in c. </span>
<span class="sd">    intros d; cbn in d.</span>
<span class="sd">    cbn; exact idpath.</span>
<span class="sd">Defined.</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">*)</span>

<span class="sd">(** Here is an example illustrating the need for [multi_assumption] instead of just [assumption]. *)</span>
<span class="sd">(**</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">Goal forall (A:Type) (R:A-&gt;A-&gt;Type),</span>
<span class="sd">    { x : A &amp; { y : A &amp; R x y } } &lt;~&gt; { xy : A * A &amp; R (fst xy) (snd xy) }.</span>
<span class="sd">  intros A R.</span>
<span class="sd">  make_equiv.</span>
<span class="sd">  Undo.</span>
<span class="sd">  simple notypeclasses refine (equiv_adjointify _ _ _ _).</span>
<span class="sd">  - intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros a1; cbn in a1.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros a2; cbn in a2.</span>
<span class="sd">    intros r; cbn in r.</span>
<span class="sd">    cbn; unshelve econstructor.</span>
<span class="sd">    { cbn; unshelve econstructor. </span>
<span class="sd">      { (** [build_record] can&#39;t guess at this point that it needs to use [a1] instead of [a2], and in fact it tries [a2] first; but later on, [exact r] fails in that case, causing backtracking to this point and a re-try with [a1].  *)</span>
<span class="sd">        cbn; exact a1. }</span>
<span class="sd">      { cbn; exact a2. } }</span>
<span class="sd">    cbn; exact r.</span>
<span class="sd">  - intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros a1; cbn in a1.</span>
<span class="sd">    intros a2; cbn in a2.</span>
<span class="sd">    intros r; cbn in r.</span>
<span class="sd">    cbn; unshelve econstructor.</span>
<span class="sd">    { cbn; exact a1. }</span>
<span class="sd">    { cbn; unshelve econstructor.</span>
<span class="sd">      { cbn; exact a2. }</span>
<span class="sd">      { cbn; exact r. } }</span>
<span class="sd">  - intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros a1; cbn in a1.</span>
<span class="sd">    intros a2; cbn in a2.</span>
<span class="sd">    intros r; cbn in r.</span>
<span class="sd">    cbn; exact idpath.</span>
<span class="sd">  - intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros a1; cbn in a1.</span>
<span class="sd">    intros x; cbn in x.</span>
<span class="sd">    elim x; clear x.</span>
<span class="sd">    intros a2; cbn in a2.</span>
<span class="sd">    intros r; cbn in r.</span>
<span class="sd">    cbn; exact idpath.</span>
<span class="sd">Defined.</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">*)</span>

<span class="sd">(** Some &quot;real-world&quot; examples where [make_equiv] simplifies things a lot include the associativity/symmetry proofs in [Types/Sigma.v], [issig_pequiv&#39;] in [Pointed/pEquiv.v], and [loop_susp_adjoint] in [Pointed/pSusp.v]. *)</span>

<span class="sd">(** Now we give a version of [make_equiv] that can also prove equivalences of nested sigma- and record types that involve contracting based path-spaces on either or both sides.  The basepoint and the path don&#39;t have to appear together, but can be in arbitrarily separated parts of the nested structure.  It does this by selectively applying path-induction to based paths appearing on both sides, if needed. *)</span>

<span class="sd">(** We start with a version of [decomposing_intros] that is willing to destruct paths, though as a second choice. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">decomposing_intros_with_paths</span> :=
  <span class="kr">let</span> <span class="nv">x</span> := <span class="kp">fresh</span> <span class="kr">in</span>
  <span class="nb">intros</span> x; <span class="nb">cbn</span> <span class="kr">in</span> x;
  <span class="kr">multimatch</span> <span class="kp">type of</span> x <span class="kr">with</span>
  | _ =&gt;
    <span class="kp">try</span> <span class="kr">match</span> <span class="kp">type of</span> x <span class="kr">with</span>
        | <span class="sd">(** Don&#39;t destruct paths at first *)</span>
          <span class="nl">?a</span> = <span class="nl">?b</span> =&gt; <span class="kp">fail</span> <span class="mi">1</span>
        | <span class="sd">(** Don&#39;t apply functions at first *)</span>
          <span class="kr">forall</span> <span class="nv">y</span>:<span class="nl">?A</span>, <span class="nl">?B</span> =&gt; <span class="kp">fail</span> <span class="mi">1</span>
        | _ =&gt; <span class="nb">elim</span> x; <span class="nb">clear</span> x
        <span class="kr">end</span>;
    <span class="kp">try</span> decomposing_intros_with_paths
  | <span class="nl">?a</span> = <span class="nl">?b</span> =&gt;
    <span class="sd">(** Destruct paths as a second choice.  But sometimes [destruct] isn&#39;t smart enough to generalize the other hypotheses that use the free endpoint, so we manually apply [paths_ind], or its right-handed version, instead. *)</span>
    ((<span class="nb">move</span> x <span class="nb">before</span> b; <span class="sd">(** Ensure that [b] and [x] come first in the [forall] goal resulting from [generalize dependent], so that [paths_ind] can apply to it. *)</span>
      <span class="nb">revert dependent</span> b;
      <span class="kp">assert_fails</span> (<span class="nb">move</span> b <span class="nb">at top</span>); <span class="sd">(** Check that [b] was actually reverted.  (If it&#39;s a section variable that the goal depends on, [generalize dependent b] will &quot;succeed&quot;, but actually fail to generalize the goal over [b] (since that can&#39;t be done within the section) and not clear [b] from the context.)  *)</span>
      <span class="nb">refine</span> (paths_ind _ _ _)) +
     <span class="sd">(** Try the other endpoint too. *)</span>
     (<span class="nb">move</span> x <span class="nb">before</span> a;
      <span class="nb">revert dependent</span> a;
      <span class="kp">assert_fails</span> (<span class="nb">move</span> a <span class="nb">at top</span>);
      <span class="nb">refine</span> (paths_ind_r _ _ _)));
    <span class="kp">try</span> decomposing_intros_with_paths
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Going the other direction, we have to be willing to insert identity paths to fill in the based path-spaces that got destructed.  In fact [econstructor] is already willing to do that, since [idpath] is the constructor of [paths].  However, our previous [build_record] won&#39;t manage to get to the point of being able to apply [econstructor] to the necessary paths, since it&#39;ll get stuck earlier on trying to find the basepoint.  Thus, we give a version of [build_record] that is willing to create existential variables (&quot;evars&quot;) for goals that it can&#39;t solve, in hopes that a later [idpath] (produced by [econstructor]) will determine them by unification.  Note that if there are other fields that depend on the basepoint that occur before the [idpath], the evar will -- and, indeed, must -- get instantiated by them instead.  This is why [multi_assumption], above, must be willing to instantiate evars. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">build_record_with_evars</span> :=
  (<span class="nb">cbn</span>; multi_assumption + (<span class="nb">unshelve</span> <span class="nb">econstructor</span>; build_record_with_evars)) +
  <span class="sd">(** Create a fresh evar to solve this goal *)</span>
  (<span class="kr">match goal with</span>
     |- <span class="nl">?G</span> =&gt; <span class="kr">let</span> <span class="nv">x</span> := <span class="kp">fresh</span> <span class="kr">in</span> <span class="nb">evar</span> (x : G); <span class="bp">exact</span> x
   <span class="kr">end</span>; build_record_with_evars).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** Now here&#39;s the improved version of [make_equiv]. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">make_equiv_contr_basedpaths</span> :=
  <span class="nb">simple notypeclasses refine</span> (equiv_adjointify _ _ _ _);
    <span class="sd">(** [solve [ unshelve TAC ]] ensures that [TAC] succeeds without leaving any leftover evars. *)</span>
    [ decomposing_intros_with_paths; <span class="kp">solve</span> [ <span class="nb">unshelve</span> build_record_with_evars ]
    | decomposing_intros_with_paths; <span class="kp">solve</span> [ <span class="nb">unshelve</span> build_record_with_evars ]
    | decomposing_intros_with_paths; <span class="bp">exact</span> idpath
    | decomposing_intros_with_paths; <span class="bp">exact</span> idpath ].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** As before, we give some examples. *)</span>

<span class="sd">(**</span>
<span class="sd">&lt;&lt;</span>
<span class="sd">Section Examples.</span>
<span class="sd">  Context (A : Type) (B : A -&gt; Type) (a0 : A).</span>
<span class="sd">  Goal { a : A &amp; { b : B a &amp; a = a0 } } &lt;~&gt; B a0.</span>
<span class="sd">  Proof.</span>
<span class="sd">    make_equiv_contr_basedpaths.</span>
<span class="sd">    Undo.</span>
<span class="sd">    simple notypeclasses refine (equiv_adjointify _ _ _ _).</span>
<span class="sd">    - (** Here begins [decomposing_intros_with_paths] *)</span>
<span class="sd">      intros x; cbn in x.</span>
<span class="sd">      elim x; clear x.</span>
<span class="sd">      intros a; cbn in a.</span>
<span class="sd">      intros x; cbn in x. </span>
<span class="sd">      elim x; clear x.</span>
<span class="sd">      intros b; cbn in b.</span>
<span class="sd">      intros p; cbn in p.</span>
<span class="sd">      (** [decomposing_intros] wouldn&#39;t be willing to destruct [p] here, because it&#39;s a path.  But [decomposing_intros_with_paths] will try it when all else fails. *)</span>
<span class="sd">      move p before a.</span>
<span class="sd">      generalize dependent a.</span>
<span class="sd">      not (move a at top).</span>
<span class="sd">      refine (paths_ind_r _ _ _).</span>
<span class="sd">      intros b; cbn in b.</span>
<span class="sd">      (** Here begins [build_record_with_evars] *)</span>
<span class="sd">      exact b.</span>
<span class="sd">    - (** Here begins [decomposing_intros_with_paths] *)</span>
<span class="sd">      intros b; cbn in b.</span>
<span class="sd">      (** Here begins [build_record_with_evars] *)</span>
<span class="sd">      cbn; unshelve econstructor.</span>
<span class="sd">      { let x := fresh in evar (x : A); exact x. }</span>
<span class="sd">      cbn; unshelve econstructor.</span>
<span class="sd">      { (** This instantiates the evar. *)</span>
<span class="sd">        exact b. }</span>
<span class="sd">      { cbn; unshelve econstructor. }</span>
<span class="sd">    - intros b; cbn in b.</span>
<span class="sd">      exact idpath.</span>
<span class="sd">    - intros x; cbn in x.</span>
<span class="sd">      elim x; clear x.</span>
<span class="sd">      intros a; cbn in a.</span>
<span class="sd">      intros x; cbn in x. </span>
<span class="sd">      elim x; clear x.</span>
<span class="sd">      intros b; cbn in b.</span>
<span class="sd">      intros p; cbn in p.</span>
<span class="sd">      move p before a.</span>
<span class="sd">      generalize dependent a.</span>
<span class="sd">      not (move a at top).</span>
<span class="sd">      refine (paths_ind_r _ _ _).</span>
<span class="sd">      intros b; cbn in b.</span>
<span class="sd">      exact idpath.</span>
<span class="sd">  Defined.</span>
<span class="sd">End Examples.</span>
<span class="sd">&gt;&gt;</span>
<span class="sd">*)</span>

<span class="sd">(** Some &quot;real-world&quot; examples where [make_equiv_contr_basedpaths] simplifies things a lot include [hfiber_compose] in [HFiber.v], [hfiber_pullback_along] in [Limits/Pullback.v], and [equiv_Ocodeleft2plus] in [BlakersMassey.v]. *)</span></span></span></pre>
</div>
</div></body>
</html>
