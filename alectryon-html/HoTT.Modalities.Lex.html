<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<title>Lex.v</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight"><span class="c">(* -*- mode: coq; mode: visual-line -*- *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> HoTT.Basics HoTT.Types.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> HFiber Extensions Pullback NullHomotopy Factorization PathAny Truncations.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Modality Accessible Localization Descent Separated.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local Open Scope</span> subuniverse_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** * Lex modalities *)</span>

<span class="sd">(** A lex modality is one that preserves finite limits, or equivalently pullbacks.  Many equivalent characterizations of this can be found in Theorem 3.1 of RSS.</span>

<span class="sd">We choose as our definition that a lex modality to be a reflective subuniverse such that [O &lt;&lt;&lt; O], which is close to (but not quite the same as) RSS Theorem 3.1 (xiii).</span>

<span class="sd">Note that since this includes [O &lt;&lt; O] as a precondition, such an [O] must indeed be a modality (and since modalities coerce to reflective subuniverses, in the following notation [O] could be either an element of [ReflectiveSubuniverse] or of [Modality]). *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Notation</span> <span class="nf">Lex</span> O := (O &lt;&lt;&lt; O).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Properties of lex modalities *)</span>

<span class="sd">(** We now show that lex modalities have all the other properties from RSS Theorem 3.1 (which are equivalent to lex-ness).  All of them are simple specializations of properties from [Descent.v] to the case [O&#39; = O] (although in the general case they are not known to be equivalent). *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">LexModality</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> (<span class="nv">O</span> : Modality) `{Lex O}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (i) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">isconnected_paths</span>
             {<span class="nv">A</span> : <span class="kt">Type</span>} `{IsConnected O A} (x y : A)
    : IsConnected O (x = y)
    := OO_isconnected_paths O O x y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (iii) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">conn_map_lex</span>
             {<span class="nv">Y</span> <span class="nv">X</span> : <span class="kt">Type</span>} `{IsConnected O Y, IsConnected O X} (f : Y -&gt; X)
    : IsConnMap O f
    := OO_conn_map_isconnected O O f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (iv) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_mapino_isconnected</span>
         {<span class="nv">Y</span> <span class="nv">X</span> : <span class="kt">Type</span>} `{IsConnected O Y, IsConnected O X}
         (f : Y -&gt; X) `{MapIn O _ _ f}
    : IsEquiv f
    := OO_isequiv_mapino_isconnected O O f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (vi) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">conn_map_functor_hfiber</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>}
             {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A -&gt; C} {<span class="nv">k</span> : B -&gt; D}
             `{IsConnMap O _ _ h, IsConnMap O _ _ k}
             (p : k o f == g o h) (b : B)
    : IsConnMap O (functor_hfiber p b)
    := OO_conn_map_functor_hfiber O O p b.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (vii) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ispullback_connmap_mapino_commsq</span>
             {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>} {<span class="nv">f</span> : A -&gt; B} {<span class="nv">g</span> : C -&gt; D} {<span class="nv">h</span> : A -&gt; C} {<span class="nv">k</span> : B -&gt; D}
             (<span class="nv">p</span> : k o f == g o h)
             `{O_inverts O h, O_inverts O k, MapIn O _ _ f, MapIn O _ _ g}
    : IsPullback p
    := OO_ispullback_connmap_mapino O O p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (viii) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">conn_map_functor_hfiber_to_O</span>
         {<span class="nv">Y</span> <span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : Y -&gt; X) (<span class="nv">x</span> : X)
    : IsConnMap O (functor_hfiber (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (to_O_natural O f y)^) x)
    := OO_conn_map_functor_hfiber_to_O O O f x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk0"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_O_functor_hfiber</span>
         {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B)
    : IsEquiv (O_functor_hfiber O f b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (O_functor_hfiber O f b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (O_functor_hfiber O f b)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2"><span class="highlight"><span class="nb">apply</span> (isequiv_O_rec_O_inverts O).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">O_inverts O
  (<span class="kr">fun</span> <span class="nv">X</span> : hfiber f b =&gt;
   (to O A X.<span class="mi">1</span>;
   to_O_natural O f X.<span class="mi">1</span> @ ap (to O B) X.<span class="mi">2</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk3"><span class="highlight"><span class="nb">apply</span> O_inverts_conn_map.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap O
  (<span class="kr">fun</span> <span class="nv">X</span> : hfiber f b =&gt;
   (to O A X.<span class="mi">1</span>;
   to_O_natural O f X.<span class="mi">1</span> @ ap (to O B) X.<span class="mi">2</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk4"><span class="highlight"><span class="nb">refine</span> (conn_map_homotopic
              O (functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> =&gt; (to_O_natural O f x)^) b)
              _ _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (to_O_natural O f x)^) b ==
(<span class="kr">fun</span> <span class="nv">X</span> : hfiber f b =&gt;
 (to O A X.<span class="mi">1</span>; to_O_natural O f X.<span class="mi">1</span> @ ap (to O B) X.<span class="mi">2</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5"><span class="highlight"><span class="nb">intros</span> [a p].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f a = b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">functor_hfiber (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (to_O_natural O f x)^) b
  (a; p) =
(to O A a; to_O_natural O f a @ ap (to O B) p)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6"><span class="highlight"><span class="nb">unfold</span> functor_hfiber, functor_sigma.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f a = b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(to O A (a; p).<span class="mi">1</span>;
((to_O_natural O f (a; p).<span class="mi">1</span>)^)^ @ ap (to O B) (a; p).<span class="mi">2</span>) =
(to O A a; to_O_natural O f a @ ap (to O B) p)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7"><span class="highlight"><span class="nb">apply</span> ap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f a = b</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((to_O_natural O f (a; p).<span class="mi">1</span>)^)^ @ ap (to O B) (a; p).<span class="mi">2</span> =
to_O_natural O f a @ ap (to O B) p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> whiskerR, inv_V.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_O_functor_hfiber</span>
             {<span class="nv">A</span> <span class="nv">B</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B)
    : O (hfiber f b) &lt;~&gt; hfiber (O_functor O f) (to O B b)
    := Build_Equiv _ _ (O_functor_hfiber O f b) _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (ix) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">isequiv_path_O</span>
         {<span class="nv">X</span> : <span class="kt">Type</span>@{i}} (<span class="nv">x</span> <span class="nv">y</span> : X)
    : IsEquiv (path_OO O O x y)
    := isequiv_path_OO O O x y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_path_O</span> {<span class="nv">X</span> : <span class="kt">Type</span>@{i}} (<span class="nv">x</span> <span class="nv">y</span> : X)
    : O (x = y) &lt;~&gt; (to O X x = to O X y)
    := equiv_path_OO O O x y.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_path_O_to_O</span> {<span class="nv">X</span> : <span class="kt">Type</span>} (<span class="nv">x</span> <span class="nv">y</span> : X)
    : (equiv_path_O x y) o (to O (x = y)) == @ap _ _ (to O X) x y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_path_O x y o to O (x = y) == ap (to O X)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equiv_path_O x y o to O (x = y) == ap (to O X)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka"><span class="highlight"><span class="nb">intros</span> p; <span class="nb">unfold</span> equiv_path_O, equiv_path_OO, path_OO; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">x = y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">O_rec (ap (to (modality_subuniv O) X))
  (to (modality_subuniv O) (x = y) p) =
ap (to (modality_subuniv O) X) p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> O_rec_beta.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (x).  This justifies the term &quot;left exact&quot;. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">O_inverts_functor_pullback_to_O</span>
         {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B -&gt; A) (<span class="nv">g</span> : C -&gt; A)
    : O_inverts O (functor_pullback f g (O_functor O f) (O_functor O g)
                                    (to O A) (to O B) (to O C)
                                    (to_O_natural O f) (to_O_natural O g))
    := OO_inverts_functor_pullback_to_O O O f g.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equiv_O_pullback</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B -&gt; A) (<span class="nv">g</span> : C -&gt; A)
    : O (Pullback f g) &lt;~&gt; Pullback (O_functor O f) (O_functor O g)
    := equiv_O_rec_O_inverts
         O (functor_pullback f g (O_functor O f) (O_functor O g)
                             (to O A) (to O B) (to O C)
                             (to_O_natural O f) (to_O_natural O g)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb"><span class="highlight"><span class="kn">Definition</span> <span class="nf">O_functor_pullback</span>
             {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : B -&gt; A) (<span class="nv">g</span> : C -&gt; A)
    : IsPullback (O_functor_square O _ _ _ _ (pullback_commsq f g)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsPullback
  (O_functor_square O pullback_pr1 pullback_pr2 f g
     (pullback_commsq f g))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsPullback
  (O_functor_square O pullback_pr1 pullback_pr2 f g
     (pullback_commsq f g))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd"><span class="highlight"><span class="nb">unfold</span> IsPullback.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv
  (pullback_corec
     (O_functor_square O pullback_pr1 pullback_pr2 f g
        (pullback_commsq f g)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chke"><span class="highlight">nrapply (isequiv_homotopic
               (O_rec (functor_pullback _ _ _ _ _ _ _
                                        (to_O_natural O f) (to_O_natural O g)))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv
  (O_rec
     (functor_pullback f g (O_functor O f)
        (O_functor O g) (to O A) (to O B) (to O C)
        (to_O_natural O f) (to_O_natural O g)))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chkf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chkf"><hr></label><div class="goal-conclusion"><span class="highlight">O_rec
  (functor_pullback f g (O_functor O f)
     (O_functor O g) (to O A) 
     (to O B) (to O C) (to_O_natural O f)
     (to_O_natural O g)) ==
pullback_corec
  (O_functor_square O pullback_pr1 pullback_pr2 f g
     (pullback_commsq f g))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk10"><span class="highlight"><span class="mi">1</span>:<span class="nb">apply</span> isequiv_O_rec_O_inverts; <span class="bp">exact</span> _.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">O_rec
  (functor_pullback f g (O_functor O f)
     (O_functor O g) (to O A) (to O B) (to O C)
     (to_O_natural O f) (to_O_natural O g)) ==
pullback_corec
  (O_functor_square O pullback_pr1 pullback_pr2 f g
     (pullback_commsq f g))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk11"><span class="highlight"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> [b [c e]].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">O_rec
  (functor_pullback f g (O_functor O f)
     (O_functor O g) (to O A) (to O B) (to O C)
     (to_O_natural O f) (to_O_natural O g))
  (to O (Pullback f g) (b; c; e)) =
pullback_corec
  (O_functor_square O pullback_pr1 pullback_pr2 f g
     (pullback_commsq f g))
  (to O (Pullback f g) (b; c; e))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk12"><span class="highlight"><span class="nb">refine</span> (O_rec_beta _ _ @ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">functor_pullback f g (O_functor O f) (O_functor O g)
  (to O A) (to O B) (to O C) (to_O_natural O f)
  (to_O_natural O g) (b; c; e) =
pullback_corec
  (O_functor_square O pullback_pr1 pullback_pr2 f g
     (pullback_commsq f g))
  (to O (Pullback f g) (b; c; e))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="sd">(** This *seems* like it ought to be the easier goal, but it turns out to involve lots of naturality wrangling.  If we ever want to make real use of this theorem, we might want to separate out this goal into an opaque lemma so we could make the main theorem transparent. *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk13"><span class="highlight"><span class="nb">unfold</span> functor_pullback, functor_sigma, pullback_corec; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(to (modality_subuniv O) B b;
to (modality_subuniv O) C c;
(to_O_natural O f b @ ap (to (modality_subuniv O) A) e) @
(to_O_natural O g c)^) =
(O_functor O pullback_pr1
   (to (modality_subuniv O) (Pullback f g) (b; c; e));
O_functor O pullback_pr2
  (to (modality_subuniv O) (Pullback f g) (b; c; e));
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to (modality_subuniv O) (Pullback f g) (b; c; e)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk14"><span class="highlight"><span class="nb">refine</span> (path_sigma&#39; _ (to_O_natural O pullback_pr1 (b;(c;e)))^ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">b</span> : O_reflector (modality_subuniv O) B =&gt;
   {c : O_reflector (modality_subuniv O) C &amp;
   O_functor O f b = O_functor O g c})
  (to_O_natural O pullback_pr1 (b; c; e))^
  (to (modality_subuniv O) C c;
  (to_O_natural O f b @
   ap (to (modality_subuniv O) A) e) @
  (to_O_natural O g c)^) =
(O_functor O pullback_pr2
   (to (modality_subuniv O) (Pullback f g) (b; c; e));
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to (modality_subuniv O) (Pullback f g) (b; c; e)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk15"><span class="highlight"><span class="nb">rewrite</span> transport_sigma&#39;; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(to (modality_subuniv O) C c;
transport
  (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt;
   O_functor O f x =
   O_functor O g (to (modality_subuniv O) C c))
  (to_O_natural O pullback_pr1 (b; c; e))^
  ((to_O_natural O f b @
    ap (to (modality_subuniv O) A) e) @
   (to_O_natural O g c)^)) =
(O_functor O pullback_pr2
   (to (modality_subuniv O) (Pullback f g) (b; c; e));
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to (modality_subuniv O) (Pullback f g) (b; c; e)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk16"><span class="highlight"><span class="nb">refine</span> (path_sigma&#39; _ (to_O_natural O pullback_pr2 (b;(c;e)))^ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">c0</span> : O_reflector (modality_subuniv O) C =&gt;
   O_functor O f
     (O_functor O pullback_pr1
        (to (modality_subuniv O) (Pullback f g)
           (b; c; e))) = O_functor O g c0)
  (to_O_natural O pullback_pr2 (b; c; e))^
  (transport
     (<span class="kr">fun</span> <span class="nv">x</span> : O B =&gt;
      O_functor O f x =
      O_functor O g (to (modality_subuniv O) C c))
     (to_O_natural O pullback_pr1 (b; c; e))^
     ((to_O_natural O f b @
       ap (to (modality_subuniv O) A) e) @
      (to_O_natural O g c)^)) =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to (modality_subuniv O) (Pullback f g) (b; c; e))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk17"><span class="highlight"><span class="nb">rewrite</span> transport_paths_Fl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport
  (<span class="kr">fun</span> <span class="nv">c0</span> : O_reflector (modality_subuniv O) C =&gt;
   O_functor O f
     (O_functor O pullback_pr1
        (to (modality_subuniv O) (Pullback f g)
           (b; c; e))) = O_functor O g c0)
  (to_O_natural O pullback_pr2 (b; c; e))^
  ((ap (O_functor O f)
      (to_O_natural O pullback_pr1 (b; c; e))^)^ @
   ((to_O_natural O f b @
     ap (to (modality_subuniv O) A) e) @
    (to_O_natural O g c)^)) =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to (modality_subuniv O) (Pullback f g) (b; c; e))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk18"><span class="highlight"><span class="nb">rewrite</span> transport_paths_Fr.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((ap (O_functor O f)
    (to_O_natural O pullback_pr1 (b; c; e))^)^ @
 ((to_O_natural O f b @
   ap (to (modality_subuniv O) A) e) @
  (to_O_natural O g c)^)) @
ap (O_functor O g)
  (to_O_natural O pullback_pr2 (b; c; e))^ =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to (modality_subuniv O) (Pullback f g) (b; c; e))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk19"><span class="highlight"><span class="kn">Open Scope</span> long_path_scope.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(ap (O_functor O f)
   (to_O_natural O pullback_pr1 (b; c; e))^)^
@&#39; (to_O_natural O f b
    @&#39; ap (to (modality_subuniv O) A) e
    @&#39; (to_O_natural O g c)^)
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))^ =
O_functor_square O pullback_pr1 pullback_pr2 f g
  (pullback_commsq f g)
  (to (modality_subuniv O) (Pullback f g) (b; c; e))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1a"><span class="highlight"><span class="nb">unfold</span> O_functor_square.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(ap (O_functor O f)
   (to_O_natural O pullback_pr1 (b; c; e))^)^
@&#39; (to_O_natural O f b
    @&#39; ap (to (modality_subuniv O) A) e
    @&#39; (to_O_natural O g c)^)
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))^ =
(O_functor_compose O pullback_pr1 f
   (to (modality_subuniv O) (Pullback f g) (b; c; e)))^
@&#39; (O_functor_homotopy O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
      (pullback_commsq f g)
      (to (modality_subuniv O) (Pullback f g)
         (b; c; e))
    @&#39; O_functor_compose O pullback_pr2 g
         (to (modality_subuniv O) (Pullback f g)
            (b; c; e)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1b"><span class="highlight"><span class="nb">rewrite</span> ap_V, inv_V, O_functor_homotopy_beta, !concat_p_pp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (O_functor O f)
  (to_O_natural O pullback_pr1 (b; c; e))
@&#39; to_O_natural O f b
@&#39; ap (to (modality_subuniv O) A) e
@&#39; (to_O_natural O g c)^
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))^ =
(O_functor_compose O pullback_pr1 f
   (to (modality_subuniv O) (Pullback f g) (b; c; e)))^
@&#39; to_O_natural O
     (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
     (b; c; e)
@&#39; ap (to O A) (pullback_commsq f g (b; c; e))
@&#39; (to_O_natural O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
      (b; c; e))^
@&#39; O_functor_compose O pullback_pr2 g
     (to (modality_subuniv O) (Pullback f g) (b; c; e))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1c"><span class="highlight"><span class="nb">unfold</span> pullback_commsq; <span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (O_functor O f)
  (to_O_natural O pullback_pr1 (b; c; e))
@&#39; to_O_natural O f b
@&#39; ap (to (modality_subuniv O) A) e
@&#39; (to_O_natural O g c)^
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))^ =
(O_functor_compose O pullback_pr1 f
   (to (modality_subuniv O) (Pullback f g) (b; c; e)))^
@&#39; to_O_natural O
     (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
     (b; c; e)
@&#39; ap (to (modality_subuniv O) A) e
@&#39; (to_O_natural O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
      (b; c; e))^
@&#39; O_functor_compose O pullback_pr2 g
     (to (modality_subuniv O) (Pullback f g) (b; c; e))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1d"><span class="highlight"><span class="nb">rewrite</span> to_O_natural_compose, !concat_pp_p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(O_functor_compose O pullback_pr1 f
   (to O (Pullback f g) (b; c; e)))^
@&#39; (to_O_natural O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
      (b; c; e)
    @&#39; (ap (to (modality_subuniv O) A) e
        @&#39; ((to_O_natural O g c)^
            @&#39; ap (O_functor O g)
                 (to_O_natural O pullback_pr2
                    (b; c; e))^))) =
(O_functor_compose O pullback_pr1 f
   (to (modality_subuniv O) (Pullback f g) (b; c; e)))^
@&#39; (to_O_natural O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; f (pullback_pr1 x))
      (b; c; e)
    @&#39; (ap (to (modality_subuniv O) A) e
        @&#39; ((to_O_natural O
               (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt;
                g (pullback_pr2 x)) (b; c; e))^
            @&#39; O_functor_compose O pullback_pr2 g
                 (to (modality_subuniv O)
                    (Pullback f g) (b; c; e)))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1e"><span class="highlight"><span class="kp">do</span> <span class="mi">3</span> <span class="nb">apply</span> whiskerL.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(to_O_natural O g c)^
@&#39; ap (O_functor O g)
     (to_O_natural O pullback_pr2 (b; c; e))^ =
(to_O_natural O
   (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
   (b; c; e))^
@&#39; O_functor_compose O pullback_pr2 g
     (to (modality_subuniv O) (Pullback f g) (b; c; e))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk1f"><span class="highlight"><span class="nb">rewrite</span> ap_V, &lt;- inv_pp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(ap (O_functor O g)
   (to_O_natural O pullback_pr2 (b; c; e))
 @&#39; to_O_natural O g c)^ =
(to_O_natural O
   (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
   (b; c; e))^
@&#39; O_functor_compose O pullback_pr2 g
     (to (modality_subuniv O) (Pullback f g) (b; c; e))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk20"><span class="highlight"><span class="nb">rewrite</span> &lt;- (inv_V (O_functor_compose _ _ _ _)), &lt;- inv_pp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B, C</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">C</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">e</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f b = g c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(ap (O_functor O g)
   (to_O_natural O pullback_pr2 (b; c; e))
 @&#39; to_O_natural O g c)^ =
((O_functor_compose O pullback_pr2 g
    (to (modality_subuniv O) (Pullback f g) (b; c; e)))^
 @&#39; to_O_natural O
      (<span class="kr">fun</span> <span class="nv">x</span> : Pullback f g =&gt; g (pullback_pr2 x))
      (b; c; e))^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> inverse2, to_O_natural_compose.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Close Scope</span> long_path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk21"><span class="highlight"><span class="kn">Definition</span> <span class="nf">diagonal_O_functor</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B)
    : diagonal (O_functor O f) == equiv_O_pullback f f o O_functor O (diagonal f).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">diagonal (O_functor O f) ==
equiv_O_pullback f f o O_functor O (diagonal f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk22"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">diagonal (O_functor O f) ==
equiv_O_pullback f f o O_functor O (diagonal f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk23"><span class="highlight"><span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">diagonal (O_functor O f) (to O A x) =
equiv_O_pullback f f
  (O_functor O (diagonal f) (to O A x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk24"><span class="highlight"><span class="nb">refine</span> (_ @ (ap _ (to_O_natural _ _ _))^).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">diagonal (O_functor O f) (to O A x) =
equiv_O_pullback f f
  (to O (Pullback f f) (diagonal f x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk25"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">diagonal (O_functor O f) (to (modality_subuniv O) A x) =
O_rec
  (functor_pullback f f (O_functor O f)
     (O_functor O f) (to (modality_subuniv O) B)
     (to (modality_subuniv O) A)
     (to (modality_subuniv O) A) (to_O_natural O f)
     (to_O_natural O f))
  (to (modality_subuniv O) (Pullback f f)
     (diagonal f x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk26"><span class="highlight"><span class="nb">refine</span> (_ @ (O_rec_beta _ _)^).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">diagonal (O_functor O f) (to (modality_subuniv O) A x) =
functor_pullback f f (O_functor O f) (O_functor O f)
  (to (modality_subuniv O) B)
  (to (modality_subuniv O) A)
  (to (modality_subuniv O) A) (to_O_natural O f)
  (to_O_natural O f) (diagonal f x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk27"><span class="highlight"><span class="nb">unfold</span> diagonal, functor_pullback, functor_sigma; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(to (modality_subuniv O) A x;
to (modality_subuniv O) A x; <span class="mi">1</span>) =
(to (modality_subuniv O) A x;
to (modality_subuniv O) A x;
(to_O_natural O f x @ <span class="mi">1</span>) @ (to_O_natural O f x)^)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk28"><span class="highlight"><span class="nb">apply</span> ap, ap.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> = (to_O_natural O f x @ <span class="mi">1</span>) @ (to_O_natural O f x)^</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> moveL_pV; <span class="bp">exact</span> (concat_1p _ @ (concat_p1 _)^).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (xi) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">cancelL_conn_map</span>
             {<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : Y -&gt; X) (<span class="nv">g</span> : X -&gt; Z)
             `{IsConnMap O _ _ (g o f)} `{IsConnMap O _ _ g}
    : IsConnMap O f
    := OO_cancelL_conn_map O O f g.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (xii) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">conn_map_O_inverts</span>
         {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) `{O_inverts O f}
    : IsConnMap O f
    := conn_map_OO_inverts O O f.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (xiii) *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk29"><span class="highlight"><span class="kn">Definition</span> <span class="nf">modal_over_connected_isconst_lex</span>
             (<span class="nv">A</span> : <span class="kt">Type</span>) `{IsConnected O A}
             (P : A -&gt; <span class="kt">Type</span>) `{<span class="kr">forall</span> <span class="nv">x</span>, In O (P x)}
    : {Q : <span class="kt">Type</span> &amp; In O Q * <span class="kr">forall</span> <span class="nv">x</span>, Q &lt;~&gt; P x}.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2b"><span class="highlight"><span class="nb">pose proof</span> (O_inverts_isconnected O (<span class="kr">fun</span> <span class="nv">_</span>:A =&gt; tt)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_inverts O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2c"><span class="highlight"><span class="kr">exists</span> (<span class="nv">OO_descend_O_inverts</span> <span class="nv">O</span> <span class="nv">O</span> (<span class="kr">fun</span> <span class="nv">_</span>:A =&gt; tt) P tt); <span class="nb">split</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_inverts O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In O (OO_descend_O_inverts O O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt) P tt)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk2d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_inverts O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk2d"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A,
OO_descend_O_inverts O O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt) P tt &lt;~&gt;
P x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2e"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_inverts O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In O (OO_descend_O_inverts O O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt) P tt)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> OO_descend_O_inverts_inO.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk2f"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_inverts O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A,
OO_descend_O_inverts O O (<span class="kr">fun</span> <span class="nv">_</span> : A =&gt; tt) P tt &lt;~&gt;
P x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span>; rapply OO_descend_O_inverts_beta.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">  
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.11 (iii): in the accessible case, the universe is modal. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Instance</span> <span class="nf">inO_typeO_lex</span> `{Univalence} `{IsAccRSU O}
    : In (lift_accrsu O) (Type_ O)
    := _.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** Part of RSS Corollary 3.9: lex modalities preserve [n]-types for all [n].  This is definitely not equivalent to lex-ness, since it is true for the truncation modalities that are not lex.  But it is also not true of all modalities; e.g. the shape modality in a cohesive topos can take 0-types to [oo]-types.  With a little more work, this can probably be proven without [Funext]. *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk30"><span class="highlight"><span class="kn">Instance</span> <span class="nf">istrunc_O_lex</span> `{Funext}
         {n : trunc_index} {A : <span class="kt">Type</span>} `{IsTrunc n A}
    : IsTrunc n (O A).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTrunc n A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n (O A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk31"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTrunc n A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n (O A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk32"><span class="highlight"><span class="nb">generalize dependent</span> A; simple_induction n n IHn; <span class="nb">intros</span> A ?.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (O A)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsTrunc n A -&gt; IsTrunc n (O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTrunc n.+<span class="mi">1</span> A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk33"><hr></label><div class="goal-conclusion"><span class="highlight">IsTrunc n.+<span class="mi">1</span> (O A)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk34"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Contr A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (O A)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> _.               <span class="sd">(** Already proven for all modalities. *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk35"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsTrunc n A -&gt; IsTrunc n (O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTrunc n.+<span class="mi">1</span> A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n.+<span class="mi">1</span> (O A)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk36"><span class="highlight"><span class="nb">refine</span> (O_ind (<span class="kr">fun</span> <span class="nv">x</span> =&gt; <span class="kr">forall</span> <span class="nv">y</span>, IsTrunc n (x = y)) _); <span class="nb">intros</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsTrunc n A -&gt; IsTrunc n (O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTrunc n.+<span class="mi">1</span> A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : O_reflector O A, IsTrunc n (to O A x = y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk37"><span class="highlight"><span class="nb">refine</span> (O_ind (<span class="kr">fun</span> <span class="nv">y</span> =&gt; IsTrunc n (to O A x = y)) _); <span class="nb">intros</span> y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Funext</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>, IsTrunc n A -&gt; IsTrunc n (O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTrunc n.+<span class="mi">1</span> A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTrunc n (to O A x = to O A y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (istrunc_equiv_istrunc _ (equiv_path_O x y)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">LexModality</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Equivalent characterizations of lex-ness *)</span>

<span class="sd">(** We will not prove that *all* of the above properties from RSS Theorem 3.1 are equivalent to lex-ness, but we will do it for some of them. *)</span>

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">ImpliesLex</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span> {<span class="nv">O</span> : Modality}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS 3.1 (xiii) implies lexness *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk38"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lex_from_modal_over_connected_isconst</span>
             (<span class="nv">H</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">A_isC</span> : IsConnected O A)
                         (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>) (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x</span>, In O (P x)),
                 {Q : <span class="kt">Type</span> &amp; In O Q * <span class="kr">forall</span> <span class="nv">x</span>, Q &lt;~&gt; P x})
    : Lex O.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk39"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk3a"><span class="highlight"><span class="nb">intros</span> A; <span class="nb">unshelve</span> <span class="nb">econstructor</span>; <span class="nb">intros</span> P P_inO.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">O_reflector O A -&gt; <span class="kt">Type</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk3b"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : O_reflector O A,
In O
  ((<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
      (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt; 
    <span class="nl">?Goal</span>) P P_inO x)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk3c"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
   (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt; 
 <span class="nl">?Goal</span>) P P_inO (to O A x) &lt;~&gt; 
P x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk3d"><span class="highlight"><span class="kp">all</span>:<span class="nb">pose</span> (Q := <span class="kr">fun</span> <span class="nv">z</span>:O A =&gt; H (hfiber (to O A) z) _ (P o pr1) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">O_reflector O A -&gt; <span class="kt">Type</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk3e"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : O_reflector O A,
In O
  ((<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
      (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt;
    <span class="kr">let</span> <span class="nv">Q</span> :=
      <span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
      H (hfiber (to O A) z)
        (isconnected_hfiber_conn_map z) 
        (P o pr1)
        (<span class="kr">fun</span> <span class="nv">x0</span> : hfiber (to O A) z =&gt; P_inO x0.<span class="mi">1</span>) <span class="kr">in</span>
    <span class="nl">?Goal</span>) P P_inO x)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chk3f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk3f"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
   (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt;
 <span class="kr">let</span> <span class="nv">Q</span> :=
   <span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
   H (hfiber (to O A) z)
     (isconnected_hfiber_conn_map z) 
     (P o pr1)
     (<span class="kr">fun</span> <span class="nv">x0</span> : hfiber (to O A) z =&gt; P_inO x0.<span class="mi">1</span>) <span class="kr">in</span>
 <span class="nl">?Goal</span>) P P_inO (to O A x) &lt;~&gt; 
P x</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk40"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">O_reflector O A -&gt; <span class="kt">Type</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">z</span> =&gt; (Q z).<span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk41"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : O_reflector O A,
In O
  ((<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
      (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt;
    <span class="kr">let</span> <span class="nv">Q</span> :=
      <span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
      H (hfiber (to O A) z)
        (isconnected_hfiber_conn_map z) (P o pr1)
        (<span class="kr">fun</span> <span class="nv">x0</span> : hfiber (to O A) z =&gt; P_inO x0.<span class="mi">1</span>) <span class="kr">in</span>
    <span class="kr">fun</span> <span class="nv">z</span> : O_reflector O A =&gt; (Q z).<span class="mi">1</span>) P P_inO x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (<span class="kr">fun</span> <span class="nv">z</span> =&gt; fst (Q z).<span class="mi">2</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk42"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">fun</span> (<span class="nv">P</span> : A -&gt; <span class="kt">Type</span>)
   (<span class="nv">P_inO</span> : <span class="kr">forall</span> <span class="nv">x0</span> : A, In O (P x0)) =&gt;
 <span class="kr">let</span> <span class="nv">Q</span> :=
   <span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
   H (hfiber (to O A) z)
     (isconnected_hfiber_conn_map z) (P o pr1)
     (<span class="kr">fun</span> <span class="nv">x0</span> : hfiber (to O A) z =&gt; P_inO x0.<span class="mi">1</span>) <span class="kr">in</span>
 <span class="kr">fun</span> <span class="nv">z</span> : O_reflector O A =&gt; (Q z).<span class="mi">1</span>) P P_inO
  (to O A x) &lt;~&gt; P x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk43"><span class="highlight"><span class="nb">intros</span> x; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)) -&gt;
{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Q</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">z</span> : O A =&gt;
H (hfiber (to O A) z)
  (isconnected_hfiber_conn_map z) 
  (P o pr1)
  (<span class="kr">fun</span> <span class="nv">x</span> : hfiber (to O A) z =&gt; P_inO x.<span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">z</span> : O A,
{Q : <span class="kt">Type</span> &amp;
In O Q *
(<span class="kr">forall</span> <span class="nv">x</span> : hfiber (to O A) z, Q &lt;~&gt; (P o pr1) x)}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(H
   (hfiber (to (modality_subuniv O) A)
      (to (modality_subuniv O) A x))
   (isconnected_hfiber_conn_map
      (to (modality_subuniv O) A x))
   (<span class="kr">fun</span>
      <span class="nv">x</span> : {x0 : A &amp;
          to (modality_subuniv O) A x0 =
          to (modality_subuniv O) A x} =&gt; P x.<span class="mi">1</span>)
   (<span class="kr">fun</span>
      <span class="nv">x</span> : hfiber (to (modality_subuniv O) A)
            (to (modality_subuniv O) A x) =&gt; P_inO x.<span class="mi">1</span>)).<span class="mi">1</span> &lt;~&gt;
P x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (snd (Q (to O A x)).<span class="mi">2</span> (x;<span class="mi">1</span>)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS 3.11 (iii), the universe is modal, implies lex-ness *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk44"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lex_from_inO_typeO</span> `{IsAccRSU O} `{In (lift_accrsu O) (Type_ O)}
    : Lex O.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccRSU O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (lift_accrsu O) (Type_ O)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk45"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccRSU O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (lift_accrsu O) (Type_ O)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> (O_lex_leq_inO_TypeO O O).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (xi) implies lex-ness *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk46"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lex_from_cancelL_conn_map</span>
             (<span class="nv">cancel</span> : <span class="kr">forall</span> {<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : Y -&gt; X) (<span class="nv">g</span> : X -&gt; Z),
                 (IsConnMap O (g o f)) -&gt; (IsConnMap O g)
                 -&gt; IsConnMap O f)
    : Lex O.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk47"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk48"><span class="highlight"><span class="nb">apply</span> lex_from_modal_over_connected_isconst; <span class="nb">intros</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{Q : <span class="kt">Type</span> &amp; In O Q * (<span class="kr">forall</span> <span class="nv">x</span> : A, Q &lt;~&gt; P x)}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk49"><span class="highlight"><span class="kr">exists</span> (<span class="nv">O</span> {x:A &amp; P x}); <span class="nb">split</span>; [ <span class="bp">exact</span> _ | <span class="nb">intros</span> x; <span class="nb">symmetry</span> ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P x &lt;~&gt; O {x : A &amp; P x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk4a"><span class="highlight"><span class="nb">refine</span> (Build_Equiv _ _ (<span class="kr">fun</span> <span class="nv">p</span> =&gt; to O _ (x ; p)) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">p</span> : P x =&gt; to O {x : A &amp; P x} (x; p))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk4b"><span class="highlight">nrefine (isequiv_conn_map_ino O _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In O (P x)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk4c"><hr></label><div class="goal-conclusion"><span class="highlight">In O (O_reflector O {x : A &amp; P x})</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chk4d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk4d"><hr></label><div class="goal-conclusion"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">p</span> : P x =&gt; to O {x : A &amp; P x} (x; p))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk4e"><span class="highlight"><span class="mi">1</span>-<span class="mi">2</span>:<span class="bp">exact</span> _.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">p</span> : P x =&gt; to O {x : A &amp; P x} (x; p))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk4f"><span class="highlight"><span class="nb">revert</span> x; <span class="nb">apply</span> conn_map_fiber.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap O
  (functor_sigma idmap
     (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">p</span> : P a) =&gt;
      to O {x : A &amp; P x} (a; p)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk50"><span class="highlight">nrefine (cancel _ _ _ _ (<span class="kr">fun</span> <span class="nv">z</span>:{x:A &amp; O {x : A &amp; P x}} =&gt; z.<span class="mi">2</span>) _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap O
  (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; P x} =&gt;
   (functor_sigma idmap
      (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">p</span> : P a) =&gt;
       to O {x0 : A &amp; P x0} (a; p)) x).<span class="mi">2</span>)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk51" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk51"><hr></label><div class="goal-conclusion"><span class="highlight">IsConnMap O
  (<span class="kr">fun</span> <span class="nv">z</span> : {_ : A &amp; O {x0 : A &amp; P x0}} =&gt; z.<span class="mi">2</span>)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk52"><span class="highlight"><span class="mi">1</span>: <span class="nb">clear</span> cancel; <span class="bp">exact</span> _.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap O
  (<span class="kr">fun</span> <span class="nv">z</span> : {_ : A &amp; O {x0 : A &amp; P x0}} =&gt; z.<span class="mi">2</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk53"><span class="highlight"><span class="nb">intros</span> z.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; P x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected O
  (hfiber (<span class="kr">fun</span> <span class="nv">z</span> : {_ : A &amp; O {x0 : A &amp; P x0}} =&gt; z.<span class="mi">2</span>)
     z)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk54"><span class="highlight"><span class="nb">refine</span> (isconnected_equiv&#39; O A _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; P x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A &lt;~&gt;
hfiber (<span class="kr">fun</span> <span class="nv">z</span> : {_ : A &amp; O {x0 : A &amp; P x0}} =&gt; z.<span class="mi">2</span>) z</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk55"><span class="highlight"><span class="nb">unfold</span> hfiber.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; P x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">A &lt;~&gt; {x : {_ : A &amp; O {x0 : A &amp; P x0}} &amp; x.<span class="mi">2</span> = z}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk56"><span class="highlight"><span class="nb">refine</span> (equiv_adjointify (<span class="kr">fun</span> <span class="nv">x</span> =&gt; ((x ; z) ; <span class="mi">1</span>))
                             (<span class="kr">fun</span> <span class="nv">y</span> =&gt; y.<span class="mi">1</span>.<span class="mi">1</span>) _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; P x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : {x : {_ : A &amp; O {x0 : A &amp; P x0}} &amp; x.<span class="mi">2</span> = z}
 =&gt; (((x.<span class="mi">1</span>).<span class="mi">1</span>; z); <span class="mi">1</span>)) == idmap</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk57" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; P x}</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk57"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (((x; z); <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span>) == idmap</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk58"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; P x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : {x : {_ : A &amp; O {x0 : A &amp; P x0}} &amp; x.<span class="mi">2</span> = z}
 =&gt; (((x.<span class="mi">1</span>).<span class="mi">1</span>; z); <span class="mi">1</span>)) == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> [[x y] []]; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk59"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cancel</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X)
(<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (g o f) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A_isC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : A, In O (P x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; P x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (((x; z); <span class="mi">1</span>).<span class="mi">1</span>).<span class="mi">1</span>) == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> x; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (iii) implies lex-ness *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5a"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lex_from_conn_map_lex</span>
             (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B),
                 (IsConnected O A) -&gt; (IsConnected O B) -&gt;
                 IsConnMap O f)
    : Lex O.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5c"><span class="highlight"><span class="nb">apply</span> lex_from_cancelL_conn_map.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">Y</span> <span class="nv">X</span> <span class="nv">Z</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : Y -&gt; X) (<span class="nv">g</span> : X -&gt; Z),
IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x)) -&gt;
IsConnMap O g -&gt; IsConnMap O f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5d"><span class="highlight"><span class="nb">intros</span> Y X Z f g gfc gc x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected O (hfiber f x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5e"><span class="highlight"><span class="nb">pose</span> (h := @functor_hfiber Y Z X Z (g o f) g f idmap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; <span class="mi">1</span>%path)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : Z,
hfiber (g o f) b -&gt; hfiber g (idmap b)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected O (hfiber f x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk5f"><span class="highlight"><span class="nb">assert</span> (cc := H _ _ (h (g x)) (gfc (g x)) (gc (g x))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : Z,
hfiber (g o f) b -&gt; hfiber g (idmap b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (h (g x))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected O (hfiber f x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk60"><span class="highlight"><span class="nb">refine</span> (isconnected_equiv&#39; O _ _ (cc (x;<span class="mi">1</span>))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : Z,
hfiber (g o f) b -&gt; hfiber g (idmap b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (h (g x))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber (h (g x)) (x; <span class="mi">1</span>) &lt;~&gt; hfiber f x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk61"><span class="highlight"><span class="nb">unfold</span> hfiber.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">b</span> : Z,
hfiber (g o f) b -&gt; hfiber g (idmap b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (h (g x))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x0 : {x0 : Y &amp; g (f x0) = g x} &amp; h (g x) x0 = (x; <span class="mi">1</span>)} &lt;~&gt;
{x0 : Y &amp; f x0 = x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk62"><span class="highlight"><span class="nb">subst</span> h; <span class="nb">unfold</span> functor_hfiber, functor_sigma; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x0 : {x0 : Y &amp; g (f x0) = g x} &amp;
(f x0.<span class="mi">1</span>; <span class="mi">1</span> @ ap idmap x0.<span class="mi">2</span>) = (x; <span class="mi">1</span>)} &lt;~&gt;
{x0 : Y &amp; f x0 = x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk63"><span class="highlight"><span class="nb">refine</span> (_ oE (equiv_sigma_assoc _ _)^-<span class="mi">1</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{a : Y &amp;
{p : g (f a) = g x &amp;
(f (a; p).<span class="mi">1</span>; <span class="mi">1</span> @ ap idmap (a; p).<span class="mi">2</span>) = (x; <span class="mi">1</span>)}} &lt;~&gt;
{x0 : Y &amp; f x0 = x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk64"><span class="highlight"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> y; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{p : g (f y) = g x &amp; (f y; <span class="mi">1</span> @ ap idmap p) = (x; <span class="mi">1</span>)} &lt;~&gt;
f y = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk65"><span class="highlight"><span class="nb">refine</span> (_ oE (equiv_functor_sigma_id _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x : _ &amp; <span class="nl">?Goal0</span> x} &lt;~&gt; f y = x</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk66" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk66"><hr></label><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : g (f y) = g x,
(f y; <span class="mi">1</span> @ ap idmap a) = (x; <span class="mi">1</span>) &lt;~&gt; <span class="nl">?Goal0</span> a</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk67"><span class="highlight"><span class="mi">2</span>:<span class="nb">intros</span>; <span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_path_sigma.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{a : g (f y) = g x &amp;
{p : (f y; <span class="mi">1</span> @ ap idmap a).<span class="mi">1</span> = (x; <span class="mi">1</span>).<span class="mi">1</span> &amp;
transport (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; g x0 = g x) p
  (f y; <span class="mi">1</span> @ ap idmap a).<span class="mi">2</span> = (x; <span class="mi">1</span>).<span class="mi">2</span>}} &lt;~&gt; f y = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk68"><span class="highlight"><span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{a : g (f y) = g x &amp;
{p : f y = x &amp;
transport (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; g x0 = g x) p
  (<span class="mi">1</span> @ ap idmap a) = <span class="mi">1</span>}} &lt;~&gt; f y = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk69"><span class="highlight"><span class="nb">refine</span> (_ oE equiv_sigma_symm _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{b : f y = x &amp;
{a : g (f y) = g x &amp;
transport (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; g x0 = g x) b
  (<span class="mi">1</span> @ ap idmap a) = <span class="mi">1</span>}} &lt;~&gt; f y = x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6a"><span class="highlight"><span class="nb">apply</span> equiv_sigma_contr; <span class="nb">intros</span> p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">f y = x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  {a : g (f y) = g x &amp;
  transport (<span class="kr">fun</span> <span class="nv">x0</span> : X =&gt; g x0 = g x) p
    (<span class="mi">1</span> @ ap idmap a) = <span class="mi">1</span>}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6b"><span class="highlight"><span class="nb">destruct</span> p; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g (f y)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr {a : g (f y) = g (f y) &amp; <span class="mi">1</span> @ ap idmap a = <span class="mi">1</span>}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6c"><span class="highlight"><span class="nb">refine</span> (contr_equiv&#39; { p : g (f y) = g (f y) &amp; p = <span class="mi">1</span>%path } _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g (f y)))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{p : g (f y) = g (f y) &amp; p = <span class="mi">1</span>} &lt;~&gt;
{a : g (f y) = g (f y) &amp; <span class="mi">1</span> @ ap idmap a = <span class="mi">1</span>}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6d"><span class="highlight"><span class="nb">apply</span> equiv_functor_sigma_id; <span class="nb">intros</span> p; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g (f y)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (f y) = g (f y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">p = <span class="mi">1</span> &lt;~&gt; <span class="mi">1</span> @ ap idmap p = <span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6e"><span class="highlight"><span class="nb">apply</span> equiv_concat_l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; IsConnMap O f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Y, X, Z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y -&gt; X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">X -&gt; Z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gfc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O (<span class="kr">fun</span> <span class="nv">x</span> : Y =&gt; g (f x))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">gc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O g</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Y</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">cc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnMap O
  (functor_hfiber (<span class="kr">fun</span> <span class="nv">a</span> : Y =&gt; <span class="mi">1</span>) (g (f y)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (f y) = g (f y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">1</span> @ ap idmap p = p</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (concat_1p _ @ ap_idmap _).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (i) implies lex-ness *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk6f"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lex_from_isconnected_paths</span>
             (<span class="nv">H</span> : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">Ac</span> : IsConnected O A) (<span class="nv">x</span> <span class="nv">y</span> : A),
                 IsConnected O (x = y))
    : Lex O.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected O (x = y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk70"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected O (x = y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk71"><span class="highlight"><span class="nb">apply</span> lex_from_conn_map_lex.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected O (x = y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt; IsConnected O B -&gt; IsConnMap O f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk72"><span class="highlight"><span class="nb">intros</span> A B f Ac Bc c.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
IsConnected O A -&gt;
<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : A, IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Ac</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected O (hfiber f c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">rapply isconnected_sigma.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (iv) implies lex-ness *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk73"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lex_from_isequiv_ismodal_isconnected_types</span>
             (<span class="nv">H</span> : <span class="kr">forall</span> <span class="nv">A</span> <span class="nv">B</span> (<span class="nv">f</span> : A -&gt; B),
                 (IsConnected O A) -&gt; (IsConnected O B) -&gt; 
                 (MapIn O f) -&gt; IsEquiv f)
    : Lex O.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk74"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk75"><span class="highlight"><span class="nb">apply</span> lex_from_conn_map_lex.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt; IsConnected O B -&gt; IsConnMap O f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk76"><span class="highlight"><span class="nb">intros</span> A B f AC BC.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap O f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk77"><span class="highlight"><span class="nb">apply</span> (conn_map_homotopic O _ _ (fact_factors (image O f))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap O
  (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt;
   factor2 (image O f) (factor1 (image O f) x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk78"><span class="highlight"><span class="nb">apply</span> conn_map_compose; [ <span class="bp">exact</span> _ | ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap O (factor2 (image O f))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk79"><span class="highlight"><span class="nb">apply</span> conn_map_isequiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (factor2 (image O f))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7a"><span class="highlight"><span class="nb">apply</span> H; [ | <span class="bp">exact</span> _ | <span class="bp">exact</span> _ ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnected O (image O f)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7b"><span class="highlight"><span class="nb">apply</span> isconnected_conn_map_to_unit.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsConnMap O (const tt)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> (cancelR_conn_map O (factor1 (image O f)) (const tt)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
  <span class="sd">(** RSS Theorem 3.1 (vii) implies lex-ness *)</span>
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7c"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lex_from_ispullback_connmap_mapino_commsq</span>
             (<span class="nv">H</span> : <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>}
                         (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D) (<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D),
                 (IsConnMap O f) -&gt; (IsConnMap O g) -&gt;
                 (MapIn O h) -&gt; (MapIn O k) -&gt;
                 <span class="kr">forall</span> (<span class="nv">p</span> : k o f == g o h), IsPullback p)
    : Lex O.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D)
(<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D),
IsConnMap O f -&gt;
IsConnMap O g -&gt;
MapIn O h -&gt;
MapIn O k -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : k o f == g o h, IsPullback p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7d"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D)
(<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D),
IsConnMap O f -&gt;
IsConnMap O g -&gt;
MapIn O h -&gt;
MapIn O k -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : k o f == g o h, IsPullback p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7e"><span class="highlight"><span class="nb">apply</span> lex_from_isequiv_ismodal_isconnected_types.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D)
(<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D),
IsConnMap O f -&gt;
IsConnMap O g -&gt;
MapIn O h -&gt;
MapIn O k -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : k o f == g o h, IsPullback p</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B),
IsConnected O A -&gt;
IsConnected O B -&gt; MapIn O f -&gt; IsEquiv f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk7f"><span class="highlight"><span class="nb">intros</span> A B f AC BC fM.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">g</span> : C -&gt; D)
(<span class="nv">h</span> : A -&gt; C) (<span class="nv">k</span> : B -&gt; D),
IsConnMap O f -&gt;
IsConnMap O g -&gt;
MapIn O h -&gt;
MapIn O k -&gt;
<span class="kr">forall</span> <span class="nv">p</span> : k o f == g o h, IsPullback p</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fM</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk80"><span class="highlight"><span class="nb">specialize</span> (H A Unit B Unit (const tt) (const tt) f idmap _ _ _ _
                  (<span class="kr">fun</span> <span class="nv">_</span> =&gt; <span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsPullback (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; <span class="mi">1</span>)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fM</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk81"><span class="highlight"><span class="nb">unfold</span> IsPullback, pullback_corec <span class="kr">in</span> H.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (const tt a; f a; <span class="mi">1</span>))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fM</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv f</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk82"><span class="highlight"><span class="nb">refine</span> (@isequiv_compose _ _ _ H _ (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x.<span class="mi">2</span>.<span class="mi">1</span>) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (const tt a; f a; <span class="mi">1</span>))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fM</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">x</span> : Pullback idmap (const tt) =&gt; (x.<span class="mi">2</span>).<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk83"><span class="highlight"><span class="nb">unfold</span> Pullback.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (const tt a; f a; <span class="mi">1</span>))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fM</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv
  (<span class="kr">fun</span> <span class="nv">x</span> : {b : Unit &amp; {c : B &amp; b = const tt c}} =&gt;
   (x.<span class="mi">2</span>).<span class="mi">1</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk84"><span class="highlight"><span class="nb">refine</span> (@isequiv_compose _ {b:Unit &amp; B}
                             (functor_sigma idmap (<span class="kr">fun</span> <span class="nv">a</span> =&gt; pr1))
                             _ _ pr2 _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (const tt a; f a; <span class="mi">1</span>))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fM</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv pr2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk85"><span class="highlight"><span class="nb">refine</span> (@isequiv_compose _ _ (equiv_sigma_prod0 Unit B)
                             _ _ snd _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A, B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A -&gt; B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsEquiv (<span class="kr">fun</span> <span class="nv">a</span> : A =&gt; (const tt a; f a; <span class="mi">1</span>))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">AC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">BC</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsConnected O B</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">fM</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv snd</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> (equiv_isequiv (prod_unit_l B)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">ImpliesLex</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Lex reflective subuniverses *)</span>

<span class="sd">(** A reflective subuniverse that preserves fibers is in fact a modality (and hence lex). *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk86"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ismodality_isequiv_O_functor_hfiber</span> (<span class="nv">O</span> : ReflectiveSubuniverse)
           (<span class="nv">H</span> : <span class="kr">forall</span> {<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>} (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
               IsEquiv (O_functor_hfiber O f b))
  : IsModality O.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsModality O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk87"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsModality O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk88"><span class="highlight"><span class="nb">intros</span> A&#39;; rapply reflectsD_from_inO_sigma.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">B</span> : O_reflector O A&#39; -&gt; <span class="kt">Type</span>,
(<span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)) -&gt;
In O {z : O_reflector O A&#39; &amp; B z}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk89"><span class="highlight"><span class="nb">intros</span> B B_inO.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In O {z : O_reflector O A&#39; &amp; B z}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8a"><span class="highlight"><span class="nb">pose</span> (A := O A&#39;).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In O {z : O_reflector O A&#39; &amp; B z}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8b"><span class="highlight"><span class="nb">pose</span> (g := O_rec pr1 : O {x : A &amp; B x} -&gt; A).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In O {z : O_reflector O A&#39; &amp; B z}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8c"><span class="highlight">transparent <span class="nb">assert</span> (p : (<span class="kr">forall</span> <span class="nv">x</span>, g (to O _ x) = x.<span class="mi">1</span>)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk8d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) 
(<span class="nv">b</span> : B), IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="nl">?Goal</span></span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk8d"><hr></label><div class="goal-conclusion"><span class="highlight">In O {z : O_reflector O A&#39; &amp; B z}</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8e"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> x; <span class="nb">subst</span> g; <span class="nb">apply</span> O_rec_beta.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk8f"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In O {z : O_reflector O A&#39; &amp; B z}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk90"><span class="highlight"><span class="nb">apply</span> inO_isequiv_to_O.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv (to O {z : O_reflector O A&#39; &amp; B z})</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk91"><span class="highlight"><span class="nb">apply</span> isequiv_contr_map; <span class="nb">intros</span> x.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr (hfiber (to O {z : O_reflector O A&#39; &amp; B z}) x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk92"><span class="highlight">snrefine (contr_equiv&#39; _ (hfiber_hfiber_compose_map _ g x)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Contr
  (hfiber
     (hfiber_compose_map
        (to O {z : O_reflector O A&#39; &amp; B z}) g (g x))
     (x; <span class="mi">1</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk93"><span class="highlight"><span class="nb">apply</span> contr_map_isequiv.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv
  (hfiber_compose_map
     (to O {z : O_reflector O A&#39; &amp; B z}) g (g x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk94"><span class="highlight"><span class="nb">unfold</span> hfiber_compose_map.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv
  (<span class="kr">fun</span>
     <span class="nv">x0</span> : hfiber
            (<span class="kr">fun</span> <span class="nv">x</span> : {z : O_reflector O A&#39; &amp; B z} =&gt;
             g (to O {z : O_reflector O A&#39; &amp; B z} x))
            (g x) =&gt;
   (to O {z : O_reflector O A&#39; &amp; B z} x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk95"><span class="highlight">transparent <span class="nb">assert</span> (h : (hfiber (@pr1 A B) (g x) &lt;~&gt; hfiber g (g x))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chk96" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) 
(<span class="nv">b</span> : B), IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="nl">?Goal</span></span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chk96"><hr></label><div class="goal-conclusion"><span class="highlight">IsEquiv
  (<span class="kr">fun</span>
     <span class="nv">x0</span> : hfiber
            (<span class="kr">fun</span> <span class="nv">x</span> : {z : O_reflector O A&#39; &amp; B z} =&gt;
             g (to O {z : O_reflector O A&#39; &amp; B z} x))
            (g x) =&gt;
   (to O {z : O_reflector O A&#39; &amp; B z} x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk97"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk98"><span class="highlight"><span class="nb">refine</span> (_ oE equiv_to_O O _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">O (hfiber pr1 (g x)) &lt;~&gt; hfiber g (g x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk99"><span class="highlight"><span class="nb">refine</span> (_ oE Build_Equiv _ _
              (O_functor_hfiber O (@pr1 A B) (g x)) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">hfiber (O_functor O pr1) (to O A (g x)) &lt;~&gt;
hfiber g (g x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9a"><span class="highlight"><span class="nb">unfold</span> hfiber.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">{x0 : O {x : _ &amp; B x} &amp;
O_functor O pr1 x0 = to O A (g x)} &lt;~&gt;
{x0 : O {x : A &amp; B x} &amp; g x0 = g x}</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9b"><span class="highlight"><span class="nb">apply</span> equiv_functor_sigma_id.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">a</span> : O {x : _ &amp; B x},
O_functor O pr1 a = to O A (g x) &lt;~&gt; g a = g x</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9c"><span class="highlight"><span class="nb">intros</span> y; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : _ &amp; B x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">O_functor O pr1 y = to O A (g x) &lt;~&gt; g y = g x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9d"><span class="highlight"><span class="nb">refine</span> (_ oE (equiv_moveR_equiv_V _ _)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : _ &amp; B x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(to O A)^-<span class="mi">1</span> (O_functor O pr1 y) = g x &lt;~&gt; g y = g x</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9e"><span class="highlight"><span class="nb">apply</span> equiv_concat_l.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : _ &amp; B x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">g y = (to O A)^-<span class="mi">1</span> (O_functor O pr1 y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chk9f"><span class="highlight"><span class="nb">apply</span> moveL_equiv_V.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : _ &amp; B x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">to O A (g y) = O_functor O pr1 y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka0"><span class="highlight"><span class="nb">unfold</span> g, O_functor.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : _ &amp; B x}</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">to O A (O_rec pr1 y) =
O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>) y</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka1"><span class="highlight"><span class="nb">revert</span> y; <span class="nb">apply</span> O_indpaths; <span class="nb">intros</span> [a q]; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">to O A (O_rec pr1 (to O {x : _ &amp; B x} (a; q))) =
O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
  (to O {x : _ &amp; B x} (a; q))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka2"><span class="highlight"><span class="nb">refine</span> (_ @ (O_rec_beta _ _)^).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">to O A (O_rec pr1 (to O {x : _ &amp; B x} (a; q))) =
to O A a</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> ap, O_rec_beta.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka3"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_functor_sigma_id
  (<span class="kr">fun</span> <span class="nv">y</span> : O {x : _ &amp; B x} =&gt;
   equiv_concat_l
     (moveL_equiv_V (O_functor O pr1 y) 
        (g y)
        (O_indpaths
           (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
            to O A (O_rec pr1 x))
           (O_rec
              (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
           (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
            (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">q</span> : B a) =&gt;
             ap (to O A) (O_rec_beta pr1 (a; q)) @
             (O_rec_beta
                (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt;
                 to O A x.<span class="mi">1</span>) 
                (a; q))^) x0.<span class="mi">1</span> x0.<span class="mi">2</span>) y)) 
     (g x)
   oE equiv_moveR_equiv_V (O_functor O pr1 y) (g x))
oE {|
     equiv_fun := O_functor_hfiber O pr1 (g x);
     equiv_isequiv := H {x : _ &amp; B x} A pr1 (g x)
   |} oE equiv_to_O O (hfiber pr1 (g x))</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsEquiv
  (<span class="kr">fun</span>
     <span class="nv">x0</span> : hfiber
            (<span class="kr">fun</span> <span class="nv">x</span> : {z : O_reflector O A&#39; &amp; B z} =&gt;
             g (to O {z : O_reflector O A&#39; &amp; B z} x))
            (g x) =&gt;
   (to O {z : O_reflector O A&#39; &amp; B z} x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka4"><span class="highlight"><span class="nb">refine</span> (isequiv_homotopic (h oE equiv_hfiber_homotopic _ _ p (g x)) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_functor_sigma_id
  (<span class="kr">fun</span> <span class="nv">y</span> : O {x : _ &amp; B x} =&gt;
   equiv_concat_l
     (moveL_equiv_V (O_functor O pr1 y) 
        (g y)
        (O_indpaths
           (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
            to O A (O_rec pr1 x))
           (O_rec
              (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
           (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
            (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">q</span> : B a) =&gt;
             ap (to O A) (O_rec_beta pr1 (a; q)) @
             (O_rec_beta
                (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt;
                 to O A x.<span class="mi">1</span>) 
                (a; q))^) x0.<span class="mi">1</span> x0.<span class="mi">2</span>) y)) 
     (g x)
   oE equiv_moveR_equiv_V (O_functor O pr1 y) (g x))
oE {|
     equiv_fun := O_functor_hfiber O pr1 (g x);
     equiv_isequiv := H {x : _ &amp; B x} A pr1 (g x)
   |} oE equiv_to_O O (hfiber pr1 (g x))</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">h
oE equiv_hfiber_homotopic
     (<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt;
      g (to O {x0 : A &amp; B x0} x)) pr1 p (g x) ==
(<span class="kr">fun</span>
   <span class="nv">x0</span> : hfiber
          (<span class="kr">fun</span> <span class="nv">x</span> : {z : O_reflector O A&#39; &amp; B z} =&gt;
           g (to O {z : O_reflector O A&#39; &amp; B z} x))
          (g x) =&gt;
 (to O {z : O_reflector O A&#39; &amp; B z} x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka5"><span class="highlight"><span class="nb">intros</span> [[a b] q]; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">h</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">equiv_functor_sigma_id
  (<span class="kr">fun</span> <span class="nv">y</span> : O {x : _ &amp; B x} =&gt;
   equiv_concat_l
     (moveL_equiv_V (O_functor O pr1 y) 
        (g y)
        (O_indpaths
           (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
            to O A (O_rec pr1 x))
           (O_rec
              (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
           (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
            (<span class="kr">fun</span> (<span class="nv">a</span> : A) (<span class="nv">q</span> : B a) =&gt;
             ap (to O A) (O_rec_beta pr1 (a; q)) @
             (O_rec_beta
                (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt;
                 to O A x.<span class="mi">1</span>) 
                (a; q))^) x0.<span class="mi">1</span> x0.<span class="mi">2</span>) y)) 
     (g x)
   oE equiv_moveR_equiv_V (O_functor O pr1 y) (g x))
oE {|
     equiv_fun := O_functor_hfiber O pr1 (g x);
     equiv_isequiv := H {x : _ &amp; B x} A pr1 (g x)
   |} oE equiv_to_O O (hfiber pr1 (g x))</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">hfiber pr1 (g x) &lt;~&gt; hfiber g (g x)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">a</span> : O {x : _ &amp; B x})
     (<span class="nv">x0</span> : O_functor O pr1 a = to O A (g x)) =&gt;
   moveL_equiv_V (O_functor O pr1 a) (g a)
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
         to O A (O_rec pr1 x))
        (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
        (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; B x} =&gt;
         ap (to O A) (O_rec_beta pr1 (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>)) @
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>))^) a) @
   moveR_equiv_V (O_functor O pr1 a) (g x) x0)
  (O_functor_hfiber O pr1 (g x)
     (to O (hfiber pr1 (g x))
        ((a; b); (p (a; b))^ @ q))) =
(to O {z : O_reflector O A&#39; &amp; B z} (a; b); q)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka6"><span class="highlight"><span class="nb">clear</span> h.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">a</span> : O {x : _ &amp; B x})
     (<span class="nv">x0</span> : O_functor O pr1 a = to O A (g x)) =&gt;
   moveL_equiv_V (O_functor O pr1 a) (g a)
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
         to O A (O_rec pr1 x))
        (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
        (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; B x} =&gt;
         ap (to O A) (O_rec_beta pr1 (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>)) @
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>))^) a) @
   moveR_equiv_V (O_functor O pr1 a) (g x) x0)
  (O_functor_hfiber O pr1 (g x)
     (to O (hfiber pr1 (g x))
        ((a; b); (p (a; b))^ @ q))) =
(to O {z : O_reflector O A&#39; &amp; B z} (a; b); q)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka7"><span class="highlight"><span class="nb">unfold</span> O_functor_hfiber.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">a</span> : O {x : _ &amp; B x})
     (<span class="nv">x0</span> : O_functor O pr1 a = to O A (g x)) =&gt;
   moveL_equiv_V (O_functor O pr1 a) (g a)
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
         to O A (O_rec pr1 x))
        (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
        (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; B x} =&gt;
         ap (to O A) (O_rec_beta pr1 (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>)) @
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>))^) a) @
   moveR_equiv_V (O_functor O pr1 a) (g x) x0)
  (O_rec
     (<span class="kr">fun</span> <span class="nv">X</span> : hfiber pr1 (g x) =&gt;
      (to O {x : _ &amp; B x} X.<span class="mi">1</span>;
      to_O_natural O pr1 X.<span class="mi">1</span> @ ap (to O A) X.<span class="mi">2</span>))
     (to O (hfiber pr1 (g x))
        ((a; b); (p (a; b))^ @ q))) =
(to O {z : O_reflector O A&#39; &amp; B z} (a; b); q)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka8"><span class="highlight"><span class="nb">rewrite</span> O_rec_beta.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">functor_sigma idmap
  (<span class="kr">fun</span> (<span class="nv">a</span> : O {x : _ &amp; B x})
     (<span class="nv">x0</span> : O_functor O pr1 a = to O A (g x)) =&gt;
   moveL_equiv_V (O_functor O pr1 a) (g a)
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
         to O A (O_rec pr1 x))
        (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
        (<span class="kr">fun</span> <span class="nv">x1</span> : {x : _ &amp; B x} =&gt;
         ap (to O A) (O_rec_beta pr1 (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>)) @
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (x1.<span class="mi">1</span>; x1.<span class="mi">2</span>))^) a) @
   moveR_equiv_V (O_functor O pr1 a) (g x) x0)
  (to O {x : _ &amp; B x} (a; b);
  to_O_natural O pr1 (a; b) @
  ap (to O A) ((p (a; b))^ @ q)) =
(to O {z : O_reflector O A&#39; &amp; B z} (a; b); q)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chka9"><span class="highlight"><span class="nb">unfold</span> functor_sigma; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(to O {x : _ &amp; B x} (a; b);
moveL_equiv_V
  (O_functor O pr1 (to O {x : _ &amp; B x} (a; b)))
  (g (to O {x : _ &amp; B x} (a; b)))
  (O_indpaths
     (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
      to O A (O_rec pr1 x))
     (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
     (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
      ap (to O A) (O_rec_beta pr1 (x0.<span class="mi">1</span>; x0.<span class="mi">2</span>)) @
      (O_rec_beta
         (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
         (x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))^) (to O {x : _ &amp; B x} (a; b))) @
moveR_equiv_V
  (O_functor O pr1 (to O {x : _ &amp; B x} (a; b))) (g x)
  (to_O_natural O pr1 (a; b) @
   ap (to O A) ((p (a; b))^ @ q))) =
(to O {z : O_reflector O A&#39; &amp; B z} (a; b); q)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkaa"><span class="highlight"><span class="nb">refine</span> (path_sigma&#39; _ <span class="mi">1</span> _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">transport (<span class="kr">fun</span> <span class="nv">x0</span> : O {x : A &amp; B x} =&gt; g x0 = g x) <span class="mi">1</span>
  (moveL_equiv_V
     (O_functor O pr1 (to O {x : _ &amp; B x} (a; b)))
     (g (to O {x : _ &amp; B x} (a; b)))
     (O_indpaths
        (<span class="kr">fun</span> <span class="nv">x</span> : O_reflector O {x : _ &amp; B x} =&gt;
         to O A (O_rec pr1 x))
        (O_rec (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>))
        (<span class="kr">fun</span> <span class="nv">x0</span> : {x : _ &amp; B x} =&gt;
         ap (to O A) (O_rec_beta pr1 (x0.<span class="mi">1</span>; x0.<span class="mi">2</span>)) @
         (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (x0.<span class="mi">1</span>; x0.<span class="mi">2</span>))^)
        (to O {x : _ &amp; B x} (a; b))) @
   moveR_equiv_V
     (O_functor O pr1 (to O {x : _ &amp; B x} (a; b)))
     (g x)
     (to_O_natural O pr1 (a; b) @
      ap (to O A) ((p (a; b))^ @ q))) = q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkab"><span class="highlight"><span class="nb">rewrite</span> O_indpaths_beta; <span class="nb">cbn</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">moveL_equiv_V
  (O_functor O pr1 (to O {x : _ &amp; B x} (a; b)))
  (g (to O {x : _ &amp; B x} (a; b)))
  (ap (to O A) (O_rec_beta pr1 (a; b)) @
   (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
      (a; b))^) @
moveR_equiv_V
  (O_functor O pr1 (to O {x : _ &amp; B x} (a; b))) (g x)
  (to_O_natural O pr1 (a; b) @
   ap (to O A) ((p (a; b))^ @ q)) = q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkac"><span class="highlight"><span class="nb">unfold</span> moveL_equiv_V, moveR_equiv_V.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">((eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^ @
 ap (to O A)^-<span class="mi">1</span>
   (ap (to O A) (O_rec_beta pr1 (a; b)) @
    (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
       (a; b))^)) @
(ap (to O A)^-<span class="mi">1</span>
   (to_O_natural O pr1 (a; b) @
    ap (to O A) ((p (a; b))^ @ q)) @
 eissect (to O A) (g x)) = q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkad"><span class="highlight"><span class="kn">Open Scope</span> long_path_scope.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b))
      @&#39; (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (a; b))^)
@&#39; (ap (to O A)^-<span class="mi">1</span>
      (to_O_natural O pr1 (a; b)
       @&#39; ap (to O A) ((p (a; b))^
                       @&#39; q))
    @&#39; eissect (to O A) (g x)) = q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkae"><span class="highlight"><span class="kn">Local</span> <span class="kn">Opaque</span> eissect. <span class="c">(* work around bug 4533 *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b))
      @&#39; (O_rec_beta
            (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
            (a; b))^)
@&#39; (ap (to O A)^-<span class="mi">1</span>
      (to_O_natural O pr1 (a; b)
       @&#39; ap (to O A) ((p (a; b))^
                       @&#39; q))
    @&#39; eissect (to O A) (g x)) = q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkaf"><span class="highlight"><span class="nb">rewrite</span> !ap_pp, !concat_p_pp, !ap_V.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b)))
@&#39; (ap (to O A)^-<span class="mi">1</span>
      (O_rec_beta
         (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>) (a; b)))^
@&#39; ap (to O A)^-<span class="mi">1</span> (to_O_natural O pr1 (a; b))
@&#39; (ap (to O A)^-<span class="mi">1</span> (ap (to O A) (p (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) = q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb0"><span class="highlight"><span class="nb">unfold</span> to_O_natural.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b)))
@&#39; (ap (to O A)^-<span class="mi">1</span>
      (O_rec_beta
         (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>) (a; b)))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (O_rec_beta (<span class="kr">fun</span> <span class="nv">x</span> : {x : _ &amp; B x} =&gt; to O A x.<span class="mi">1</span>)
        (a; b))
@&#39; (ap (to O A)^-<span class="mi">1</span> (ap (to O A) (p (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) = q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb1"><span class="highlight"><span class="nb">rewrite</span> concat_pV_p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight"><span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x</span> : {x : A &amp; B x},
g (to O {x0 : A &amp; B x0} x) = x.<span class="mi">1</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b)))
@&#39; (ap (to O A)^-<span class="mi">1</span> (ap (to O A) (p (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) = q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb2"><span class="highlight"><span class="nb">subst</span> p.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span>
     (ap (to O A) (O_rec_beta pr1 (a; b)))
@&#39; (ap (to O A)^-<span class="mi">1</span>
      (ap (to O A)
         ((<span class="kr">fun</span> <span class="nv">x</span> : {x : A &amp; B x} =&gt; O_rec_beta pr1 x)
            (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) = q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb3"><span class="highlight"><span class="nb">rewrite</span> concat_pp_V.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(eissect (to O A) (g (to O {x : _ &amp; B x} (a; b))))^
@&#39; ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) = q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb4"><span class="highlight"><span class="nb">rewrite</span> concat_pp_p; <span class="nb">apply</span> moveR_Vp.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (to O A)^-<span class="mi">1</span> (ap (to O A) q)
@&#39; eissect (to O A) (g x) =
eissect (to O A) (g (to O {x : _ &amp; B x} (a; b)))
@&#39; q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb5"><span class="highlight"><span class="nb">rewrite</span> &lt;- !(ap_compose (to O A) (to O A)^-<span class="mi">1</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">ReflectiveSubuniverse</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B) (<span class="nv">b</span> : B),
IsEquiv (O_functor_hfiber O f b)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A'</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O A&#39; -&gt; <span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">B_inO</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">oa</span> : O_reflector O A&#39;, In O (B oa)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O A&#39;</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">g</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">O_rec pr1 : O {x : A &amp; B x} -&gt; A</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O {x : A &amp; B x} -&gt; A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">O_reflector O {z : O_reflector O A&#39; &amp; B z}</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">a</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">B a</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">q</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">g (to O {x : A &amp; B x} (a; b)) = g x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ap (<span class="kr">fun</span> <span class="nv">x</span> : A =&gt; (to O A)^-<span class="mi">1</span> (to O A x)) q
@&#39; eissect (to O A) (g x) =
eissect (to O A) (g (to O {x : _ &amp; B x} (a; b)))
@&#39; q</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">rapply @concat_A1p.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Local</span> <span class="kn">Transparent</span> eissect. <span class="c">(* work around bug 4533 *)</span></span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Close Scope</span> long_path_scope.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** Lexness via generators *)</span>

<span class="sd">(** Here the characterization of when an accessible presentation yields a lex modality from Anel-Biederman-Finster-Joyal (&quot;Higher Sheaves and Left-Exact Localizations of ‚àû-Topoi&quot;, arXiv:2101.02791): it&#39;s enough for path spaces of the generators to be connected. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb6"><span class="highlight"><span class="kn">Definition</span> <span class="nf">lex_gen</span> `{Univalence} (O : Modality) `{IsAccModality O}
           (lexgen : <span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O)) (<span class="nv">x</span> <span class="nv">y</span> : ngen_type (acc_ngen O) i),
               IsConnected O (x = y))
  : Lex O.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Lex O</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb8"><span class="highlight">srapply lex_from_inO_typeO; [ <span class="bp">exact</span> _ | <span class="nb">intros</span> i ].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">ooExtendableAlong (acc_lgen O i)
  (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt; Type_ O)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkb9"><span class="highlight">rapply ooextendable_TypeO_from_extension; <span class="nb">intros</span> P; srefine (_;_).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> : lgen_codomain (acc_lgen O) i,
(<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt; Type_ O) y</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chkba"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : lgen_codomain (acc_lgen O) i,
       (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
        Type_ O) y =&gt;
 <span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i,
 s (acc_lgen O i x) = P x) 
  <span class="nl">?proj1</span></span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkbb"><span class="highlight"><span class="mi">1</span>:<span class="nb">intros</span>; <span class="kr">exists</span> (<span class="nv">forall</span> <span class="nv">x</span>, P x); <span class="bp">exact</span> _.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : lgen_codomain (acc_lgen O) i,
       (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
        Type_ O) y =&gt;
 <span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i,
 s (acc_lgen O i x) = P x)
  (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
   (<span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i, P x;
   inO_forall O (lgen_domain (acc_lgen O) i)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt; P x)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
      inO_TypeO (P x))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkbc"><span class="highlight"><span class="nb">assert</span> (wc : <span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span>, P y &lt;~&gt; P z).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i, P y &lt;~&gt; P z</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chkbd"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : lgen_codomain (acc_lgen O) i,
       (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
        Type_ O) y =&gt;
 <span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i,
 s (acc_lgen O i x) = P x)
  (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
   (<span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i, P x;
   inO_forall O (lgen_domain (acc_lgen O) i)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt; P x)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
      inO_TypeO (P x))))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkbe"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i, P y &lt;~&gt; P z</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkbf"><span class="highlight"><span class="nb">intros</span> y z.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y, z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P y &lt;~&gt; P z</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">    <span class="sd">(** Here we use the hypothesis [lexgen] (typeclass inference finds it automatically). *)</span>
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">refine</span> (pr1 (isconnected_elim O _ (@equiv_transport _ P y z))).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc0"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   <span class="nv">s</span> : <span class="kr">forall</span> <span class="nv">y</span> : lgen_codomain (acc_lgen O) i,
       (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
        Type_ O) y =&gt;
 <span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i,
 s (acc_lgen O i x) = P x)
  (<span class="kr">fun</span> <span class="nv">_</span> : lgen_codomain (acc_lgen O) i =&gt;
   (<span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i, P x;
   inO_forall O (lgen_domain (acc_lgen O) i)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt; P x)
     (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
      inO_TypeO (P x))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc1"><span class="highlight"><span class="nb">intros</span> x; <span class="nb">apply</span> path_TypeO, path_universe_uncurried.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i, P x;
inO_forall O (lgen_domain (acc_lgen O) i)
  (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt; P x)
  (<span class="kr">fun</span> <span class="nv">x</span> : lgen_domain (acc_lgen O) i =&gt;
   inO_TypeO (P x))).<span class="mi">1</span> &lt;~&gt; 
(P x).<span class="mi">1</span></span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc2"><span class="highlight"><span class="nb">refine</span> (equiv_adjointify (<span class="kr">fun</span> <span class="nv">f</span> =&gt; f x) (<span class="kr">fun</span> <span class="nv">u</span> <span class="nv">y</span> =&gt; wc x y ((wc x x)^-<span class="mi">1</span> u)) _ _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x0</span> : P x =&gt; wc x x ((wc x x)^-<span class="mi">1</span> x0)) == idmap</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chkc3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chkc3"><hr></label><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   (<span class="nv">x0</span> : <span class="kr">forall</span> <span class="nv">x0</span> : lgen_domain (acc_lgen O) i, P x0)
   (<span class="nv">y</span> : lgen_domain (acc_lgen O) i) =&gt;
 wc x y ((wc x x)^-<span class="mi">1</span> (x0 x))) == idmap</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc4"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x0</span> : P x =&gt; wc x x ((wc x x)^-<span class="mi">1</span> x0)) == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> u; <span class="nb">apply</span> eisretr.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc5"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span>
   (<span class="nv">x0</span> : <span class="kr">forall</span> <span class="nv">x0</span> : lgen_domain (acc_lgen O) i, P x0)
   (<span class="nv">y</span> : lgen_domain (acc_lgen O) i) =&gt;
 wc x y ((wc x x)^-<span class="mi">1</span> (x0 x))) == idmap</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc6"><span class="highlight"><span class="nb">intros</span> f; <span class="nb">apply</span> path_forall; <span class="nb">intros</span> y; <span class="nb">apply</span> moveR_equiv_M.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : lgen_domain (acc_lgen O) i, P x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(wc x x)^-<span class="mi">1</span> (f x) = (wc x y)^-<span class="mi">1</span> (f y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc7"><span class="highlight"><span class="nb">destruct</span> (isconnected_elim O _ (<span class="kr">fun</span> <span class="nv">y</span> =&gt; (wc x y)^-<span class="mi">1</span> (f y))) <span class="kr">as</span> [z p].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Univalence</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsAccModality O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lexgen</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">i</span> : ngen_indices (acc_ngen O))
(<span class="nv">x</span> <span class="nv">y</span> : acc_ngen O i), IsConnected O (x = y)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_indices (acc_lgen O)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i -&gt; Type_ O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">wc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">y</span> <span class="nv">z</span> : lgen_domain (acc_lgen O) i,
P y &lt;~&gt; P z</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">f</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : lgen_domain (acc_lgen O) i, P x0</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">lgen_domain (acc_lgen O) i</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">z</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P x</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">x0</span> : lgen_domain (acc_lgen O) i,
(wc x x0)^-<span class="mi">1</span> (f x0) = z</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(wc x x)^-<span class="mi">1</span> (f x) = (wc x y)^-<span class="mi">1</span> (f y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span> (p x @ (p y)^).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** ** n-fold separation *)</span>

<span class="sd">(** A type is [n]-[O]-separated, for n &gt;= -2, if all its (n+2)-fold iterated identity types are [O]-modal.  Inductively, this means that it is (-2)-O-separated if it is O-modal, and (n+1)-O-separated if its identity types are n-O-separated. *)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Fixpoint</span> <span class="nf">nSep</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">O</span> : Subuniverse) : Subuniverse
  := <span class="kr">match</span> n <span class="kr">with</span>
     | -<span class="mi">2</span> =&gt; O
     | n.+<span class="mi">1</span> =&gt; Sep (nSep n O)
     <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="sd">(** The reason for indexing this notion by a [trunc_index] rather than a [nat] is that when O is lex, a type is n-O-separated if and only if its O-unit is an n-truncated map. *)</span>
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc8"><span class="highlight"><span class="kn">Definition</span> <span class="nf">nsep_iff_trunc_to_O</span> (<span class="nv">n</span> : trunc_index) (<span class="nv">O</span> : Modality) `{Lex O} (A : <span class="kt">Type</span>)
  : In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkc9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkca"><span class="highlight"><span class="nb">revert</span> A; <span class="nb">induction</span> n <span class="kr">as</span> [|n IHn]; <span class="nb">intros</span> A; <span class="nb">split</span>; <span class="nb">intros</span> ?.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (nSep (-<span class="mi">2</span>) O) A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTruncMap (-<span class="mi">2</span>) (to O A)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chkcb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap (-<span class="mi">2</span>) (to O A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chkcb"><hr></label><div class="goal-conclusion"><span class="highlight">In (nSep (-<span class="mi">2</span>) O) A</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chkcc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (nSep n.+<span class="mi">1</span> O) A</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chkcc"><hr></label><div class="goal-conclusion"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lex-v-chkcd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chkcd"><hr></label><div class="goal-conclusion"><span class="highlight">In (nSep n.+<span class="mi">1</span> O) A</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkce"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (nSep (-<span class="mi">2</span>) O) A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTruncMap (-<span class="mi">2</span>) (to O A)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> contr_map_isequiv; rapply isequiv_to_O_inO.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkcf"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap (-<span class="mi">2</span>) (to O A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (nSep (-<span class="mi">2</span>) O) A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> (inO_equiv_inO (O A) (to O A)^-<span class="mi">1</span>).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd0"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (nSep n.+<span class="mi">1</span> O) A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd1"><span class="highlight"><span class="nb">apply</span> istruncmap_from_ap; <span class="nb">intros</span> x y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (nSep n.+<span class="mi">1</span> O) A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTruncMap n (ap (to O A))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd2"><span class="highlight"><span class="nb">pose</span> (i := fst (IHn (x = y)) _).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">In (nSep n.+<span class="mi">1</span> O) A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">fst (IHn (x = y)) (inO_paths_SepO (nSep n O) x y)</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n (to O (x = y))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTruncMap n (ap (to O A))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> istruncmap_mapinO_tr, (mapinO_homotopic _ _ (equiv_path_O_to_O O x y)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd3"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (nSep n.+<span class="mi">1</span> O) A</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd4"><span class="highlight"><span class="nb">intros</span> x y.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">In (nSep n O) (x = y)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd5"><span class="highlight"><span class="nb">apply</span> (snd (IHn (x = y))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTruncMap n (to O (x = y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd6"><span class="highlight"><span class="nb">pose</span> (i := istruncmap_ap n (to O A) x y).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">istruncmap_ap n (to O A) x y</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n (ap (to O A))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTruncMap n (to O (x = y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd7"><span class="highlight"><span class="nb">apply</span> mapinO_tr_istruncmap <span class="kr">in</span> i.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn (Tr n) (ap (to O A))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">IsTruncMap n (to O (x = y))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkd8"><span class="highlight"><span class="nb">apply</span> istruncmap_mapinO_tr, (mapinO_homotopic _ ((equiv_path_O O x y)^-<span class="mi">1</span> o (@ap _ _ (to O A) x y))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn (Tr n) (ap (to O A))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
 (equiv_path_O O x y)^-<span class="mi">1</span> (ap (to O A) x0)) ==
to O (x = y)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lex-v-chkd9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn (Tr n) (ap (to O A))</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lex-v-chkd9"><hr></label><div class="goal-conclusion"><span class="highlight">MapIn (Tr n)
  (<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
   (equiv_path_O O x y)^-<span class="mi">1</span> (ap (to O A) x0))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkda"><span class="highlight">{</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn (Tr n) (ap (to O A))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
 (equiv_path_O O x y)^-<span class="mi">1</span> (ap (to O A) x0)) ==
to O (x = y)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intros</span> p; <span class="nb">apply</span> moveR_equiv_V; <span class="nb">symmetry</span>; <span class="nb">apply</span> equiv_path_O_to_O.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkdb"><span class="highlight">}</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn (Tr n) (ap (to O A))</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">MapIn (Tr n)
  (<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
   (equiv_path_O O x y)^-<span class="mi">1</span> (ap (to O A) x0))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lex-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="lex-v-chkdc"><span class="highlight"><span class="nb">pose</span> mapinO_isequiv. <span class="c">(* This speeds up the next line. *)</span></span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">trunc_index</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">O</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Modality</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Lex0</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">Lex O</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> <span class="nv">A</span> : <span class="kt">Type</span>,
In (nSep n O) A &lt;-&gt; IsTruncMap n (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">A</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">IsTruncMap n.+<span class="mi">1</span> (to O A)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">A</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MapIn (Tr n) (ap (to O A))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">m</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">mapinO_isequiv</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kr">forall</span> (<span class="nv">O</span> : ReflectiveSubuniverse) 
(<span class="nv">A</span> <span class="nv">B</span> : <span class="kt">Type</span>) (<span class="nv">f</span> : A -&gt; B), 
IsEquiv f -&gt; MapIn O f</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">MapIn (Tr n)
  (<span class="kr">fun</span> <span class="nv">x0</span> : x = y =&gt;
   (equiv_path_O O x y)^-<span class="mi">1</span> (ap (to O A) x0))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">rapply mapinO_compose.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span></span></pre>
</div>
</div></body>
</html>
